{"gt": "U", "requirement": "Given a number s(in string form). Find the Smallest number (Not leading Zeros) which can be obtained by rearranging the digits of given number.\n \nExample 1:\nInput: s = \"846903\"\nOutput: 304689\nExplanation: 304689 is the smallest number\nby rearranging the digits.\nExample 2:\nInput: s = \"55010\"\nOutput: 10055\nExplanation: 10055 is the smallest number \nby rearranging the digts.\n \nYour Task:\nYou don't need to read or print anything. Your task is to complete the function minimum_number() which takes the number as input parameter and returns the smallest number than can be formed without leading zeros by rearranging the digits of the number.\n \nExpected Time Complexity: O(N * log(N)) where N is the number of digits of the given number\nExpected Space Complexity: O(1)\n \nConstraints:\n1 <= N <= 10^{5}", "solutions": ["def minimum_number(s):\n    l = list(s)\n    l.sort()\n    for i in range(len(l)):\n        if int(l[i]) > 0:\n            (l[0], l[i]) = (l[i], l[0])\n            break\n    n = ''\n    for i in l:\n        n += i\n    return n", "def minimum_number(s):\n    d = {}\n    for i in s:\n        i = int(i)\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    t = list(d.keys())\n    t.sort()\n    if len(t) == 1:\n        return str(t[0]) * d[t[0]]\n    res = str(t[1] * 10 + t[0])\n    (d[t[0]], d[t[1]]) = (d[t[0]] - 1, d[t[1]] - 1)\n    for i in t:\n        res += str(i) * d[int(i)]\n    return res", "def minimum_number(s):\n    sort = sorted(s)\n    s = ''\n    i = 0\n    while sort[i] == '0' and i < len(sort) - 1:\n        i += 1\n    if i == len(sort):\n        for ele in sort:\n            s += ele\n    temp = sort[0]\n    sort[0] = sort[i]\n    sort[i] = temp\n    for ele in sort:\n        s += ele\n    return s", "def minimum_number(s):\n    arr = []\n    new = []\n    s = list(s)\n    for i in s:\n        if int(i) == 0:\n            new.append(int(i))\n        else:\n            arr.append(int(i))\n    if len(new) == len(s):\n        return ''.join(s)\n    arr.sort()\n    new1 = [arr.pop(0)]\n    new1.extend(new)\n    new1.extend(arr)\n    ans = ''\n    for i in new1:\n        ans += str(i)\n    ans = int(ans)\n    return ans", "def minimum_number(s):\n    j = sorted(s)\n    p = ''\n    if j[0] != '0':\n        return p.join(j)\n    else:\n        for i in range(len(j)):\n            if j[i] != '0':\n                temp = j[0]\n                j[0] = j[i]\n                j[i] = temp\n                break\n    return p.join(j)", "def minimum_number(s):\n    m = sorted(s)\n    for i in range(len(m)):\n        if int(m[i]) > 0:\n            (m[0], m[i]) = (m[i], m[0])\n            break\n    sr = ''\n    for i in m:\n        sr += i\n    return sr", "def minimum_number(s):\n    lst = list(s)\n    lst.sort()\n    tmp = ''\n    for (i, n) in enumerate(lst):\n        if n != '0':\n            tmp = lst.pop(i)\n            break\n    return str(tmp) + ''.join(lst)", "def minimum_number(s):\n    l = list(s)\n    l.sort()\n    tmp = ''\n    for (i, ele) in enumerate(l):\n        if ele != '0':\n            tmp = str(l.pop(i))\n            break\n    return str(tmp) + ''.join(l)", "def minimum_number(s):\n    n = len(s)\n    lst = list(map(int, s))\n    lst.sort()\n    for i in range(n):\n        if lst[i] != 0:\n            (lst[0], lst[i]) = (lst[i], lst[0])\n            break\n    ans = ''\n    for i in lst:\n        ans += str(i)\n    return ans", "import functools\n\ndef minimum_number(s):\n    c = 0\n    arr = []\n    for i in s:\n        if i != 0:\n            arr.append(i)\n        if i == '0':\n            c += 1\n    if c == len(s):\n        return s\n\n    def fuc(a, b):\n        if a + b > b + a:\n            return 1\n        else:\n            return -1\n    arr.sort()\n    news = str(int(''.join(arr)))\n    if c == 0:\n        return news\n    else:\n        return news[0] + '0' * c + news[1:]", "def minimum_number(s):\n    num = sorted(s)\n    t = 0\n    for i in num:\n        if i == '0':\n            t += 1\n        else:\n            break\n    num = num[t:]\n    if len(num) > 0:\n        x = num[0]\n    else:\n        return '0' * t\n    num = ['0'] * t + num[1:]\n    num.insert(0, x)\n    return ''.join(num)", "def minimum_number(s):\n    g = s.count('0')\n    l = s.replace('0', '')\n    if len(l) == 0:\n        return s\n    l = sorted(l)\n    l.sort()\n    h = [l[0]]\n    for i in range(g):\n        h.append('0')\n    for i in range(1, len(l)):\n        h.append(l[i])\n    return ''.join(h)", "def minimum_number(s):\n    x = [i for i in s]\n    x.sort()\n    c = 0\n    for i in range(len(x)):\n        if x[i] != '0':\n            c = i\n            break\n    (x[0], x[c]) = (x[c], x[0])\n    return ''.join(x)", "def minimum_number(s):\n    snum = sorted(list(s))\n    czero = snum.count('0')\n    if czero == len(snum):\n        return s\n    snum[0] = snum[czero]\n    snum[czero] = '0'\n    return ''.join(snum)", "def minimum_number(s):\n    lst = []\n    for c in s:\n        lst.append(c)\n    lst.sort()\n    n = len(lst)\n    i = 0\n    while i < n and lst[i] == '0':\n        i += 1\n    if i == n:\n        return int(''.join(lst))\n    else:\n        (lst[0], lst[i]) = (lst[i], lst[0])\n        return int(''.join(lst))", "def minimum_number(s):\n    arr = list(s)\n    arr.sort()\n    for i in range(len(arr)):\n        if arr[i] != '0':\n            temp = arr[i]\n            arr.pop(i)\n            break\n    if len(arr) == len(s):\n        return s\n    else:\n        return temp + ''.join(arr)", "def minimum_number(s):\n    res = [int(x) for x in str(s)]\n    mo = ''\n    res.sort()\n    if res[len(res) - 2] == 0:\n        res.sort(reverse=True)\n        for s in res:\n            mo = mo + str(s)\n        return int(mo)\n    if res[0] == 0:\n        for i in range(len(res) - 1):\n            if res[i] > 0:\n                res[0] = res[i]\n                res[i] = 0\n                break\n    for s in res:\n        mo = mo + str(s)\n    return int(mo)", "def minimum_number(s):\n    s = list(s)\n    s.sort()\n    ind = 0\n    leng = len(s)\n    while ind < leng and s[ind] == '0':\n        ind += 1\n    if ind == leng:\n        return int(''.join(s))\n    p = s.pop(ind)\n    s.insert(0, p)\n    return int(''.join(s))", "def minimum_number(s):\n    dic = {}\n    for el in range(10):\n        dic[str(el)] = 0\n    if s[0] != '-':\n        for el in s:\n            dic[el] += 1\n        newS = ''\n        for el in range(1, 10):\n            newS += str(el) * dic[str(el)]\n        if dic['0'] != 0 and len(newS) > 0:\n            newS = newS[0] + '0' * dic['0'] + newS[1:]\n        elif dic['0'] != 0 and len(newS) == 0:\n            newS += '0' * dic['0']\n        return newS\n    else:\n        for el in s[1:]:\n            dic[el] += 1\n        newS = ''\n        for el in range(9, -1, -1):\n            newS += str(el) * dic[str(el)]\n        newS = '-' + newS\n        return newS", "def minimum_number(s):\n    s = sorted(s)\n    if s[-1] == '0':\n        return ''.join(s)\n    i = 0\n    while s[i] == '0':\n        i += 1\n    (s[i], s[0]) = (s[0], s[i])\n    return ''.join(s)", "def minimum_number(s):\n    n = len(s)\n    s = list(s)\n    s = sorted(s)\n    i = 0\n    while i < n - 1 and s[i] == '0':\n        i += 1\n    if i == 0:\n        return ''.join(s)\n    else:\n        (s[0], s[i]) = (s[i], s[0])\n    return ''.join(s)", "def minimum_number(s):\n    lst = list(s)\n    num = sorted(lst)\n    num = ''.join(num)\n    num = list(num)\n    for i in range(len(num)):\n        if num[i] == '0':\n            continue\n        (num[i], num[0]) = (num[0], num[i])\n        return ''.join(num)\n    return ''.join(num)", "def minimum_number(n):\n    arr = sorted([int(i) for i in list(str(n))])\n    zcount = arr.count(0)\n    if zcount == 0:\n        return int(''.join(arr))\n    elif zcount == len(arr):\n        return 0\n    else:\n        s = str(arr[zcount])\n        for _ in range(zcount):\n            s += '0'\n        for i in arr[zcount + 1:]:\n            s += str(i)\n        return int(s)", "import heapq\n\ndef minimum_number(s):\n    s = list(s)\n    s.sort()\n    s.append('-1')\n    i = 0\n    while s[i] == '0':\n        i += 1\n    if i == len(s) - 1:\n        return 0\n    s.pop()\n    (s[0], s[i]) = (s[i], s[0])\n    return ''.join(s)", "def minimum_number(s):\n    n = len(s)\n    ls = list(s)\n    ls.sort()\n    i = 0\n    while i < n and ls[i] == '0':\n        i += 1\n    if i < n:\n        (ls[0], ls[i]) = (ls[i], ls[0])\n    return ''.join(ls)"], "starter_code": "def minimum_number(s):\n", "input_output": {"inputs": ["s = \"846903\"", "s = \"55010\""], "outputs": ["304689", "10055"]}, "difficulty": "EASY", "raw_tags": ["Algorithms", "Mathematical"], "name": null, "source": "geeksforgeeks", "tags": ["Mathematics"], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/smallest-number-by-rearranging-digits-of-a-given-number0820/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N * log(N)) where N is the number of digits of the given number", "entry_point": "minimum_number", "task_id": "TACO_lite/0"}
{"gt": "U", "requirement": "An **anagram** is the result of rearranging the letters of a word to produce a new word.\n\n**Note:** anagrams are case insensitive\n\nComplete the function to return `true` if the two arguments given are anagrams of each other; return `false` otherwise.\n\n\n## Examples\n\n* `\"foefet\"` is an anagram of `\"toffee\"`\n\n* `\"Buckethead\"` is an anagram of `\"DeathCubeK\"`", "solutions": ["def is_anagram(test, original):\n    return sorted(original.lower()) == sorted(test.lower())", "from collections import Counter\n\ndef is_anagram(test, original):\n    return Counter(test.lower()) == Counter(original.lower())", "def is_anagram(test, original):\n    return sorted(test.upper()) == sorted(original.upper())", "def is_anagram(test, original):\n    (test_dict, original_dict) = ({}, {})\n    for i in test.lower():\n        test_dict[i] = test_dict.get(i, 0) + 1\n    for i in original.lower():\n        original_dict[i] = original_dict.get(i, 0) + 1\n    return test_dict == original_dict", "def is_anagram(test, original):\n    if len(test) != len(original):\n        return False\n    count = [0] * 26\n    for i in range(len(test)):\n        count[(ord(test[i]) & 31) - 1] += 1\n        count[(ord(original[i]) & 31) - 1] -= 1\n    return not any(count)", "def is_anagram(test, original):\n    a = sorted(test.lower())\n    b = sorted(original.lower())\n    c = ''.join(a)\n    d = ''.join(b)\n    if c == d:\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    go = len(test) == len(original)\n    arr = []\n    if go:\n        for i in test:\n            arr.append(i.lower() in original.lower())\n        return False not in arr\n    else:\n        return False", "def is_anagram(test, original):\n    if len(test) != len(original):\n        return False\n    for l in test.lower():\n        if l not in original.lower():\n            return False\n    return True", "from operator import eq\nfrom collections import Counter\n\ndef is_anagram(test, original):\n    return eq(*map(Counter, map(str.lower, (test, original))))", "def is_anagram(test, original):\n    if len(test) != len(original):\n        return False\n    return sorted(test.lower()) == sorted(original.lower())", "def is_anagram(test, original):\n    if sorted(test.lower()) == sorted(original.lower()):\n        return True\n    else:\n        return False", "is_anagram = lambda t, o: sorted(t.lower()) == sorted(o.lower())", "aprime = {'a': 2, 'c': 5, 'b': 3, 'e': 11, 'd': 7, 'g': 17, 'f': 13, 'i': 23, 'h': 19, 'k': 31, 'j': 29, 'm': 41, 'l': 37, 'o': 47, 'n': 43, 'q': 59, 'p': 53, 's': 67, 'r': 61, 'u': 73, 't': 71, 'w': 83, 'v': 79, 'y': 97, 'x': 89, 'z': 101}\n\ndef aprime_sum(str):\n    strChList = list(str.lower())\n    return sum([aprime[x] for x in strChList])\n\ndef is_anagram(test, original):\n    if aprime_sum(test) == aprime_sum(original):\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    return set(original.lower()) == set(test.lower()) if len(test) == len(original) else False", "def is_anagram(test, original):\n    a = list(test.lower())\n    s = list(original.lower())\n    if len(a) != len(s):\n        return False\n    else:\n        for i in a:\n            cond = False\n            k = 0\n            while k != len(s) and cond == False:\n                if i == s[k]:\n                    a.remove(i)\n                    s.remove(i)\n                    cond = True\n                k += 1\n            if cond == False:\n                return False\n        if len(a) != len(s):\n            return False\n        else:\n            return True", "def is_anagram(test, original):\n    flag = 0\n    if len(test) != len(original):\n        return False\n    else:\n        for i in test.lower():\n            if i not in original.lower():\n                flag = 1\n            else:\n                continue\n        if flag == 1:\n            return False\n        else:\n            return True", "def is_anagram(test, original):\n\n    def to_dict(word):\n        dictionary = {}\n        for w in word.lower():\n            if w not in dictionary:\n                dictionary[w] = 0\n            else:\n                dictionary[w] += 1\n        return dictionary\n    return to_dict(test) == to_dict(original)", "is_anagram = lambda a, b, s=sorted: s(a.lower()) == s(b.lower())", "def is_anagram(s, l):\n    n = len(s)\n    if len(l) != n:\n        return False\n    s = s.lower()\n    l = l.lower()\n    h = [0 for x in range(26)]\n    for i in range(n):\n        h[ord(s[i]) - 97] += 1\n        h[ord(l[i]) - 97] -= 1\n    return h.count(0) == 26", "def is_anagram(test: str, original: str) -> bool:\n    return all([all([_ in original.lower() for _ in test.lower()]), len(test) == len(original)])", "def is_anagram(test, original):\n    test = test.lower()\n    original = original.lower()\n    testcount = 0\n    for i in test:\n        if i in original:\n            testcount += 1\n    originalcount = 0\n    for i in original:\n        if i in test:\n            originalcount += 1\n    if testcount == originalcount and testcount == len(test) and (originalcount == len(original)):\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    if len(test) == len(original):\n        test = test.lower()\n        original = original.lower()\n        count = 0\n        for char in test:\n            if char in original:\n                count += 1\n        if count == len(test):\n            return True\n        else:\n            return False\n    else:\n        return False", "def is_anagram(test, original):\n    if len(test) != len(original):\n        return False\n    letters = {}\n    for i in test.lower():\n        if i in letters:\n            letters[i] += 1\n        else:\n            letters[i] = 1\n    for i in original.lower():\n        if i not in letters:\n            return False\n        if original.lower().count(i) != letters[i]:\n            return False\n    return True", "def is_anagram(t, o):\n    return sorted([*t.lower()]) == sorted([*o.lower()])", "def is_anagram(test, original):\n    x = list(test.lower())\n    y = list(original.lower())\n    x = sorted(x)\n    y = sorted(y)\n    if x == y:\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    if len(test) != len(original):\n        return False\n    a = sorted(test.lower())\n    b = sorted(original.lower())\n    if a == b:\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    sorted_test = sorted(list(test.lower()))\n    sorted_original = sorted(list(original.lower()))\n    return sorted_test == sorted_original", "def is_anagram(test, original):\n    letters = [c for c in test.lower()]\n    for char in original.lower():\n        if char in letters:\n            del letters[letters.index(char)]\n        else:\n            return False\n    return not bool(len(letters))", "import collections\n\ndef is_anagram(test, original):\n    return collections.Counter([i.lower() for i in sorted(test)]) == collections.Counter([i.lower() for i in sorted(original)])", "def is_anagram(test, original):\n    test_set = sorted(test.lower())\n    original_set = sorted(original.lower())\n    if test_set == original_set:\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    t = sorted(test.lower())\n    o = sorted(original.lower())\n    if t == o:\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    new_test = test.lower()\n    new_original = original.lower()\n    sortedTest = sorted(new_test)\n    sortedOriginal = sorted(new_original)\n    for letters in new_test:\n        if letters in new_original and len(new_test) == len(new_original) and (sortedOriginal == sortedTest):\n            return True\n        else:\n            return False", "def is_anagram(test, original):\n    first = [i.lower() for i in test]\n    second = [i.lower() for i in original]\n    return sorted(first) == sorted(second)", "def is_anagram(test, original):\n    list_test = []\n    list_original = []\n    for i in test.lower():\n        list_test += i\n    for i in original.lower():\n        list_original += i\n    if len(list_test) == len(list_original):\n        list_test.sort()\n        list_original.sort()\n        if list_test == list_original:\n            return True\n        else:\n            return False\n    else:\n        return False", "def is_anagram(test, original):\n    return True if sorted([letter for letter in test.lower()]) == sorted([letter for letter in original.lower()]) else False", "def is_anagram(test, original):\n    t = list(test.lower())\n    to = ''.join(sorted(t))\n    o = list(original.lower())\n    oo = ''.join(sorted(o))\n    if to == oo:\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    letterCount = dict.fromkeys('abcdefghijklmnopqrstuvwxyz', 0)\n    for c in test.lower():\n        letterCount[c] += 1\n    for c in original.lower():\n        letterCount[c] -= 1\n    for value in list(letterCount.values()):\n        if value != 0:\n            return False\n    return True", "def is_anagram(a_str, b_str):\n    if len(a_str) == len(b_str):\n        a_list = list(a_str.lower())\n        b_list = list(b_str.lower())\n        for char in a_list:\n            if char in b_list:\n                b_list.remove(char)\n        if not b_list:\n            return True\n        else:\n            return False\n    else:\n        return False", "def is_anagram(test, original):\n    if len(test) != len(original):\n        return False\n    else:\n        test = test.lower()\n        original = original.lower()\n        counter_original = [0] * 26\n        counter_test = [0] * 26\n        for i in test:\n            counter_test[ord(i) - 97] += 1\n        for i in original:\n            counter_original[ord(i) - 97] += 1\n    return counter_test == counter_original", "def is_anagram(test, original):\n    test = test.lower()\n    original = original.lower()\n    newList = [ord(c) for c in test]\n    newList.sort()\n    newList2 = [ord(b) for b in original]\n    newList2.sort()\n    if newList == newList2:\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    counterTest = [0] * 255\n    counterOri = [0] * 255\n    for i in range(len(test)):\n        counterTest[ord(test[i].lower())] += 1\n    for i in range(len(original)):\n        counterOri[ord(original[i].lower())] += 1\n    if counterOri == counterTest:\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    test = test.upper()\n    original = original.upper()\n    if sorted(test) == sorted(original):\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    if len(test) == len(original):\n        test = test.lower()\n        original = original.lower()\n        for i in test:\n            if original.find(i) == -1:\n                return False\n            else:\n                test.replace(i, '')\n                original.replace(i, '')\n    else:\n        return False\n    return True", "def is_anagram(test, original):\n    counter1 = [0] * 255\n    counter2 = [0] * 255\n    for i in range(len(test)):\n        counter1[ord(test[i].lower())] += 1\n    for i in range(len(original)):\n        counter2[ord(original[i].lower())] += 1\n    return counter1 == counter2", "def is_anagram(test, original):\n    test = test.lower()\n    original = original.lower()\n    for x in range(len(test)):\n        if test.count(test[x]) != original.count(test[x]):\n            return False\n    for x in range(len(original)):\n        if test.count(original[x]) != original.count(original[x]):\n            return False\n    return True", "def is_anagram(test, original):\n    test = test.lower()\n    original = original.lower()\n    nT = len(test)\n    nO = len(original)\n    if nO == nT:\n        counterT = [0] * (255 + 1)\n        counterO = [0] * (255 + 1)\n        for x in range(nT):\n            counterT[ord(test[x])] += 1\n            counterO[ord(original[x])] += 1\n        if counterT == counterO:\n            return True\n        else:\n            return False\n    else:\n        return False", "def is_anagram(test, original):\n    n = len(original)\n    if n != len(test):\n        return False\n    counterTest = [0] * 255\n    counterOrig = [0] * 255\n    for i in range(n):\n        counterTest[ord(test[i].lower())] += 1\n        counterOrig[ord(original[i].lower())] += 1\n    return True if ''.join(map(str, counterTest)) == ''.join(map(str, counterOrig)) else False", "def is_anagram(test, original):\n    return sorted([n.lower() for n in test]) == sorted([n.lower() for n in original])", "def is_anagram(word_o, test_o):\n    is_anagram = True\n    word = word_o.lower()\n    test = test_o.lower()\n    if len(word) != len(test):\n        is_anagram = False\n    alist = list(test.lower())\n    pos1 = 0\n    while pos1 < len(word) and is_anagram:\n        pos2 = 0\n        found = False\n        while pos2 < len(alist) and (not found):\n            if word[pos1] == alist[pos2]:\n                found = True\n            else:\n                pos2 = pos2 + 1\n        if found:\n            alist[pos2] = None\n        else:\n            is_anagram = False\n        pos1 = pos1 + 1\n    return is_anagram", "def is_anagram(test, original):\n    l1 = list(test.lower())\n    l2 = list(original.lower())\n    if len(l1) == len(l2):\n        for i in l1:\n            if i in l2:\n                l2.remove(i)\n            else:\n                return False\n    else:\n        return False\n    return True", "def is_anagram(test, original):\n    for i in test.lower():\n        if i in original.lower() and len(test) == len(original):\n            continue\n        else:\n            return False\n    return True", "def is_anagram(test, original):\n    test_list = [letter1 for letter1 in test.lower()]\n    orig_list = [letter2 for letter2 in original.lower()]\n    if sorted(test_list) == sorted(orig_list):\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    test = [i.lower() for i in test]\n    original = [j.lower() for j in original]\n    test.sort()\n    original.sort()\n    return test == original", "def is_anagram(test, original):\n    test = test.lower()\n    original = original.lower()\n    if len(test) != len(original):\n        return False\n    for x in test:\n        if test.count(x) == original.count(x):\n            continue\n        else:\n            return False\n    return True", "def is_anagram(test, original):\n    test = test.lower()\n    original = original.lower()\n    new_test = list(test)\n    new_original = list(original)\n    new_test.sort()\n    new_original.sort()\n    if new_test == new_original:\n        return True\n    return False\n    pass", "def is_anagram(test, original):\n    return set(test.upper()) == set(original.upper()) and len(test) == len(original)", "is_anagram = lambda test, original: True if sorted(original.lower()) == sorted(test.lower()) else False", "def is_anagram(test, original):\n    originalLower = [val for val in original.lower()]\n    arr = test.lower()\n    if len(arr) != len(originalLower):\n        return False\n    for element in arr:\n        if element not in originalLower:\n            return False\n        else:\n            originalLower.remove(element)\n    return True", "def is_anagram(test, original):\n    n1 = len(test)\n    n2 = len(original)\n    if n1 != n2:\n        return False\n    str1 = sorted(test.lower())\n    str2 = sorted(original.lower())\n    for i in range(0, n1):\n        if str1[i] != str2[i]:\n            return False\n    return True", "def is_anagram(test, original):\n    test_l = list(test.lower())\n    original_l = list(original.lower())\n    test_l.sort()\n    original_l.sort()\n    if test_l == original_l:\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    test = list(test.lower())\n    original = list(original.lower())\n    if len(test) != len(original):\n        return False\n    for word in test:\n        for word2 in original:\n            if word == word2:\n                original.remove(word2)\n                break\n    if len(original) == 0:\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n\n    def to_list(string):\n        listed = []\n        for i in range(len(string)):\n            listed.append(string[i])\n        return listed\n    return str(sorted(to_list(test.lower()))) == str(sorted(to_list(original.lower())))", "def is_anagram(test, original):\n    test = list(test.lower())\n    test.sort()\n    original = list(original.lower())\n    original.sort()\n    if original != test or len(test) != len(original):\n        return False\n    else:\n        return True", "def is_anagram(test, original):\n    if len(test) != len(original):\n        return False\n    test = sorted(test.lower())\n    original = sorted(original.lower())\n    for i in range(len(test)):\n        if test[i] != original[i]:\n            return False\n    return True", "def is_anagram(test, original):\n    result = True if len(test) == len(original) else False\n    for letter in test.upper():\n        result = False if letter not in original.upper() else result\n    return result", "def is_anagram(test, original):\n    if len(original) != len(test):\n        return False\n    test = test.lower()\n    original = original.lower()\n    for letter in original:\n        if original.count(letter) != test.count(letter):\n            return False\n    return True", "def is_anagram(test, original):\n    if sorted(test.lower()) == sorted(original.lower()):\n        return True\n    elif test != original:\n        return False", "def is_anagram(test, original):\n    test_list = sorted(list(test.lower()))\n    original_list = sorted(list(original.lower()))\n    if test_list == original_list:\n        return True\n    if test_list != original_list:\n        return False", "def is_anagram(test, original):\n    test = test.lower()\n    original = original.lower()\n    t = list(test)\n    o = list(original)\n    t.sort()\n    o.sort()\n    return t == o", "def is_anagram(test, original):\n    t = test.lower()\n    o = [*original.lower()]\n    if len(t) != len(o):\n        return False\n    for c in t:\n        if c in o:\n            o.remove(c)\n        else:\n            return False\n    return True", "def is_anagram(test, original):\n    if len(test) > len(original) or len(test) < len(original):\n        return False\n    res = ''\n    counter = 0\n    sortedTest = sorted(test.lower())\n    sortedOriginal = sorted(original.lower())\n    for i in range(0, len(sortedTest)):\n        if sortedTest[i] != sortedOriginal[i]:\n            res = False\n            break\n        else:\n            res = True\n    return res", "from collections import Counter as C\n\ndef is_anagram(test, original):\n    return C(test.lower()) == C(original.lower())", "def is_anagram(test, original):\n    sort1 = sorted(test.lower())\n    sort2 = sorted(original.lower())\n    if ''.join(sort2) == ''.join(sort1):\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    theTest = test.lower()\n    theOriginal = original.lower()\n    if len(theTest) != len(theOriginal):\n        return False\n    else:\n        index = 0\n        lengthCheck = 0\n        array = [None] * len(theTest)\n        for i in theOriginal:\n            array[index] = i\n            index += 1\n        for j in theTest:\n            testLength = len(theTest)\n            if j in array:\n                lengthCheck += 1\n            else:\n                return False\n        if lengthCheck == testLength:\n            return True", "def is_anagram(tst, org):\n    tst = tst.lower()\n    org = org.lower()\n    if len(tst) != len(org):\n        return False\n    for i in org:\n        if tst.count(i) != org.count(i):\n            return False\n    return True", "def is_anagram(test, original):\n    if len(test) != len(original):\n        return False\n    elif sorted(test.casefold()) == sorted(original.casefold()):\n        return True\n    else:\n        return False", "def is_anagram(test, original):\n    letters_original = sorted(list(original.upper()))\n    letters_test = sorted(list(test.upper()))\n    return letters_original == letters_test", "def is_anagram(test, original):\n    return len(test) == len(original) and all([i in original.lower() for i in test.lower()])", "def is_anagram(test, original):\n    org1 = [x.lower() for x in original]\n    org2 = [y.lower() for y in test]\n    org1.sort()\n    org2.sort()\n    if org1 == org2:\n        return True\n    return False", "def is_anagram(test, original):\n    original_list = list(original.lower())\n    test_list = list(test.lower())\n    original_list.sort()\n    test_list.sort()\n    a = ''.join(test_list)\n    b = ''.join(original_list)\n    return a == b", "def is_anagram(test, original):\n    test = test.lower().replace(' ', '')\n    original = original.lower().replace(' ', '')\n    if len(test) != len(original):\n        return False\n    for letter in test:\n        if letter not in original:\n            return False\n    for letter in original:\n        if letter not in test:\n            return False\n    return True"], "starter_code": "def is_anagram(test, original):\n", "input_output": {"fn_name": "is_anagram", "inputs": [["foefet", "toffee"], ["Buckethead", "DeathCubeK"], ["Twoo", "WooT"], ["dumble", "bumble"], ["ound", "round"], ["apple", "pale"]], "outputs": [[true], [true], [true], [false], [false], [false]]}, "difficulty": "EASY", "raw_tags": ["Strings", "Fundamentals"], "name": null, "source": "codewars", "tags": ["String algorithms", "Fundamentals"], "skill_types": [], "url": "https://www.codewars.com/kata/529eef7a9194e0cbc1000255", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "is_anagram", "task_id": "TACO_lite/1"}
{"gt": "U", "requirement": "Given a string 's'. The task is to find the smallest window length that contains all the characters of the given string at least one time.\nFor eg. A = aabcbcdbca, then the result would be 4 as of the smallest window will be dbca.\n \nExample 1:\nInput : \"AABBBCBBAC\"\nOutput : 3\nExplanation : Sub-string -> \"BAC\"\nExample 2:\nInput : \"aaab\"\nOutput : 2\nExplanation : Sub-string -> \"ab\"\n \nExample 3:\nInput : \"GEEKSGEEKSFOR\"\nOutput : 8\nExplanation : Sub-string -> \"GEEKSFOR\"\n \nYour Task:  \nYou don't need to read input or print anything. Your task is to complete the function findSubString() which takes the string  S as input and returns the length of the smallest such window of the string.\nExpected Time Complexity: O(256.N)\nExpected Auxiliary Space: O(256)\n \nConstraints:\n1 ≤ |S| ≤ 10^{5}\nString may contain both type of English Alphabets.", "solutions": ["def findsubstring(str):\n    dict = {}\n    ans = float('inf')\n    j = 0\n    for i in str:\n        if i not in dict:\n            dict[i] = 0\n    length = len(dict)\n    for i in range(len(str)):\n        dict[str[i]] += 1\n        if dict[str[i]] == 1:\n            length -= 1\n        while length == 0:\n            ans = min(ans, i - j + 1)\n            dict[str[j]] -= 1\n            if dict[str[j]] == 0:\n                length += 1\n            j += 1\n    return ans", "from collections import defaultdict\n\ndef findsubstring(s):\n    n = len(s)\n    dist_count = len(set([x for x in s]))\n    m = defaultdict(int)\n    start = 0\n    min_len = float('inf')\n    count = 0\n    for j in range(n):\n        m[s[j]] += 1\n        if m[s[j]] == 1:\n            count += 1\n        if count == dist_count:\n            while m[s[start]] > 1:\n                if m[s[start]] > 1:\n                    m[s[start]] -= 1\n                start += 1\n            len_window = j - start + 1\n            if min_len > len_window:\n                min_len = len_window\n    return min_len", "def findsubstring(str):\n    from collections import defaultdict\n    n = len(str)\n    if n <= 1:\n        return 1\n    dist_count = len(set([x for x in str]))\n    curr_count = defaultdict(lambda : 0)\n    count = 0\n    start = 0\n    min_len = n\n    for j in range(n):\n        curr_count[str[j]] += 1\n        if curr_count[str[j]] == 1:\n            count += 1\n        if count == dist_count:\n            while curr_count[str[start]] > 1:\n                if curr_count[str[start]] > 1:\n                    curr_count[str[start]] -= 1\n                start += 1\n            len_window = j - start + 1\n            min_len = min(min_len, len_window)\n            start_index = start\n    return min_len", "def findsubstring(s):\n    D = {}\n    for i in s:\n        if i in D:\n            pass\n        else:\n            D[i] = 1\n    n = len(s)\n    (i, j) = (0, 0)\n    count = len(D)\n    mini = 9999\n    while j < n:\n        if s[j] in D:\n            D[s[j]] -= 1\n            if D[s[j]] == 0:\n                count -= 1\n        while count == 0:\n            mini = min(mini, j - i + 1)\n            if s[i] in D:\n                D[s[i]] += 1\n                if D[s[i]] > 0:\n                    count += 1\n            i += 1\n        j += 1\n    return mini", "def findsubstring(str):\n    mp = {}\n    cnt = 0\n    for i in range(len(str)):\n        if str[i] not in mp:\n            mp[str[i]] = 0\n            cnt += 1\n    cnt1 = 0\n    j = 0\n    mn = len(str)\n    for i in range(len(str)):\n        if mp[str[i]] == 0:\n            mp[str[i]] += 1\n            cnt1 += 1\n        else:\n            mp[str[i]] += 1\n        while cnt == cnt1:\n            mn = min(mn, i - j + 1)\n            if mp[str[j]] == 1:\n                mp[str[j]] -= 1\n                cnt1 -= 1\n                j = j + 1\n            else:\n                mp[str[j]] -= 1\n                j = j + 1\n    return mn", "def findsubstring(str):\n    dict = {}\n    a = 1000000000.0\n    j = 0\n    for i in str:\n        if i not in dict:\n            dict[i] = 0\n    l = len(dict)\n    for i in range(len(str)):\n        dict[str[i]] += 1\n        if dict[str[i]] == 1:\n            l -= 1\n        while l == 0:\n            a = min(a, i - j + 1)\n            dict[str[j]] -= 1\n            if dict[str[j]] == 0:\n                l += 1\n            j += 1\n    return a", "def findsubstring(s):\n    distinct = len(set(s))\n    d = dict()\n    si = -1\n    Len = 100000.0\n    start = 0\n    for i in range(len(s)):\n        if s[i] not in d:\n            d[s[i]] = 1\n        else:\n            d[s[i]] += 1\n        if len(d) == distinct:\n            while d[s[start]] > 1:\n                d[s[start]] -= 1\n                start += 1\n            clen = i - start + 1\n            if Len > clen:\n                Len = clen\n                si = start\n    return len(s[si:si + Len])", "from collections import defaultdict\n\ndef findsubstring(str):\n    leng = len(str)\n    (start, end) = (0, leng - 1)\n    ct = 0\n    t_dist = len(set([e for e in str]))\n    chr_map = defaultdict(lambda : 0)\n    min_wind = leng\n    for i in range(leng):\n        x = str[i]\n        chr_map[x] += 1\n        if chr_map[x] == 1:\n            ct += 1\n        if ct == t_dist:\n            while chr_map[str[start]] > 1:\n                chr_map[str[start]] -= 1\n                start += 1\n            min_wind = min(i - start + 1, min_wind)\n    return min_wind", "def findsubstring(str):\n    n = len(str)\n    (dic, vic) = ({}, {})\n    for a in str:\n        if a not in dic:\n            dic[a] = 0\n        dic[a] += 1\n    (i, j, ans) = (0, 0, 10000000000)\n    while j < n:\n        if str[j] not in vic:\n            vic[str[j]] = 0\n        vic[str[j]] += 1\n        if len(vic) == len(dic):\n            while len(vic) == len(dic):\n                vic[str[i]] -= 1\n                if vic[str[i]] == 0:\n                    del vic[str[i]]\n                i += 1\n            ans = min(ans, 2 + j - i)\n        j += 1\n    return ans", "def findsubstring(str):\n    dict = {}\n    ans = 1000000000.0\n    for i in str:\n        if i not in dict:\n            dict[i] = 0\n    length = len(dict)\n    count = 0\n    j = 0\n    for i in range(len(str)):\n        dict[str[i]] += 1\n        if dict[str[i]] == 1:\n            count += 1\n        while count == length:\n            ans = min(ans, i - j + 1)\n            dict[str[j]] -= 1\n            if dict[str[j]] == 0:\n                count -= 1\n            j += 1\n    return ans", "from collections import Counter\n\ndef findsubstring(str1):\n    length = len(str1)\n    dict1 = Counter(str1)\n    k = len(dict1)\n    dict2 = dict()\n    count = 0\n    start = 0\n    minimum = 99999\n    for i in range(length):\n        if count < k:\n            j = start\n            while j < length:\n                if str1[j] not in dict2:\n                    dict2[str1[j]] = 1\n                    count += 1\n                else:\n                    dict2[str1[j]] += 1\n                if count == k:\n                    break\n                j += 1\n        if count == k:\n            minimum = min(minimum, j - i + 1)\n            start = j + 1\n        dict2[str1[i]] -= 1\n        if dict2[str1[i]] == 0:\n            dict2.pop(str1[i])\n            count -= 1\n    return minimum", "from collections import Counter, defaultdict\n\ndef findsubstring(str_):\n    set_of_string = set()\n    len_set_of_string = len(set(str_))\n    answer = float('inf')\n    left = 0\n    right = 0\n    freq = defaultdict(int)\n    while right < len(str_):\n        freq[str_[right]] += 1\n        while left <= right and len(freq) == len_set_of_string:\n            answer = min(answer, right - left + 1)\n            freq[str_[left]] -= 1\n            if freq[str_[left]] == 0:\n                del freq[str_[left]]\n            left += 1\n        right += 1\n    return answer", "def findsubstring(a):\n    dict = {}\n    n = len(set(a))\n    left = 0\n    right = 0\n    ans = len(a)\n    while right < len(a):\n        if a[right] not in dict:\n            dict[a[right]] = 1\n        else:\n            dict[a[right]] += 1\n        if len(dict) == n:\n            while dict[a[left]] > 1:\n                dict[a[left]] -= 1\n                left += 1\n            ans = min(ans, right - left + 1)\n        right += 1\n    return ans", "import math\n\ndef findsubstring(s):\n    dicti = {}\n    mini = math.inf\n    k = len(set(s))\n    n = len(s)\n    (i, j) = (0, 0)\n    while j < n:\n        if s[j] not in dicti:\n            dicti[s[j]] = 1\n        else:\n            dicti[s[j]] += 1\n        if len(dicti) < k:\n            j += 1\n        elif len(dicti) == k:\n            while len(dicti) == k:\n                mini = min(mini, j - i + 1)\n                if s[i] in dicti:\n                    dicti[s[i]] -= 1\n                    if dicti[s[i]] == 0:\n                        del dicti[s[i]]\n                i += 1\n            j += 1\n    return mini", "from collections import defaultdict\n\ndef findsubstring(arr):\n    dic = defaultdict(lambda : 0)\n    i = 0\n    j = 0\n    n = len(set(arr))\n    ans = len(arr)\n    while j < len(arr):\n        dic[arr[j]] += 1\n        if len(dic) < n:\n            j += 1\n        if len(dic) == n:\n            while dic[arr[i]] > 1:\n                dic[arr[i]] -= 1\n                i += 1\n            ans = min(ans, j - i + 1)\n            j += 1\n    return ans", "def findsubstring(str):\n    d = {}\n    for i in str:\n        d[i] = 0\n    i = 0\n    j = 0\n    ans = len(str)\n    count = len(d)\n    temp = 0\n    while j < len(str):\n        while temp < count and j < len(str):\n            if d[str[j]] == 0:\n                temp += 1\n            d[str[j]] += 1\n            j += 1\n        while temp >= count:\n            d[str[i]] -= 1\n            if d[str[i]] == 0:\n                temp -= 1\n            i += 1\n        ans = min(ans, j - i + 1)\n    return ans", "from collections import deque\n\ndef findsubstring(stre):\n    s = set(stre)\n    set_len = len(s)\n    j = 0\n    minlen = 1000000000.0\n    mp = {}\n    n = len(stre)\n    for i in range(n):\n        if stre[i] not in mp:\n            mp[stre[i]] = 1\n        else:\n            mp[stre[i]] += 1\n        while j <= i and len(mp) == set_len:\n            if minlen > i - j + 1:\n                minlen = i - j + 1\n            mp[stre[j]] -= 1\n            if mp[stre[j]] == 0:\n                del mp[stre[j]]\n            j += 1\n    return minlen", "def findsubstring(str):\n    m = {}\n    n = len(set(str))\n    length = float('inf')\n    j = 0\n    for i in range(len(str)):\n        m[str[i]] = m.get(str[i], 0) + 1\n        if len(m) == n:\n            while m[str[j]] > 1:\n                m[str[j]] -= 1\n                j += 1\n            length = min(length, i - j + 1)\n    return length", "def findsubstring(str):\n    dict = {}\n    ans = 1000000000.0\n    for i in str:\n        if i not in dict:\n            dict[i] = 1\n    dict2 = {}\n    j = 0\n    for i in range(len(str)):\n        if str[i] not in dict2:\n            dict2[str[i]] = 1\n        else:\n            dict2[str[i]] += 1\n        while len(dict) == len(dict2):\n            ans = min(ans, i - j + 1)\n            if dict2[str[j]] > 1:\n                dict2[str[j]] -= 1\n            elif dict2[str[j]] == 1:\n                dict2.pop(str[j])\n            j += 1\n    return ans", "from collections import defaultdict\n\ndef findsubstring(s):\n    a = set(s)\n    i = 0\n    t = {}\n    min_len = float('inf')\n    for j in range(len(s)):\n        if s[j] not in t:\n            t[s[j]] = 0\n        t[s[j]] += 1\n        while len(t) == len(a):\n            min_len = min(min_len, j - i + 1)\n            t[s[i]] -= 1\n            if t[s[i]] == 0:\n                del t[s[i]]\n            i += 1\n    return min_len", "def findsubstring(str):\n    from collections import defaultdict\n    curr_count = defaultdict(lambda : 0)\n    dist_count = len(set([x for x in str]))\n    if len(str) <= 1:\n        return 1\n    counter = 0\n    start = 0\n    min_len = len(str)\n    for i in range(len(str)):\n        curr_count[str[i]] += 1\n        if curr_count[str[i]] == 1:\n            counter += 1\n        if counter == dist_count:\n            while curr_count[str[start]] > 1:\n                if curr_count[str[start]] > 1:\n                    curr_count[str[start]] -= 1\n                start += 1\n            window_len = i - start + 1\n            if window_len < min_len:\n                min_len = window_len\n                start_index = start\n    a = min_len\n    return a", "def findsubstring(str):\n    d = {}\n    for i in str:\n        if i not in d:\n            d[i] = 0\n    (i, j) = (0, float('inf'))\n    (count, out) = (0, float('inf'))\n    for j in range(len(str)):\n        if d[str[j]] == 0:\n            count += 1\n        d[str[j]] += 1\n        if count == len(d):\n            while i < j:\n                d[str[i]] -= 1\n                if d[str[i]] == 0:\n                    out = min(out, j - i + 1)\n                    count -= 1\n                    i += 1\n                    break\n                i += 1\n    return out if out != float('inf') else 1", "def findsubstring(str):\n    k = len(set(str))\n    memo = {}\n    ans = len(str)\n    (i, j) = (0, 0)\n    while j < len(str):\n        memo[str[j]] = memo.get(str[j], 0) + 1\n        if len(memo) < k:\n            j += 1\n        elif len(memo) == k:\n            while len(memo) == k:\n                memo[str[i]] -= 1\n                if memo[str[i]] == 0:\n                    del memo[str[i]]\n                i += 1\n            ans = min(ans, j - i + 2)\n            j += 1\n        elif len(memo) > k:\n            while len(memo) > k:\n                memo[str[i]] -= 1\n                if memo[str[i]] == 0:\n                    del memo[str[i]]\n                i += 1\n            j += 1\n    return ans", "def findsubstring(str):\n    res = 100000\n    d = {}\n    for i in range(len(str)):\n        if str[i] not in d:\n            d[str[i]] = 0\n    s1 = set()\n    count = len(d)\n    l = 0\n    for i in range(len(str)):\n        s1.add(str[i])\n        d[str[i]] = d[str[i]] + 1\n        while count == len(s1) and d[str[l]] != 0:\n            d[str[l]] = d[str[l]] - 1\n            if d[str[l]] == 0:\n                s1.remove(str[l])\n                res = min(res, i - l + 1)\n            l = l + 1\n    return res", "def findsubstring(str):\n    ans = len(str)\n    N = len(str)\n    n = len(set(str))\n    (i, j) = (0, 0)\n    d = {}\n    while i < N:\n        if str[i] not in d:\n            d[str[i]] = 1\n        else:\n            d[str[i]] += 1\n        if len(d) == n:\n            while d[str[j]] > 1:\n                d[str[j]] -= 1\n                j += 1\n            ans = min(ans, i - j + 1)\n        i += 1\n    return ans", "def findsubstring(s):\n    freq = {}\n    for c in s:\n        freq[c] = 0\n    unique_chars = len(freq)\n    left = 0\n    right = 0\n    count = 0\n    min_length = float('inf')\n    while right < len(s):\n        if s[right] in freq:\n            freq[s[right]] += 1\n            if freq[s[right]] == 1:\n                count += 1\n        right += 1\n        while count == unique_chars:\n            if right - left < min_length:\n                min_length = right - left\n            if s[left] in freq:\n                freq[s[left]] -= 1\n                if freq[s[left]] == 0:\n                    count -= 1\n            left += 1\n    return min_length", "def findsubstring(str):\n    d = {}\n    for i in str:\n        if i not in d:\n            d[i] = 0\n    x = len(d)\n    ans = 999999\n    i = 0\n    j = 0\n    c = 0\n    while i < len(str):\n        if d[str[i]] == 0:\n            c += 1\n        d[str[i]] += 1\n        if c == x:\n            f = True\n            while c == x:\n                ans = min(ans, i - j + 1)\n                d[str[j]] -= 1\n                if d[str[j]] == 0:\n                    c -= 1\n                j += 1\n        i += 1\n    return ans", "def findsubstring(str):\n    reslen = len(str)\n    s = set()\n    d = dict()\n    for i in range(len(str)):\n        s.add(str[i])\n    i = 0\n    count = 0\n    for j in range(len(str)):\n        d[str[j]] = d.get(str[j], 0) + 1\n        if d[str[j]] == 1:\n            count += 1\n        if count == len(s):\n            while d[str[i]] > 1:\n                if d[str[i]] > 1:\n                    d[str[i]] -= 1\n                i += 1\n            if reslen > j - i + 1:\n                reslen = j - i + 1\n    return reslen", "from collections import defaultdict\n\ndef findsubstring(strr):\n    n = len(strr)\n    dist_count = len(set([x for x in strr]))\n    if n == dist_count:\n        return n\n    curr_count = dict()\n    count = 0\n    start = 0\n    min_len = n\n    for i in range(n):\n        curr_count[strr[i]] = curr_count.get(strr[i], 0) + 1\n        if curr_count[strr[i]] == 1:\n            count += 1\n        if count == dist_count:\n            while curr_count[strr[start]] > 1:\n                if curr_count[strr[start]] > 1:\n                    curr_count[strr[start]] -= 1\n                start += 1\n            if min_len > i - start + 1:\n                min_len = i - start + 1\n    return min_len", "def findsubstring(s):\n    n = len(s)\n    res = n\n    i = 0\n    uniq = set(list(s))\n    found = {}\n    for j in range(n):\n        if s[j] in found:\n            found[s[j]] += 1\n        else:\n            found[s[j]] = 1\n        while i < j:\n            if found[s[i]] > 1:\n                found[s[i]] -= 1\n                i += 1\n            else:\n                break\n        if len(found) == len(uniq):\n            res = min(res, j - i + 1)\n    return res", "from collections import defaultdict\n\ndef findsubstring(s):\n    n = len(s)\n    if n <= 1:\n        return len(s)\n    dis_char = len(set(list(s)))\n    curr = defaultdict(lambda : 0)\n    cnt = 0\n    minlen = n\n    start = 0\n    for j in range(n):\n        curr[s[j]] += 1\n        if curr[s[j]] == 1:\n            cnt += 1\n        if cnt == dis_char:\n            while curr[s[start]] > 1:\n                curr[s[start]] -= 1\n                start += 1\n            length = j - start + 1\n            if length < minlen:\n                minlen = length\n                startind = start\n    return minlen", "def findsubstring(S):\n    distinct_chars = set(S)\n    n = len(S)\n    left = 0\n    min_length = n\n    count = [0] * 256\n    distinct = 0\n    for right in range(n):\n        count[ord(S[right])] += 1\n        if count[ord(S[right])] == 1:\n            distinct += 1\n        if distinct == len(distinct_chars):\n            while count[ord(S[left])] > 1:\n                count[ord(S[left])] -= 1\n                left += 1\n            min_length = min(min_length, right - left + 1)\n            count[ord(S[left])] -= 1\n            left += 1\n            distinct -= 1\n    return min_length", "def findsubstring(str):\n    maxi = len(str)\n    sets = set(str)\n    i = 0\n    j = 0\n    m = {}\n    while i < len(str):\n        m[str[i]] = 1 + m.get(str[i], 0)\n        if len(m) >= len(sets):\n            while m[str[j]] > 1:\n                m[str[j]] -= 1\n                j += 1\n            maxi = min(maxi, i - j + 1)\n        i += 1\n    return maxi", "def findsubstring(input_string):\n    start = 0\n    end = 1\n    alphabet_dict = {}\n    distinct_list = list(set(input_string))\n    for i in range(0, len(distinct_list)):\n        alphabet_dict[distinct_list[i]] = 0\n    n = len(distinct_list)\n    count = 1\n    alphabet_dict[input_string[0]] = 1\n    answer = len(input_string)\n    while start <= end < len(input_string):\n        if count < n:\n            element = input_string[end]\n            if alphabet_dict[element] == 0:\n                alphabet_dict[element] = 1\n                count = count + 1\n            else:\n                alphabet_dict[element] = alphabet_dict[element] + 1\n            end = end + 1\n        elif count == n:\n            answer = min(answer, end - start)\n            element = input_string[start]\n            if element in alphabet_dict and alphabet_dict[element] == 1:\n                count = count - 1\n            alphabet_dict[element] = alphabet_dict[element] - 1\n            start = start + 1\n    while count == n:\n        answer = min(answer, end - start)\n        element = input_string[start]\n        if element in alphabet_dict and alphabet_dict[element] == 1:\n            count = count - 1\n        alphabet_dict[element] = alphabet_dict[element] - 1\n        start = start + 1\n    return answer", "from collections import Counter\n\ndef findsubstring(str):\n    dic1 = Counter(str)\n    dic2 = dict()\n    (i, j) = (0, 0)\n    res = 10000000000\n    while j < len(str):\n        if str[j] in dic2:\n            dic2[str[j]] += 1\n        else:\n            dic2[str[j]] = 1\n        if len(dic1) == len(dic2):\n            while len(dic1) == len(dic2):\n                res = min(res, j - i + 1)\n                dic2[str[i]] -= 1\n                if dic2[str[i]] == 0:\n                    del dic2[str[i]]\n                i += 1\n        j += 1\n    return res", "import math\n\ndef findsubstring(s):\n    freq = {}\n    for c in s:\n        freq[c] = 0\n    (b, d, ans) = (0, 0, math.inf)\n    for (i, c) in enumerate(s):\n        while d == len(freq.keys()):\n            freq[s[b]] -= 1\n            if freq[s[b]] == 0:\n                ans = min(ans, i - b)\n                d -= 1\n            b += 1\n        freq[c] += 1\n        if freq[c] == 1:\n            d += 1\n    while d == len(freq.keys()):\n        freq[s[b]] -= 1\n        if freq[s[b]] == 0:\n            ans = min(ans, i - b + 1)\n            d -= 1\n        b += 1\n    return ans", "def findsubstring(str):\n    n = len(str)\n    ans = 0\n    length = n\n    s = list(set(str))\n    d = dict()\n    count = 0\n    start = 0\n    for i in range(n):\n        if str[i] not in d.keys():\n            d[str[i]] = 1\n            count += 1\n        else:\n            d[str[i]] += 1\n        if count == len(s):\n            while d[str[start]] > 1:\n                d[str[start]] -= 1\n                start += 1\n            ans = i - start + 1\n            if length > ans:\n                length = ans\n    return length", "from collections import defaultdict\n\ndef findsubstring(s):\n    control = set(s)\n    m = len(control)\n    n = len(s)\n    test = defaultdict(lambda : 0)\n    mini = float('inf')\n    i = 0\n    for j in range(n):\n        while len(test) < m and i < n:\n            test[s[i]] += 1\n            i += 1\n        if len(test) < m:\n            break\n        mini = min(mini, i - j)\n        test[s[j]] -= 1\n        if test[s[j]] == 0:\n            del test[s[j]]\n    return mini", "def findsubstring(str):\n    i = 0\n    j = 0\n    s = len(set(str))\n    n = len(str)\n    ans = n\n    dic = {}\n    while i < n:\n        if str[i] not in dic:\n            dic[str[i]] = 1\n        else:\n            dic[str[i]] += 1\n        if len(dic) == s:\n            while dic[str[j]] > 1:\n                dic[str[j]] -= 1\n                j += 1\n            ans = min(ans, i - j + 1)\n        i += 1\n    return ans", "def findsubstring(s):\n    n = len(s)\n    distinct_chars = len(set(s))\n    freq = [0] * 256\n    left = 0\n    right = 0\n    count = 0\n    min_len = n\n    while right < n:\n        ch = ord(s[right])\n        if freq[ch] == 0:\n            count += 1\n        freq[ch] += 1\n        right += 1\n        while count == distinct_chars:\n            min_len = min(min_len, right - left)\n            ch = ord(s[left])\n            freq[ch] -= 1\n            if freq[ch] == 0:\n                count -= 1\n            left += 1\n    return min_len", "def findsubstring(str):\n    nd = len(set(str))\n    i = 0\n    j = 0\n    res = len(str)\n    dic = {}\n    while i < len(str):\n        if str[i] in dic:\n            dic[str[i]] = dic[str[i]] + 1\n        else:\n            dic[str[i]] = 1\n        if len(dic) == nd:\n            while dic[str[j]] > 1:\n                dic[str[j]] = dic[str[j]] - 1\n                j = j + 1\n            res = min(res, i - j + 1)\n        i = i + 1\n    return res", "from collections import Counter\n\ndef findsubstring(str1):\n    dict1 = dict()\n    count = 0\n    distinct = len(Counter(str1))\n    n = len(str1)\n    j = 0\n    minimum = n\n    for i in range(n):\n        if count < distinct:\n            while j < n:\n                if str1[j] not in dict1:\n                    dict1[str1[j]] = 1\n                    count += 1\n                else:\n                    dict1[str1[j]] += 1\n                if count == distinct:\n                    j += 1\n                    break\n                j += 1\n        if count == distinct:\n            minimum = min(minimum, j - i)\n        dict1[str1[i]] -= 1\n        if dict1[str1[i]] == 0:\n            dict1.pop(str1[i])\n            count -= 1\n    return minimum", "def findsubstring(a):\n    s = ''\n    a1 = {}\n    for i in a:\n        a1[i] = 1\n    c1 = len(a1)\n    i = 0\n    j = 0\n    a2 = {}\n    c = 0\n    res = len(a)\n    while j < len(a):\n        if a[j] not in a2:\n            a2[a[j]] = 0\n            c += 1\n        a2[a[j]] += 1\n        while i <= j and c == c1:\n            res = min(res, j - i + 1)\n            a2[a[i]] -= 1\n            if a2[a[i]] == 0:\n                del a2[a[i]]\n                c -= 1\n            i += 1\n        j += 1\n    return res", "def findsubstring(str):\n    ans_len = len(set(str))\n    d = {}\n    ws = 0\n    ans = 10 ** 6\n    for we in range(0, len(str)):\n        d[str[we]] = d.get(str[we], 0) + 1\n        if len(d) == ans_len:\n            while d[str[ws]] > 1:\n                d[str[ws]] -= 1\n                ws += 1\n            ans = min(ans, we - ws + 1)\n    return ans", "def findsubstring(str):\n    unique = set(str)\n    res = len(str)\n    j = 0\n    map = dict()\n    for i in range(0, len(str)):\n        if str[i] in map.keys():\n            map[str[i]] += 1\n        else:\n            map[str[i]] = 1\n        if len(unique) == len(map):\n            while map[str[j]] > 1:\n                map[str[j]] -= 1\n                j += 1\n            res = min(res, i - j + 1)\n    return res", "def findsubstring(str):\n    l = len(str)\n    s = set()\n    for i in range(len(str)):\n        s.add(str[i])\n    n = len(s)\n    head = 0\n    tail = 0\n    hmap = {}\n    ans = l\n    while head < l:\n        if str[head] in hmap:\n            hmap[str[head]] += 1\n        else:\n            hmap[str[head]] = 1\n        if len(hmap) == n:\n            while hmap[str[tail]] > 1:\n                hmap[str[tail]] -= 1\n                tail += 1\n            ans = min(ans, head - tail + 1)\n        head += 1\n    return ans", "from collections import defaultdict, Counter\nfrom sys import maxsize\n\ndef findsubstring(str):\n    cnt = Counter(str)\n    cur = defaultdict(int)\n    k = 0\n    ans = maxsize\n    i = 0\n    for (j, ch) in enumerate(str):\n        cur[ch] += 1\n        if cur[ch] == 1:\n            k += 1\n        if k == len(cnt):\n            while i < j:\n                if cur[str[i]] == 1:\n                    break\n                cur[str[i]] -= 1\n                i += 1\n            ans = min(ans, j - i + 1)\n    return ans", "def findsubstring(str):\n    res = float('inf')\n    (i, j) = (0, 0)\n    maxLen = len(set(list(str)))\n    hashmap = {}\n    while j < len(str):\n        if str[j] not in hashmap:\n            hashmap[str[j]] = 1\n        else:\n            hashmap[str[j]] += 1\n        j += 1\n        if len(hashmap) == maxLen:\n            while i < j and hashmap[str[i]] > 1:\n                hashmap[str[i]] -= 1\n                i += 1\n            res = min(res, j - i)\n    return res", "def findsubstring(str):\n    d = {}\n    for ch in str:\n        if ch not in d:\n            d[ch] = 1\n    n = len(d)\n    d.clear()\n    i = 0\n    j = 0\n    count = 0\n    mini = len(str)\n    while j < len(str):\n        if str[j] not in d:\n            d[str[j]] = 1\n            count = count + 1\n        else:\n            d[str[j]] = d[str[j]] + 1\n        if count == n:\n            while d[str[i]] != 1:\n                d[str[i]] = d[str[i]] - 1\n                i = i + 1\n            mini = min(mini, j - i + 1)\n        j = j + 1\n    return mini", "def findsubstring(s):\n    n = len(s)\n    d = {}\n    count = 0\n    for i in range(n):\n        d[s[i]] = 0\n    i = 0\n    j = 0\n    ans = n\n    while i < n:\n        if d[s[i]] == 0:\n            count += 1\n        d[s[i]] += 1\n        if count == len(d):\n            while j < n and d[s[j]] > 1:\n                d[s[j]] -= 1\n                j += 1\n            if ans > i - j + 1:\n                ans = i - j + 1\n        i += 1\n    return ans", "def findsubstring(str):\n    p = len(set(str))\n    j = 0\n    i = 0\n    d = {}\n    mn = 100000\n    while j < len(str):\n        if str[j] in d:\n            d[str[j]] += 1\n        else:\n            d[str[j]] = 1\n        if len(d) == p:\n            while len(d) == p:\n                mn = min(mn, j - i + 1)\n                d[str[i]] -= 1\n                if d[str[i]] == 0:\n                    del d[str[i]]\n                i += 1\n        j += 1\n    return mn", "def findsubstring(str):\n    d = {}\n    i = 0\n    j = 0\n    sw = 100000000\n    n = len(set(str))\n    while j < len(str):\n        if str[j] not in d:\n            d[str[j]] = 1\n        else:\n            d[str[j]] += 1\n        if len(d) == n:\n            while len(d) == n:\n                sw = min(sw, j - i + 1)\n                d[str[i]] -= 1\n                if d[str[i]] == 0:\n                    del d[str[i]]\n                i += 1\n        j += 1\n    return sw", "def findsubstring(str):\n    dict = {}\n    for i in str:\n        if i in dict:\n            dict[i] += 1\n        else:\n            dict[i] = 1\n    count = len(list(dict.keys()))\n    i = j = 0\n    ans = len(str)\n    c = 0\n    dict = {}\n    for i in range(len(str)):\n        if str[i] in dict:\n            dict[str[i]] += 1\n        else:\n            dict[str[i]] = 1\n            c += 1\n        if c == count:\n            ans = min(ans, i - j + 1)\n            while c == count and j <= i:\n                dict[str[j]] -= 1\n                if dict[str[j]] == 0:\n                    del dict[str[j]]\n                    c -= 1\n                ans = min(ans, i - j + 1)\n                j += 1\n    return ans", "def findsubstring(str):\n    s = set(str)\n    n = len(s)\n    ss = set()\n    ind = 0\n    d = {}\n    mini = 10 ** 9\n    for i in range(len(str)):\n        if str[i] not in ss:\n            ss.add(str[i])\n        d[str[i]] = d.get(str[i], 0) + 1\n        if len(ss) == n:\n            ind = i + 1\n            mini = min(mini, i + 1)\n            break\n    index = 0\n    while d[str[index]] > 1:\n        d[str[index]] -= 1\n        index += 1\n        mini = min(mini, i - index + 1)\n    for i in range(ind, len(str)):\n        d[str[i]] = d.get(str[i], 0) + 1\n        while d[str[index]] > 1:\n            d[str[index]] -= 1\n            index += 1\n            mini = min(mini, i - index + 1)\n    while d[str[index]] > 1:\n        d[str[index]] -= 1\n        index += 1\n        mini = min(mini, i - index + 1)\n    return mini"], "starter_code": "def findsubstring(str):\n", "input_output": {"inputs": ["\"AABBBCBBAC\"", "\"aaab\"", "\"GEEKSGEEKSFOR\""], "outputs": ["3", "2", "8"]}, "difficulty": "MEDIUM", "raw_tags": ["Algorithms", "Hash", "sliding-window", "Strings", "Data Structures", "Arrays"], "name": null, "source": "geeksforgeeks", "tags": ["String algorithms", "Data structures", "Amortized analysis"], "skill_types": ["Amortized analysis", "Data structures"], "url": "https://practice.geeksforgeeks.org/problems/smallest-distant-window3132/1", "Expected Auxiliary Space": "O(256)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(256.N)", "entry_point": "findsubstring", "task_id": "TACO_lite/2"}
{"gt": "U", "requirement": "Given an array arr[] which contains data of N nodes of Complete Binary tree in level order fashion. The task is to print the level order traversal in sorted order. \nExample 1:\nInput:\nN = 7\narr[] = {7 6 5 4 3 2 1}\nOutput:\n7\n5 6\n1 2 3 4\nExplanation: The formed Binary Tree is:\n             7\n          /      \\\n        6         5\n      /  \\      /   \\\n     4    3    2     1\nExample 2:\nInput:\nN = 6\narr[] = {5 6 4 9 2 1}\nOutput:\n5\n4 6\n1 2 9\nExplanation: The formed Binary Tree is:\n             5\n          /     \\\n        6        4\n      /  \\      /    \n     9    2    1    \nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function binTreeSortedLevels() which takes the array arr[] and its size N as inputs and returns a 2D array where the i-th array denotes the nodes of the i-th level in sorted order.\nExpected Time Complexity: O(NlogN).\nExpected Auxiliary Space: O(N).\nConstraints:\n1 <= N <= 10^{4}", "solutions": ["def bintreesortedlevels(arr, n):\n    li = []\n    i = 0\n    level = 0\n    while i < n:\n        dumm = []\n        if level == 0:\n            li.append([arr[i]])\n            i += 1\n            level += 1\n        else:\n            size = 2 ** level\n            if i + size < n:\n                dumm.extend(arr[i:i + size])\n                dumm.sort()\n                li.append(dumm)\n                i += size\n                level += 1\n            else:\n                dumm.extend(arr[i:])\n                dumm.sort()\n                li.append(dumm)\n                break\n    return li", "def bintreesortedlevels(arr, n):\n    ans = []\n    m = 1\n    level = []\n    j = 0\n    for i in range(n):\n        if j < m:\n            level.append(arr[i])\n            j += 1\n        else:\n            level.sort()\n            ans.append(level.copy())\n            level.clear()\n            m += m\n            j = 1\n            level.append(arr[i])\n    level.sort()\n    ans.append(level)\n    return ans", "def bintreesortedlevels(arr, n):\n    res = []\n    i = 0\n    ls = 1\n    while i < n:\n        t = (1 << ls) - 1\n        t = min(t, n)\n        temp = sorted(arr[i:t])\n        i = t\n        ls += 1\n        res.append(temp)\n    return res", "def bintreesortedlevels(arr, n):\n    res = []\n    (i, total) = (0, 0)\n    while total < n:\n        temp = []\n        for j in range(2 ** i):\n            if total < n:\n                temp.append(arr[total])\n                total += 1\n            else:\n                break\n        temp.sort()\n        res.append(temp)\n        i += 1\n    return res", "def bintreesortedlevels(arr, n):\n    n = len(arr)\n    list2 = [[arr[0]]]\n    c = 0\n    j = 1\n    list3 = []\n    for x in range(1, n):\n        if c == 2 ** j - 1:\n            list3.append(arr[x])\n            list3.sort()\n            list2.append(list3)\n            list3 = []\n            j += 1\n            c = 0\n        else:\n            list3.append(arr[x])\n            c += 1\n    if len(list3) != 0:\n        list3.sort()\n        list2.append(list3)\n    return list2", "from collections import deque\n\ndef bintreesortedlevels(arr, n):\n    dq = deque()\n    dq.append(0)\n    res = []\n    while len(dq) > 0:\n        currsize = len(dq)\n        t = []\n        for i in range(currsize):\n            temp = dq.popleft()\n            t.append(arr[temp])\n            if 2 * temp + 1 < n:\n                dq.append(2 * temp + 1)\n            if 2 * temp + 2 < n:\n                dq.append(2 * temp + 2)\n        t.sort()\n        res.append(t)\n    return res", "def bintreesortedlevels(arr, n):\n    final = []\n    l = [1]\n    final.append([arr[0]])\n    i = 0\n    while True:\n        li = len(l)\n        l = []\n        for j in range(li):\n            if 2 * i + 1 < n:\n                l.append(arr[2 * i + 1])\n            if 2 * i + 2 < n:\n                l.append(arr[2 * i + 2])\n            i += 1\n        if len(l):\n            final.append(sorted(l))\n        else:\n            break\n    return final", "def bintreesortedlevels(arr, n):\n    output = []\n    i = 0\n    while 2 ** i <= n:\n        j = 2 ** i\n        k = 2 ** (i + 1)\n        i += 1\n        output.append(sorted(arr[j - 1:k - 1]))\n    return output", "def bintreesortedlevels(arr, n):\n    a1 = {}\n    queue = [0]\n    queue1 = [0]\n    while len(queue) > 0:\n        x = queue.pop(0)\n        y = queue1.pop(0)\n        if y not in a1:\n            a1[y] = []\n        a1[y].append(arr[x])\n        if 2 * x + 1 < len(arr):\n            queue.append(2 * x + 1)\n            queue1.append(y + 1)\n        if 2 * x + 2 < len(arr):\n            queue.append(2 * x + 2)\n            queue1.append(y + 1)\n    e = []\n    for i in range(max(a1) + 1):\n        e.append(sorted(a1[i]))\n    return e", "from collections import deque\nfrom sortedcontainers import SortedList\n\ndef bintreesortedlevels(arr, n):\n    q = deque([0])\n    res = []\n    while q:\n        t = SortedList()\n        for _ in range(len(q)):\n            cur = q.popleft()\n            t.add(arr[cur])\n            for i in [2 * cur + 1, 2 * cur + 2]:\n                if i < len(arr):\n                    q.append(i)\n        res.append(t)\n    return res", "from collections import deque\nfrom heapq import heappush, heappop\n\ndef bintreesortedlevels(arr, n):\n    q = deque([0])\n    res = []\n    while q:\n        hp = []\n        for _ in range(len(q)):\n            cur = q.popleft()\n            heappush(hp, arr[cur])\n            for i in [2 * cur + 1, 2 * cur + 2]:\n                if i < len(arr):\n                    q.append(i)\n        t = []\n        while hp:\n            t.append(heappop(hp))\n        res.append(t)\n    return res", "def bintreesortedlevels(arr, n):\n    (res, start, end, len1) = ([], 0, 1, 1)\n    while start < n:\n        res.append(sorted(arr[start:end]))\n        len1 *= 2\n        start = end\n        end = start + len1\n    return res", "def bintreesortedlevels(arr, n):\n    i = 1\n    ans = []\n    while len(arr):\n        ans.append(sorted(arr[:i]))\n        arr = arr[i:]\n        i <<= 1\n    return ans", "def bintreesortedlevels(arr, n):\n    i = 0\n    k = 1\n    res = []\n    while i < n:\n        temp = arr[i:i + k]\n        temp.sort()\n        res.append(temp)\n        i += k\n        k *= 2\n    return res", "def bintreesortedlevels(arr, n):\n    _list = []\n    a = 1\n    curr = 0\n    while curr < n:\n        _list.append(sorted(arr[curr:curr + a]))\n        curr += a\n        a *= 2\n    return _list", "def bintreesortedlevels(arr, n):\n    if n == 1:\n        return [[arr[0]]]\n    else:\n        l = [[arr[0]]]\n        i = 1\n        c = 1\n        while i < n:\n            size = 2 ** c\n            if i + size < n:\n                a = arr[i:i + size]\n                a.sort()\n                l.append(a)\n                i += size\n                c += 1\n            else:\n                a = arr[i:]\n                a.sort()\n                l.append(a)\n                break\n        return l", "def bintreesortedlevels(arr, n):\n    start = 0\n    i = 0\n    increment = 2 ** i\n    list1 = []\n    while start < n:\n        list1.append(sorted(arr[start:start + increment]))\n        start += increment\n        i += 1\n        increment = 2 ** i\n    return list1", "def bintreesortedlevels(arr, n):\n    res = []\n    i = 0\n    count = 0\n    level = 0\n    while True:\n        count = 2 ** level\n        t = []\n        while count != 0 and i < n:\n            t.append(arr[i])\n            i += 1\n            count -= 1\n        res.append(sorted(t))\n        if i >= n:\n            break\n        level += 1\n    return res", "def bintreesortedlevels(arr, n):\n    res = []\n    l = 0\n    i = 0\n    while True:\n        count = int(2 ** l)\n        tmp = []\n        while count != 0 and i < n:\n            tmp.append(arr[i])\n            i += 1\n            count -= 1\n        res.append(sorted(tmp))\n        if i >= n:\n            break\n        l += 1\n    return res", "def bintreesortedlevels(arr, n):\n    i = 0\n    a = []\n    while 2 ** i <= n:\n        a.append(sorted(arr[:2 ** i]))\n        arr[:] = arr[2 ** i:]\n        i = i + 1\n    return a", "def bintreesortedlevels(arr, n):\n    ans = []\n    i = 0\n    level = 0\n    while True:\n        count = int(2 ** level)\n        tmp = []\n        while count != 0 and i < n:\n            tmp.append(arr[i])\n            i += 1\n            count -= 1\n        ans.append(sorted(tmp))\n        if i >= n:\n            break\n        level += 1\n    return ans", "def bintreesortedlevels(arr, n):\n    from math import exp\n    level = 0\n    prevLevelEnd = 0\n    out = []\n    while prevLevelEnd < n:\n        nAtLevel = pow(2, level)\n        out.append(list(sorted(arr[prevLevelEnd:prevLevelEnd + nAtLevel])))\n        prevLevelEnd += nAtLevel\n        level += 1\n    return out", "def bintreesortedlevels(arr, n):\n    re = []\n    level = 0\n    i = 0\n    while i < n:\n        ans = []\n        if level == 0:\n            re.append([arr[i]])\n            i += 1\n            level += 1\n        else:\n            size = 2 ** level\n            if i + size < n:\n                ans.extend(arr[i:i + size])\n                ans.sort()\n                re.append(ans)\n                i += size\n                level += 1\n            else:\n                ans.extend(arr[i:])\n                ans.sort()\n                re.append(ans)\n                break\n    return re", "import heapq\n\ndef bintreesortedlevels(arr, n):\n    lst = []\n    x = 0\n    y = 1\n    while True:\n        ll = []\n        for j in range(x, min(x + y, n)):\n            ll.append(arr[j])\n        lst.append(sorted(ll))\n        x = x + y\n        y = 2 * y\n        if x >= n:\n            break\n    return lst", "def bintreesortedlevels(x, n):\n    res = []\n    i = 0\n    j = 1\n    while i < n:\n        res.append(sorted(x[i:i + j]))\n        i = i + j\n        j = j * 2\n    return res", "def bintreesortedlevels(arr, n):\n    ans = []\n    si = 0\n    k = 0\n    while si < n:\n        size = 2 ** k\n        k += 1\n        if si + size >= n:\n            tans = arr[si:]\n        else:\n            tans = arr[si:si + size]\n        tans.sort()\n        ans.append(tans)\n        si += size\n    return ans", "def bintreesortedlevels(arr, n):\n    lst = []\n    level = 0\n    i = 0\n    while i < n:\n        l = []\n        if level == 0:\n            l.append(arr[i])\n            lst.append(l)\n            i = i + 1\n            level = level + 1\n        else:\n            size = 2 ** level\n            if i + size < n:\n                l.extend(arr[i:i + size])\n                l.sort()\n                lst.append(l)\n                i = i + size\n                level = level + 1\n            else:\n                l.extend(arr[i:])\n                l.sort()\n                lst.append(l)\n                break\n    return lst", "def bintreesortedlevels(arr, n):\n    a = [[arr[0]]]\n    i = 1\n    while i < n:\n        b = arr[i:2 * i + 1]\n        b.sort()\n        a.append(b)\n        i = 2 * i + 1\n    return a", "def bintreesortedlevels(arr, n):\n    c = 0\n    i = 0\n    ans = []\n    while c < n:\n        l = []\n        x = pow(2, i)\n        while x > 0 and c < n:\n            l.append(arr[c])\n            c += 1\n            x -= 1\n        i += 1\n        l.sort()\n        ans.append(l)\n    return ans", "from collections import deque\n\ndef bintreesortedlevels(arr, n):\n    lqc = deque()\n    lqc.append(0)\n    lqn = deque()\n    lsrl = deque()\n    rslt = deque()\n    while len(lqc) > 0:\n        idx = lqc.popleft()\n        lsrl.append(arr[idx])\n        if 2 * idx + 1 < n:\n            lqn.append(2 * idx + 1)\n        if 2 * idx + 2 < n:\n            lqn.append(2 * idx + 2)\n        if len(lqc) == 0:\n            lqc = lqn.copy()\n            lqn = deque()\n            lsrl = list(lsrl)\n            lsrl.sort()\n            rslt.append(lsrl)\n            lsrl = deque()\n    return rslt", "def bintreesortedlevels(arr, n):\n    mm = 0\n    x = 0\n    b = []\n    if n == 1:\n        return [arr]\n        exit()\n    while x < n:\n        e = 2 ** mm\n        t = []\n        for k in range(e):\n            if x < n:\n                t.append(arr[x])\n            x = x + 1\n        t.sort()\n        mm = mm + 1\n        b.append(t)\n    return b", "from collections import defaultdict\nimport queue\n\ndef bintreesortedlevels(arr, n):\n    q = queue.deque()\n    dic = defaultdict(list)\n    q.append([arr[0], 0, 0])\n    while q:\n        ele = q.popleft()\n        dic[ele[1]].append(ele[0])\n        val = 2 * ele[2]\n        if val + 1 < n:\n            q.append([arr[val + 1], ele[1] + 1, val + 1])\n        if val + 2 < n:\n            q.append([arr[val + 2], ele[1] + 1, val + 2])\n    for i in dic:\n        dic[i].sort()\n    return dic", "def bintreesortedlevels(arr, n):\n    l = 0\n    el = 1\n    r = l + el\n    ans = []\n    while r <= len(arr):\n        brr = arr[l:r]\n        brr.sort()\n        ans.append(brr)\n        el *= 2\n        if r < len(arr):\n            l = r\n            if l + el <= len(arr):\n                r = l + el\n            else:\n                r = len(arr)\n        elif r == len(arr):\n            break\n    return ans", "def bintreesortedlevels(arr, n):\n    if not arr:\n        return\n    res = [[arr[0]]]\n    level = 1\n    i = 1\n    l = len(arr)\n    while i < l:\n        tmp = []\n        j = 0\n        while i < l and j < 2 ** level:\n            tmp.append(arr[i])\n            i += 1\n            j += 1\n        level += 1\n        tmp.sort()\n        res.append(tmp)\n    return res", "def bintreesortedlevels(arr, n):\n    ind = 0\n    ans = []\n    q = [arr[ind]]\n    while q:\n        b = sorted(q)\n        ans.append(b)\n        nn = len(q)\n        for i in range(nn):\n            p = q.pop(0)\n            if ind + 1 < n:\n                q.append(arr[ind + 1])\n            if ind + 2 < n:\n                q.append(arr[ind + 2])\n            ind += 2\n    return ans", "def bintreesortedlevels(arr, n):\n    lvl = -1\n    ans = []\n    while len(arr) > 0:\n        lvl += 1\n        s = pow(2, lvl)\n        if s > len(arr):\n            s = len(arr)\n        arr[0:s].sort()\n        ans.append([])\n        while s > 0:\n            ans[lvl].append(arr.pop(0))\n            s -= 1\n        for i in range(lvl + 1):\n            ans[i].sort()\n    return ans", "def bintreesortedlevels(arr, n):\n    j = 0\n    l = []\n    while j < n:\n        i = 2 * j + 1\n        l1 = arr[j:i]\n        l1.sort()\n        l.append(l1)\n        j = i\n    return l", "def bintreesortedlevels(arr, n):\n    c = 0\n    p = 0\n    l = []\n    while p < n:\n        s = 2 ** c\n        k = arr[p:p + s]\n        c = c + 1\n        p = p + s\n        k.sort()\n        l.append(k)\n    return l", "from collections import deque\n\ndef bintreesortedlevels(arr, n):\n    (i, j, k) = (0, 0, 0)\n    ans = []\n    while j < n:\n        st = []\n        i = 2 ** k\n        while i > 0 and j < n:\n            st.append(arr[j])\n            j += 1\n            i -= 1\n        ans.append(sorted(st))\n        k += 1\n    return ans", "def bintreesortedlevels(l, n):\n    start = 0\n    end = 0\n    count = 0\n    result_list = []\n    while True:\n        end = 2 ** count\n        if end > len(l):\n            break\n        result_list.append(sorted(l[start:end + start]))\n        count += 1\n        start += end\n    return result_list", "def bintreesortedlevels(arr, n):\n    ans = []\n    if n == 0:\n        return ans\n    size = 1\n    start = 0\n    while True:\n        if start + size > n:\n            level = arr[start:n]\n            if level:\n                ans.append(sorted(level))\n            break\n        else:\n            level = arr[start:start + size]\n            ans.append(sorted(level))\n            start += size\n            size *= 2\n    return ans", "def bintreesortedlevels(arr, n):\n    if n == 0:\n        return []\n    ans = [[arr[0]]]\n    l = 0\n    r = 1\n    while r < n:\n        l = min(l * 2 + 1, n - 1)\n        r = min(r * 2 + 1, n)\n        ans.append(sorted(arr[l:r]))\n    return ans", "def bintreesortedlevels(arr, n):\n    curr = 1\n    i = 0\n    j = 0\n    final_ans = []\n    ans = []\n    while i < n:\n        ans.append(arr[i])\n        i += 1\n        j += 1\n        if j == curr:\n            j = 0\n            curr *= 2\n            ans.sort()\n            final_ans.append(ans)\n            ans = []\n    if len(ans):\n        ans.sort()\n        final_ans.append(ans)\n    return final_ans", "def bintreesortedlevels(arr, n):\n    if not arr:\n        return []\n    res = []\n    q = [arr[0]]\n    pointer = 1\n    while q:\n        tempQ = []\n        data = []\n        while q:\n            data.append(q.pop(0))\n            if pointer < len(arr):\n                tempQ.append(arr[pointer])\n            pointer += 1\n            if pointer < len(arr):\n                tempQ.append(arr[pointer])\n            pointer += 1\n        res.append(sorted(data))\n        q = tempQ\n    return res", "def bintreesortedlevels(arr, n):\n    res = []\n    i = 0\n    k = 0\n    while i < n:\n        tmp = []\n        lvl = 2 ** k\n        while lvl > 0 and i < n:\n            tmp.append(arr[i])\n            i += 1\n            lvl -= 1\n        tmp.sort()\n        res.append(tmp)\n        k += 1\n    return res", "import math\n\ndef bintreesortedlevels(arr, n):\n    res = []\n    (j, k) = (0, 0)\n    while j < n:\n        tmp = []\n        lvl = math.pow(2, k)\n        while lvl > 0 and j < n:\n            tmp.append(arr[j])\n            lvl -= 1\n            j += 1\n        tmp.sort()\n        res.append(tmp)\n        k += 1\n    return res", "def bintreesortedlevels(arr, n):\n    level = 0\n    index = 0\n    ans = list()\n    while index < n:\n        nodesCurrLevel = pow(2, level) - 1\n        lastindex = min(index + nodesCurrLevel, n - 1)\n        arr = arr[:index] + sorted(arr[index:lastindex + 1]) + arr[lastindex + 1:]\n        lst = list()\n        while index <= lastindex:\n            lst.append(arr[index])\n            index += 1\n        ans.append(lst)\n        level += 1\n    return ans", "def bintreesortedlevels(arr, n):\n    (k, i) = (0, 1)\n    ans = []\n    z = []\n    tot = 0\n    for x in arr:\n        if k < i:\n            z.append(x)\n            k += 1\n        else:\n            ans.append(sorted(z))\n            tot += k\n            k = 0\n            i *= 2\n            z = []\n            z.append(x)\n            k += 1\n    if tot != n:\n        ans.append(sorted(z))\n    return ans", "def bintreesortedlevels(arr, n):\n    ans = []\n    i = 1\n    while i <= n:\n        temp = []\n        for j in range(i):\n            if not arr:\n                break\n            temp.append(arr.pop(0))\n        temp.sort()\n        ans.append(temp)\n        i *= 2\n    return ans", "def bintreesortedlevels(arr, n):\n    l = 0\n    i = 0\n    s = []\n    while i < n:\n        cln = 2 ** l\n        j = min(i + cln - 1, n - 1)\n        s.append(sorted(arr[i:j + 1]))\n        i = j + 1\n        l += 1\n    return s", "def bintreesortedlevels(arr, n):\n    ans = []\n    c = 0\n    i = 1\n    while True:\n        v = []\n        j = 0\n        while j < i and c < n:\n            v.append(arr[c])\n            c += 1\n            j += 1\n        ans.append(sorted(v))\n        i = 2 * i\n        if c == n:\n            break\n    return ans", "def bintreesortedlevels(arr, n):\n    ans = []\n    i = 0\n    while arr:\n        temp = []\n        c = 0\n        while c < 2 ** i and arr:\n            temp.append(arr.pop(0))\n            c += 1\n        ans.append(sorted(list(temp)))\n        i += 1\n    return ans", "def bintreesortedlevels(a, n):\n    l = []\n    q = [0]\n    while q:\n        t = a[q[0]:q[-1] + 1]\n        t.sort()\n        l.append(t)\n        t = q.copy()\n        q.clear()\n        for e in t:\n            r1 = 2 * e + 1\n            r2 = 2 * e + 2\n            if r1 < n:\n                q.append(r1)\n            if r2 < n:\n                q.append(r2)\n    return l", "def bintreesortedlevels(arr, n):\n    res = []\n    level = 0\n    i = 0\n    while i < len(arr):\n        res.append([])\n        j = min(len(arr), i + pow(2, level)) - 1\n        for k in range(j, i - 1, -1):\n            res[-1].append(arr[k])\n        i = j + 1\n        level += 1\n        res[-1].sort()\n    return res", "def bintreesortedlevels(arr, n):\n    ans = []\n    i = 0\n    c = 0\n    j = 2 ** c\n    while i < n and j < n:\n        t = arr[i:j]\n        ans.append(sorted(t))\n        i = j\n        c += 1\n        j = min(n, i + 2 ** c)\n    ans.append(sorted(arr[i:j]))\n    return ans", "def bintreesortedlevels(arr, n):\n    j = 0\n    level = []\n    result = []\n    for i in range(n):\n        if len(level) < 2 ** j:\n            level.append(arr[i])\n            if len(level) == 2 ** j or i == n - 1:\n                result.append(sorted(level.copy()))\n                level.clear()\n                j += 1\n                i += 1\n    return result"], "starter_code": "def bintreesortedlevels (arr, n):\n", "input_output": {"inputs": ["N = 7\narr[] = {7 6 5 4 3 2 1}", "N = 6\narr[] = {5 6 4 9 2 1}"], "outputs": ["7\n5 6\n1 2 3 4", "5\n4 6\n1 2 9"]}, "difficulty": "MEDIUM", "raw_tags": ["Algorithms", "Tree", "Sorting", "Queue", "Data Structures", "priority-queue"], "name": null, "source": "geeksforgeeks", "tags": ["Tree algorithms", "Sorting", "Data structures"], "skill_types": ["Sorting", "Data structures"], "url": "https://practice.geeksforgeeks.org/problems/print-binary-tree-levels-in-sorted-order3241/1", "Expected Auxiliary Space": "O(N).", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(NlogN).", "entry_point": "bintreesortedlevels", "task_id": "TACO_lite/3"}
{"gt": "U", "requirement": "You are given the prices of stock for n number of days. every ith day tell the price of the stock on that day.find the maximum profit that you can make by buying and selling stock any number of times as you can't proceed with other transactions if you hold any transaction.\nExample:\nInput:\nn = 7\nprices = [1,2,3,4,5,6,7]\nOutput:\n6\nExplaination:\nWe can make the maximum profit by buying the stock on the first day and selling it on the last day.\nYour Task:\nYou don't have to read input or print anything. Your task is to complete the function maximizeProfit() which takes the integer n and array prices and returns the maximum profit that can earn.\nExpected Time Complexity: O(n)\nExpected Space Complexity: O(n^{2})\nNOTE: can you solve this in less space complexity?\nConstraint:\n1<=n<=10^{5}\n1<=prices[i]<=10^{5}", "solutions": ["def maximumprofit(prices, n):\n    n = len(prices)\n    curr = [0 for i in range(2)]\n    nex = [0 for i in range(2)]\n    profit = 0\n    for ind in range(n - 1, -1, -1):\n        for buy in range(0, 2):\n            if buy:\n                buynow = -prices[ind] + nex[0]\n                notbuy = 0 + nex[1]\n                profit = max(buynow, notbuy)\n            else:\n                sellnow = prices[ind] + nex[1]\n                notsell = 0 + nex[0]\n                profit = max(sellnow, notsell)\n            curr[buy] = profit\n        nex = curr\n    return nex[1]", "def maximumprofit(prices, n):\n    ans = 0\n    prev = 0\n    for i in range(1, n):\n        if prices[i] > prices[prev]:\n            ans += prices[i] - prices[prev]\n        prev = i\n    return ans", "def maximumprofit(prices, n):\n    Max = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            Max += prices[i] - prices[i - 1]\n    return Max", "def maximumprofit(prices, n):\n    profit = 0\n    for i in range(n - 1):\n        x = prices[i + 1] - prices[i]\n        if x < 0:\n            continue\n        profit += x\n    if profit < 0:\n        return 0\n    return profit", "def maximumprofit(prices, n):\n    dp = [[-1 for i in range(2)] for j in range(n + 1)]\n    dp[n][0] = dp[n][1] = 0\n    for ind in range(n - 1, -1, -1):\n        for buy in range(2):\n            if buy:\n                profit = max(-prices[ind] + dp[ind + 1][0], dp[ind + 1][1])\n            else:\n                profit = max(prices[ind] + dp[ind + 1][1], dp[ind + 1][0])\n            dp[ind][buy] = profit\n    return dp[0][1]", "def maximumprofit(prices, n):\n    prev = [-1 for i in range(2)]\n    for i in range(1, -1, -1):\n        prev[i] = 0\n    for ind in range(n - 1, -1, -1):\n        temp = [-1 for i in range(2)]\n        for buy in range(1, -1, -1):\n            if buy == 1:\n                temp[buy] = max(-prices[ind] + prev[0], 0 + prev[1])\n            else:\n                temp[buy] = max(prices[ind] + prev[1], 0 + prev[0])\n        prev = temp\n    return prev[1]", "def maximumprofit(A, n):\n    i = 0\n    ans = 0\n    while i < n:\n        while i + 1 < n and A[i] >= A[i + 1]:\n            i += 1\n        l = A[i]\n        while i + 1 < n and A[i] <= A[i + 1]:\n            i += 1\n        r = A[i]\n        if l == r:\n            return ans\n        ans += r - l\n        i += 1\n    return ans", "def maximumprofit(prices, n):\n    minm = prices[0]\n    profit = 0\n    for i in range(1, n):\n        if prices[i] > minm:\n            profit += prices[i] - minm\n            minm = prices[i]\n        else:\n            minm = prices[i]\n    return profit", "def maximumprofit(prices, n):\n    n = len(prices)\n    dp = [[0 for _ in range(3)] for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for buy in range(2):\n            if buy == 1:\n                dp[i][buy] = max(-prices[i] + dp[i + 1][0], dp[i + 1][1])\n            else:\n                dp[i][buy] = max(prices[i] + dp[i + 1][1], dp[i + 1][0])\n    return dp[0][1]", "def maximumprofit(prices, n):\n    (profit, A) = (0, prices)\n    for i in range(n - 1):\n        if A[i + 1] > A[i]:\n            profit += A[i + 1] - A[i]\n    return profit", "def maximumprofit(prices, n):\n    dp = [[0 for i in range(2)] for i in range(n + 1)]\n    ans = 0\n    for j in range(1, len(prices)):\n        if prices[j - 1] < prices[j]:\n            ans += prices[j] - prices[j - 1]\n    return ans", "def maximumprofit(prices, n):\n    max_profit = 0\n    for i in range(1, n):\n        if prices[i] > prices[i - 1]:\n            max_profit += prices[i] - prices[i - 1]\n    return max_profit", "def maximumprofit(prices, n):\n    after = [0 for i in range(2)]\n    for i in range(2):\n        after[i] = 0\n    for ind in range(n - 1, -1, -1):\n        curr = [0 for i in range(2)]\n        curr[1] = max(-prices[ind] + after[0], after[1])\n        curr[0] = max(prices[ind] + after[1], after[0])\n        after = curr\n    return after[1]", "def maximumprofit(arr, n):\n    dp = [[0 for i in range(2)] for j in range(n + 1)]\n    dp[n][0] = 0\n    dp[n][1] = 0\n    for idx in range(n - 1, -1, -1):\n        for buy in range(2):\n            profit = 0\n            if buy:\n                p = -arr[idx] + dp[idx + 1][0]\n                np = 0 + dp[idx + 1][1]\n                profit = max(profit, max(p, np))\n            else:\n                s = arr[idx] + dp[idx + 1][1]\n                ns = 0 + dp[idx + 1][0]\n                profit = max(profit, max(s, ns))\n            dp[idx][buy] = profit\n    return dp[0][1]", "def maximumprofit(prices, n):\n    profit = 0\n    i = 1\n    while i < n:\n        buy = i - 1\n        while i < n and prices[i] > prices[i - 1]:\n            i += 1\n        sell = i - 1\n        profit += prices[sell] - prices[buy]\n        i += 1\n    return profit", "def maximumprofit(prices, n):\n    dp = [[0] * 2 for _ in range(n + 1)]\n    profit = 0\n    for i in range(n - 1, -1, -1):\n        for j in range(2):\n            if j == 0:\n                profit = max(dp[i + 1][0], dp[i + 1][1] - prices[i])\n            if j == 1:\n                profit = max(dp[i + 1][1], dp[i + 1][0] + prices[i])\n            dp[i][j] = profit\n    return dp[0][0]", "def maximumprofit(arr, n):\n    i = 0\n    final_ans = []\n    while i < n - 1:\n        if arr[i] <= arr[i + 1]:\n            ans = []\n            ans.append(arr[i])\n            while i < n - 1 and arr[i] <= arr[i + 1]:\n                i += 1\n            ans.append(arr[i])\n            final_ans.append(ans)\n        else:\n            i += 1\n    answer = 0\n    for res in final_ans:\n        answer = answer + (res[1] - res[0])\n    return answer", "def maximumprofit(prices, n):\n    ans = 0\n    for i in range(1, n):\n        ans += max(0, prices[i] - prices[i - 1])\n    return ans", "def maximumprofit(prices, n):\n    n = len(prices)\n    dp = [[0] * 2 for i in range(n + 1)]\n    dp[n][0] = dp[n][1] = 0\n    for idx in range(n - 1, -1, -1):\n        for buy in range(0, 2):\n            profit = 0\n            if buy:\n                profit = max(-prices[idx] + dp[idx + 1][0], 0 + dp[idx + 1][1])\n            else:\n                profit = max(prices[idx] + dp[idx + 1][1], 0 + dp[idx + 1][0])\n            dp[idx][buy] = profit\n    return dp[0][1]", "def maximumprofit(A, n):\n    ahead = [0, 0]\n    curr = [0, 0]\n    ahead[0] = ahead[1] = 0\n    for ind in range(n - 1, -1, -1):\n        for buy in range(2):\n            if buy:\n                take = -A[ind] + ahead[0]\n                noTake = 0 + ahead[1]\n                curr[buy] = max(take, noTake)\n            else:\n                take = A[ind] + ahead[1]\n                noTake = 0 + ahead[0]\n                curr[buy] = max(take, noTake)\n        ahead = curr\n    return ahead[1]", "def maximumprofit(A, n):\n    dp = [[0 for _ in range(2)] for _ in range(n + 1)]\n    (dp[n][0], dp[n][1]) = (0, 0)\n    for ind in range(n - 1, -1, -1):\n        for buy in range(2):\n            if buy:\n                take = -A[ind] + dp[ind + 1][0]\n                noTake = 0 + dp[ind + 1][1]\n                dp[ind][buy] = max(take, noTake)\n            else:\n                take = A[ind] + dp[ind + 1][1]\n                noTake = 0 + dp[ind + 1][0]\n                dp[ind][buy] = max(take, noTake)\n    return dp[0][1]", "import sys\nsys.setrecursionlimit(10 ** 8)\nmod = 10 ** 9\n\ndef maximumprofit(arr, n):\n    dp = [[0 for j in range(0, 2)] for i in range(0, n + 1)]\n    dp[n][0] = 0\n    dp[n][1] = 0\n    for i in range(n - 1, -1, -1):\n        for j in range(0, 2):\n            profit = 0\n            if j == 0:\n                buy = -arr[i] + dp[i + 1][1]\n                notbuy = dp[i + 1][0]\n                profit = max(buy, notbuy)\n            elif j == 1:\n                sell = arr[i] + dp[i + 1][0]\n                notsell = dp[i + 1][1]\n                profit = max(sell, notsell)\n            dp[i][j] = profit\n    return dp[0][0]", "def maximumprofit(arr, n):\n    (l, r) = (0, 1)\n    total = 0\n    prev = 0\n    while r < n:\n        curr = arr[r] - arr[l]\n        if curr > prev:\n            prev = curr\n            if r == n - 1:\n                total += prev\n        elif curr < prev:\n            total += prev\n            prev = 0\n            l = r\n        r += 1\n    return total", "def maximumprofit(prices, n):\n    ahead = [0] * 2\n    ahead[0] = 0\n    ahead[1] = 0\n    for ind in range(n - 1, -1, -1):\n        cur = [0] * 2\n        for buy in range(2):\n            if buy:\n                profit = max(-1 * prices[ind] + ahead[0], ahead[1])\n            else:\n                profit = max(prices[ind] + ahead[1], ahead[0])\n            cur[buy] = profit\n        ahead = cur\n    return ahead[1]", "import sys\n\ndef maximumprofit(prices, n):\n    minI = 0\n    res = []\n    for i in range(n):\n        if i == n - 1 or (i < n - 1 and prices[i] > prices[i + 1]):\n            if i != minI:\n                res.append([minI, i])\n            minI = i + 1\n    prof = 0\n    for p in res:\n        prof += prices[p[1]] - prices[p[0]]\n    return prof", "def maximumprofit(prices, n):\n    total_profit = 0\n    buy = 0\n    sell = 0\n    for i in range(1, n):\n        if prices[i] >= prices[i - 1]:\n            sell += 1\n        else:\n            total_profit += prices[sell] - prices[buy]\n            buy = i\n            sell = i\n    total_profit += prices[sell] - prices[buy]\n    return total_profit"], "starter_code": "def maximumprofit(prices, n):\n", "input_output": {"inputs": ["n = 7\nprices = [1,2,3,4,5,6,7]"], "outputs": ["6"]}, "difficulty": "MEDIUM", "raw_tags": [], "name": null, "source": "geeksforgeeks", "tags": [], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/buy-stock-2/1", "Expected Auxiliary Space": "O(n^{2})", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(n)", "entry_point": "maximumprofit", "task_id": "TACO_lite/4"}
{"gt": "U", "requirement": "Implement a function called makeAcronym that returns the first letters of each word in a passed in string.\n\nMake sure the letters returned are uppercase.\n\nIf the value passed in is not a string return 'Not a string'.\n\nIf the value passed in is a string which contains characters other than spaces and alphabet letters, return 'Not letters'.\n\nIf the string is empty, just return the string itself: \"\".\n\n**EXAMPLES:**\n```\n'Hello codewarrior' -> 'HC'\n\n'a42' -> 'Not letters'\n\n42 -> 'Not a string'\n\n[2,12] -> 'Not a string'\n\n{name: 'Abraham'} -> 'Not a string'\n```", "solutions": ["def make_acronym(phrase):\n    try:\n        return ''.join((word[0].upper() if word.isalpha() else 0 for word in phrase.split()))\n    except AttributeError:\n        return 'Not a string'\n    except TypeError:\n        return 'Not letters'", "from operator import itemgetter\n\ndef make_acronym(phrase):\n    if type(phrase) != str:\n        return 'Not a string'\n    if not all((c.isalpha() or c.isspace() for c in phrase)):\n        return 'Not letters'\n    return ''.join(map(itemgetter(0), phrase.split())).upper()", "def make_acronym(phrase):\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    arr = phrase.split()\n    return ''.join((a[0] for a in arr)).upper() if all(map(str.isalpha, arr)) else 'Not letters'", "def make_acronym(phrase):\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    elif phrase == '':\n        return ''\n    elif not phrase.replace(' ', '').isalpha():\n        return 'Not letters'\n    else:\n        return ''.join((word[0].upper() for word in phrase.split(' ')))", "def make_acronym(phrase):\n    if isinstance(phrase, str):\n        words = phrase.split()\n        if all((x.isalpha() or x.isspace() for x in words)):\n            return ''.join((x[0] for x in words)).upper()\n        else:\n            return 'Not letters'\n    return 'Not a string'", "from string import ascii_letters\n\ndef make_acronym(phrase):\n    acronym = ''\n    if isinstance(phrase, str):\n        words = phrase.split()\n        for word in words:\n            for char in word:\n                if char in ascii_letters:\n                    pass\n                else:\n                    return 'Not letters'\n            acronym += word[0].upper()\n        return acronym\n    return 'Not a string'", "def make_acronym(phrase):\n    if not isinstance(phrase, str):\n        return 'Not a string'\n    words = phrase.split()\n    if not all((i.isalpha() for i in words)):\n        return 'Not letters'\n    return ''.join((p[0] for p in words)).upper()", "def make_acronym(phrase):\n    import re\n    if type(phrase) is not str:\n        return 'Not a string'\n    if re.search('[^A-Za-z\\\\s]', phrase):\n        return 'Not letters'\n    acronym = ''\n    for x in phrase.split():\n        acronym += x[0]\n    return acronym.upper()"], "starter_code": "def make_acronym(phrase):\n", "input_output": {"fn_name": "make_acronym", "inputs": [["My aunt sally"], ["Please excuse my dear aunt Sally"], ["How much wood would a woodchuck chuck if a woodchuck could chuck wood"], ["Unique New York"], ["a42"], ["1111"], [64], [[]], [{}], [""]], "outputs": [["MAS"], ["PEMDAS"], ["HMWWAWCIAWCCW"], ["UNY"], ["Not letters"], ["Not letters"], ["Not a string"], ["Not a string"], ["Not a string"], [""]]}, "difficulty": "EASY", "raw_tags": [], "name": null, "source": "codewars", "tags": [], "skill_types": [], "url": "https://www.codewars.com/kata/557efeb04effce569d000022", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "make_acronym", "task_id": "TACO_lite/5"}
{"gt": "U", "requirement": "A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.)\nWe are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'.\nReturn the minimum number of flips to make S monotone increasing.\n \n\nExample 1:\nInput: \"00110\"\nOutput: 1\nExplanation: We flip the last digit to get 00111.\n\n\nExample 2:\nInput: \"010110\"\nOutput: 2\nExplanation: We flip to get 011111, or alternatively 000111.\n\n\nExample 3:\nInput: \"00011000\"\nOutput: 2\nExplanation: We flip to get 00000000.\n\n \nNote:\n\n1 <= S.length <= 20000\nS only consists of '0' and '1' characters.", "solutions": ["def minflipsmonoincr(S: str) -> int:\n    onesSoFar = 0\n    partial = 0\n    for n in S:\n        if n == '0':\n            partial = min(onesSoFar, partial + 1)\n        else:\n            onesSoFar += 1\n    return partial", "def minflipsmonoincr(S: str) -> int:\n    if not S:\n        return 0\n    n = len(S)\n    if n == 1:\n        return 0\n    total_1s = 0\n    total_0s = 0\n    for char in S:\n        if char == '1':\n            total_1s += 1\n        else:\n            total_0s += 1\n    if total_1s == 0 or total_0s == 0:\n        return 0\n    prefix_sum = 0\n    ans = float('inf')\n    for i in range(n):\n        prefix_sum += 1 if S[i] == '1' else 0\n        ans = min(ans, prefix_sum + (n - i - 1 - (total_1s - prefix_sum)))\n    return min(ans, total_0s, total_1s)", "def minflipsmonoincr(S: str) -> int:\n    at0 = 0\n    at1 = 0\n    num0 = 0\n    for a in S:\n        if a == '0':\n            at1 = min(at1, at0) + 1\n        else:\n            at1 = min(at1, at0)\n            at0 += 1\n    return min(at1, at0)", "def minflipsmonoincr(S: str) -> int:\n    str_len = len(S)\n    count_arr = [[0, 0] for x in range(str_len)]\n    one_start_idx = -1\n    for i in range(len(S)):\n        if S[i] == '0':\n            if i == 0:\n                count_arr[i][0] += 1\n                count_arr[i][1] = 0\n            else:\n                count_arr[i][0] = count_arr[i - 1][0] + 1\n                count_arr[i][1] = count_arr[i - 1][1]\n        else:\n            if i == 0:\n                count_arr[i][1] += 1\n            else:\n                count_arr[i][1] = count_arr[i - 1][1] + 1\n                count_arr[i][0] = count_arr[i - 1][0]\n            if one_start_idx == -1:\n                one_start_idx = i\n    total_flips = []\n    total_flips.append(min(count_arr[str_len - 1][0], count_arr[str_len - 1][1]))\n    for i in range(one_start_idx, str_len):\n        if i == 0:\n            total_flips.append(count_arr[str_len - 1][0] - count_arr[i][0])\n        elif i == str_len - 1:\n            total_flips.append(count_arr[str_len - 1][0])\n        else:\n            total_flips.append(count_arr[i - 1][1] + count_arr[str_len - 1][0] - count_arr[i][0])\n    return min(total_flips)", "def minflipsmonoincr(S: str) -> int:\n    dp = 0\n    ones = 0\n    for c in S:\n        if c == '0':\n            dp = min(1 + dp, ones)\n        else:\n            dp = min(dp, 1 + ones)\n            ones += 1\n    return dp", "def minflipsmonoincr(S: str) -> int:\n    (flip, one) = (0, 0)\n    for i in S:\n        if i == '1':\n            one += 1\n        else:\n            flip += 1\n        flip = min(one, flip)\n    return flip", "def minflipsmonoincr(S: str) -> int:\n    (n, prefix, total, res) = (len(S), 0, S.count('1'), sys.maxsize)\n    for i in range(n + 1):\n        res = min(res, prefix + len(S) - i - total + prefix)\n        if i < n:\n            prefix += 1 if S[i] == '1' else 0\n    return res"], "starter_code": "def minflipsmonoincr(S: str) -> int:\n", "input_output": {"fn_name": "minFlipsMonoIncr", "inputs": [["\"00110\""]], "outputs": [2]}, "difficulty": "MEDIUM_HARD", "raw_tags": ["Dynamic Programming", "String"], "name": null, "source": "leetcode", "tags": ["String algorithms", "Dynamic programming"], "skill_types": ["Dynamic programming"], "url": "https://leetcode.com/problems/flip-string-to-monotone-increasing/", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "minflipsmonoincr", "task_id": "TACO_lite/6"}
{"gt": "U", "requirement": "Given two values ‘a’ and ‘b’ that represent coefficients in “ax – by = 0”, find the smallest values of x and y that satisfy the equation. It may also be assumed that x > 0, y > 0, a > 0 and b > 0.\nExample 1:\nInput: a = 25, b = 35\nOutput: 7 5\nExplaination: 25*7 - 35*5 = 0. And x = 7 \nand y = 5 are the least possible values \nof x and y to get the equation solved.\nExample 2:\nInput: a = 3, b = 7\nOutput: 7 3\nExplaination: For this case x = 7 and \ny = 3 are the least values of x and y \nto satisfy the equation.\nYour Task:\nYou do not need to read input or print anything. Your task is to complete the function findXY() which takes a and b as input parameters and returns the least possible values of x and y to satisfy the equation.\nExpected Time Complexity: O(log(max(a, b)))\nExpected Auxiliary Space: O(1)\nConstraints:\n1 ≤ a, b ≤ 10^{4}", "solutions": ["def findxy(a, b):\n    import math\n    n = math.gcd(a, b)\n    x = a / n\n    y = b / n\n    if b / a == y / x:\n        return [int(y), int(x)]", "def findxy(a, b):\n    i = 2\n    n = min(a, b)\n    while i != n + 1:\n        if a % i == 0 and b % i == 0:\n            a = a // i\n            b = b // i\n        else:\n            i += 1\n    return (b, a)", "def findxy(a, b):\n\n    def gcd(m, n):\n        if n == 0:\n            return m\n        return gcd(n, m % n)\n    result = a * b // gcd(a, b)\n    x = result // a\n    y = result // b\n    return (x, y)", "import math\n\ndef findxy(a, b):\n    l = math.gcd(a, b)\n    return [b // l, a // l]", "def findxy(a, b):\n    if a > b:\n        greater = a\n    else:\n        greater = b\n    while True:\n        if greater % a == 0 and greater % b == 0:\n            lcm = greater\n            break\n        greater += 1\n    return (lcm // a, lcm // b)", "from math import gcd\n\ndef findxy(a, b):\n    m = gcd(a, b)\n    l = []\n    l.append(b // m)\n    l.append(a // m)\n    return l", "def findxy(a, b):\n    p = max(a, b)\n    q = min(a, b)\n    for i in range(1, q + 1):\n        if p * i % q == 0:\n            break\n    j = int(p * i / q)\n    if p == a:\n        return [i, j]\n    else:\n        return [j, i]", "def findxy(a, b):\n    r = [0] * 2\n    if a > b:\n        small = b\n    else:\n        small = a\n    for i in range(1, small + 1):\n        if a % i == 0 and b % i == 0:\n            gcd = i\n    lcm = a * b // gcd\n    r[0] = lcm // a\n    r[1] = lcm // b\n    return r", "import math\n\ndef findxy(a, b):\n    h = math.gcd(a, b)\n    l = a / h * b\n    arr = []\n    a1 = l / a\n    arr.append(int(a1))\n    a2 = l / b\n    arr.append(int(a2))\n    return arr"], "starter_code": "def findxy(a, b):\n", "input_output": {"inputs": ["a = 25, b = 35", "a = 3, b = 7"], "outputs": ["7 5", "7 3"]}, "difficulty": "EASY", "raw_tags": ["Algorithms", "Mathematical"], "name": null, "source": "geeksforgeeks", "tags": ["Mathematics"], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/find-smallest-values-of-x-and-y-such-that-ax-by-01433/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(log(max(a, b)))", "entry_point": "findxy", "task_id": "TACO_lite/7"}
{"gt": "U", "requirement": "# Solve For X\n\nYou will be given an equation as a string and you will need to [solve for X](https://www.mathplacementreview.com/algebra/basic-algebra.php#solve-for-a-variable) and return x's value. For example: \n\n```python\nsolve_for_x('x - 5 = 20') # should return 25\nsolve_for_x('20 = 5 * x - 5') # should return 5\nsolve_for_x('5 * x = x + 8') # should return 2\nsolve_for_x('(5 - 3) * x = x + 2') # should return 2\n```\n\nNOTES:\n * All numbers will be whole numbers\n * Don't forget about the [order of operations](https://www.mathplacementreview.com/algebra/basic-algebra.php#order-of-operations).\n * If the random tests don't pass the first time, just run them again.", "solutions": ["from itertools import count\n\ndef solve_for_x(equation):\n    return next((x for n in count(0) for x in [n, -n] if eval(equation.replace('x', str(x)).replace('=', '=='))))", "import re\n\ndef solve_for_x(equation):\n    (left, right) = equation.split('=')\n    answer = False\n    TrialAndErrorRipMs = -1000\n    while answer == False:\n        FinalLeft = re.sub('x', str(TrialAndErrorRipMs), left)\n        FinalRight = re.sub('x', str(TrialAndErrorRipMs), right)\n        if eval(FinalLeft) == eval(FinalRight):\n            return TrialAndErrorRipMs\n        TrialAndErrorRipMs += 1", "def solve_for_x(equation):\n    left_side = equation.split('=')[0]\n    right_side = equation.split('=')[1]\n    for x in range(-1000, 1000):\n        if eval(left_side) == eval(right_side):\n            return x", "def solve_for_x(equation):\n    for x in range(-100, 1001):\n        if eval(equation.replace('=', '==')):\n            return x", "from itertools import count\n\ndef solve_for_x(equation):\n    equation = equation.replace('=', '==')\n    for x in count():\n        if eval(equation):\n            return x\n        x = -x\n        if eval(equation):\n            return x", "def solve_for_x(equation):\n    (left, right) = equation.split('=')\n    for x in range(-1000, 1000):\n        if eval(left) == eval(right):\n            return x", "def solve_for_x(equation):\n    p = equation.split()\n    for i in range(0, len(p)):\n        if p[i] == '=':\n            p[i] = '=='\n    t = p.index('x')\n    for x in range(-1000, 1000):\n        p[t] = str(x)\n        if eval(''.join(p)):\n            return x", "def solve_for_x(s):\n    for i in range(-1000, 1000):\n        if eval(s.replace('x', str(i)).replace('=', '==')):\n            return i", "def build1(s):\n    s = s.replace(' ', '')\n    stack = []\n    s += '!'\n    if s[0] == '-':\n        s = '0' + s\n    j = 0\n    for i in range(len(s)):\n        if s[i] in ['+', '-', '*', '/', '(', ')', '!']:\n            if j < i:\n                stack.append(s[j:i])\n            stack.append(s[i])\n            j = i + 1\n    stack.remove('!')\n    for (i, x) in enumerate(stack):\n        if x not in ['+', '-', '*', '/', '(', ')', '!']:\n            stack[i] = Exp(x)\n    return stack\n\ndef build2(s):\n    while ')' in s:\n        end = s.index(')')\n        start = end\n        while s[start] != '(':\n            start -= 1\n        s = s[:start] + [build2(s[start + 1:end])] + s[end + 1:]\n    op = {'+': lambda x, y: x + y, '-': lambda x, y: x - y, '*': lambda x, y: x * y, '/': lambda x, y: x.__div__(y)}\n    i = 2\n    for order in [0, 1]:\n        i = 2\n        while i < len(s):\n            if order == 0 and s[i - 1] in ['*', '/'] or (order == 1 and s[i - 1] in ['+', '-']):\n                s[i - 2] = op[s[i - 1]](s[i - 2], s[i])\n                s.pop(i)\n                s.pop(i - 1)\n            else:\n                i += 2\n    return s[0]\n\ndef build(s):\n    stack = build1(s)\n    equ = build2(stack)\n    if type(equ) == Exp:\n        equ = Equ([equ])\n    return equ\n\ndef solve_for_x(equation):\n    (l, r) = equation.split(' = ')\n    (l, r) = (build(l), build(r))\n    (l, r) = (l.get_power(1) - r.get_power(1), r.get_power(0) - l.get_power(0))\n    return r.a / l.a\n\ndef __init__(s):\n    self.a = 1\n    self.p = 0\n    if s[-1] == 'x':\n        self.p = 1\n        s = s[:-1]\n    if 0 < len(s):\n        self.a *= int(s)\n\ndef __add__(other):\n    if self.p == other.p:\n        self.a += other.a\n        return self\n    else:\n        return Equ([self, other])\n\ndef __sub__(other):\n    if self.p == other.p:\n        self.a -= other.a\n        return self\n    else:\n        return Equ([self, Exp('-1') * other])\n\ndef __mul__(other):\n    self.p += other.p\n    self.a *= other.a\n    return self\n\ndef __div__(other):\n    self.p -= other.p\n    self.a /= other.a\n    return self\n\ndef __str__():\n    s = ''\n    if self.a != 0:\n        s += str(self.a)\n    if self.p == 1:\n        s += 'x'\n    if s == '':\n        s += '0'\n    return s\n\ndef __init__(exp):\n    self.exp = dict()\n    for e in exp:\n        if e.p not in self.exp:\n            self.exp[e.p] = e\n        else:\n            self.exp[e.p] += e\n\ndef __add__(other):\n    if type(other) == Exp:\n        other = Equ([other])\n    for p in other.exp:\n        if p in self.exp:\n            self.exp[p] += other.exp[p]\n        else:\n            self.exp[p] = other.exp[p]\n    return self\n\ndef __sub__(other):\n    if type(other) == Exp:\n        other = Equ([other])\n    for p in other.exp:\n        if p in self.exp:\n            self.exp[p] -= other.exp[p]\n        else:\n            self.exp[p] = Exp('-1') * other.exp[p]\n    return self\n\ndef __mul__(other):\n    if type(other) == Exp:\n        other = Equ([other])\n    res = None\n    for p1 in other.exp:\n        temp_res = []\n        for p2 in self.exp:\n            temp_res.append(self.exp[p2] * other.exp[p1])\n        if res is None:\n            res = Equ(temp_res)\n        else:\n            res += Equ(temp_res)\n    return self\n\ndef __div__(other):\n    if type(other) == Exp:\n        other = Equ([other])\n    res = None\n    for p1 in other.exp:\n        temp_res = []\n        for p2 in self.exp:\n            temp_res.append(self.exp[p2] / other.exp[p1])\n        if res is None:\n            res = Equ(temp_res)\n        else:\n            res += Equ(temp_res)\n    return self\n\ndef __str__():\n    s = ''\n    for p in self.exp:\n        s += ' (' + str(self.exp[p]) + ') +'\n    return s[:-1]\n\ndef get_power(p):\n    return self.exp[p] if p in self.exp else Exp('0') if p == 0 else Exp('0x')"], "starter_code": "def solve_for_x(equation):\n", "input_output": {"fn_name": "solve_for_x", "inputs": [["x - 5 = 20"], ["5 * x + 5 = 30"], ["20 = 5 * x - 5"], ["24 = 4 + 5 * x"], ["x = 5"], ["x * 100 = 700"], ["2 * x + 5 = 105"], ["2 * x = 198"], ["x - 100 + 2 - 50 = 52"], ["x / 3 = 33"], ["x + 80 = 20"], ["x + 20 = -60"], ["5 * x + 20 - x = 60"], ["x + x + 6 = 10"], ["5 * x = x + 8"], ["x = x / 2 + 25"], ["(5 - 3) * x = x + 2"], ["(x - 30) * 2 = x"]], "outputs": [[25], [5], [5], [4], [5], [7], [50], [99], [200], [99], [-60], [-80], [10], [2], [2], [50], [2], [60]]}, "difficulty": "EASY", "raw_tags": ["Mathematics", "Algorithms", "Fundamentals", "Puzzles"], "name": null, "source": "codewars", "tags": ["Fundamentals", "Mathematics", "Ad-hoc"], "skill_types": [], "url": "https://www.codewars.com/kata/59c2e2a36bddd2707e000079", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "solve_for_x", "task_id": "TACO_lite/8"}
{"gt": "U", "requirement": "Write a function that takes an array/list of numbers and returns a number such that \n\nExplanation\ntotal([1,2,3,4,5]) => 48\n\n1+2=3--\\ 3+5 =>     8 \\\n2+3=5--/ \\            ==  8+12=>20\\     \n          ==>5+7=> 12 / \\           20+28 => 48\n3+4=7--\\ /            == 12+16=>28/\n4+5=9--/ 7+9 =>     16  /\n\n\nif total([1,2,3]) => 8 then \n\n\nfirst+second => 3 \\\n                   then 3+5 => 8\nsecond+third => 5 /\n\n\n### Examples\n```python\ntotal([-1,-1,-1]) => -4\ntotal([1,2,3,4])  => 20\n```\n\n**Note:** each array/list will have at least an element and all elements will be valid numbers.", "solutions": ["def total(arr):\n    while len(arr) > 1:\n        arr = [x + y for (x, y) in zip(arr, arr[1:])]\n    return arr[0]", "def total(arr):\n    from math import factorial as fact\n    choose = lambda a, b: fact(a) / (fact(a - b) * fact(b))\n    return sum((choose(len(arr) - 1, i) * v for (i, v) in enumerate(arr)))", "def total(xs):\n    return xs[0] if len(xs) == 1 else total([xs[i] + x for (i, x) in enumerate(xs[1:])])", "def total(arr):\n    if len(arr) == 1:\n        return arr[0]\n    arr2 = []\n    for i in range(len(arr) - 1):\n        arr2.append(arr[i] + arr[i + 1])\n    return total(arr2)", "def total(arr):\n    while len(arr) > 2:\n        arr = [x + y for (x, y) in zip(arr, arr[1:])]\n    return sum(arr)", "total = lambda a: a[0] if len(a) == 1 else total([a[i] + a[i + 1] for i in range(len(a) - 1)])", "from math import factorial as fac\n\ndef C(n, k):\n    return fac(n) // (fac(k) * fac(n - k))\n\ndef total(arr):\n    l = len(arr)\n    return sum((arr[i] * C(l - 1, i) for i in range(l)))", "def total(arr):\n    a = arr[:]\n    for i in range(len(a), 1, -1):\n        for j in range(1, i):\n            a[j - 1] += a[j]\n    return a[0]"], "starter_code": "def total(arr):\n", "input_output": {"fn_name": "total", "inputs": [[[1, 2, 3, 4, 5]], [[1, 2, 3, 4]], [[1, 2, 3]], [[4, 4, 52, 23, 32, 1, -1]], [[4, 4, 5, -1]], [[-1, -1, -1]], [[-1, -1, -10, 42, 92, 1, 23, 6, -3]], [[-1, 1, -1, 1]], [[42]]], "outputs": [[48], [20], [8], [1753], [30], [-4], [9248], [0], [42]]}, "difficulty": "EASY", "raw_tags": ["Mathematics", "Lists", "Fundamentals", "Logic", "Arrays"], "name": null, "source": "codewars", "tags": ["Fundamentals", "Data structures", "Mathematics"], "skill_types": ["Data structures"], "url": "https://www.codewars.com/kata/559fed8454b12433ff0000a2", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "total", "task_id": "TACO_lite/9"}
{"gt": "U", "requirement": "A faro shuffle of a deck of playing cards is a shuffle in which the deck is split exactly in half and then the cards in the two halves are perfectly interwoven, such that the original bottom card is still on the bottom and the original top card is still on top.\n\nFor example, faro shuffling the list\n```python\n['ace', 'two', 'three', 'four', 'five', 'six']\n```\ngives\n```python\n['ace', 'four', 'two', 'five', 'three', 'six' ]\n```\n\nIf 8 perfect faro shuffles are performed on a deck of 52 playing cards, the deck is restored to its original order.\n\nWrite a function that inputs an integer n and returns an integer representing the number of faro shuffles it takes to restore a deck of n cards to its original order.\n\nAssume n is an even number between 2 and 2000.", "solutions": ["def faro_cycles(n):\n    (x, cnt) = (2, 1)\n    while x != 1 and n > 3:\n        cnt += 1\n        x = x * 2 % (n - 1)\n    return cnt", "def faro_cycles(deck_size):\n    (arr, count) = (list(range(deck_size)), 0)\n    original_arr = arr\n    while True:\n        arr = arr[0:deck_size:2] + arr[1:deck_size:2]\n        count += 1\n        if original_arr == arr:\n            break\n    return count", "def faro_cycles(size):\n    deck = list(range(size))\n    (cur, count) = (deck[::2] + deck[1::2], 1)\n    while cur != deck:\n        (cur, count) = (cur[::2] + cur[1::2], count + 1)\n    return count", "def faro_cycles(n):\n    original = list(range(1, n + 1))\n    (duplicate, c) = (original.copy(), 0)\n    while 1:\n        (first, bottom) = (duplicate[0], duplicate[-1])\n        first_half = duplicate[1:n // 2]\n        second_half = duplicate[n // 2:-1]\n        duplicate = []\n        for (i, j) in zip(first_half, second_half):\n            duplicate.extend([j, i])\n        duplicate = [first] + duplicate + [bottom]\n        c += 1\n        if original == duplicate:\n            return c", "def faro_cycles(deck_size):\n    if deck_size == 2:\n        return 1\n    (pos, output) = (2, 1)\n    while pos != 1:\n        pos = pos * 2 % (deck_size - 1)\n        output += 1\n    return output", "def faro_cycles(deck_size):\n    pos = 1\n    for i in range(deck_size):\n        pos = pos * 2 - (0 if pos < deck_size / 2 else deck_size - 1)\n        if pos == 1:\n            return i + 1", "def faro(xs):\n    m = len(xs) // 2\n    return [x for xs in zip(xs[:m], xs[m:]) for x in xs]\n\ndef faro_cycles(deck_size):\n    xs = original = list(range(deck_size))\n    n = 0\n    while True:\n        n += 1\n        xs = faro(xs)\n        if xs == original:\n            return n", "def interv(list1, list2):\n    out_list = []\n    for (el1, el2) in zip(list1, list2):\n        out_list.append(el1)\n        out_list.append(el2)\n    return out_list\n\ndef faro_cycles(deck_size):\n    original = [x for x in range(deck_size)]\n    new = interv(original[:deck_size // 2], original[deck_size // 2:])\n    n = 1\n    while original != new:\n        new = interv(new[:deck_size // 2], new[deck_size // 2:])\n        n += 1\n    return n", "def faro_cycles(deck_size):\n    return [None, 1, 2, 4, 3, 6, 10, 12, 4, 8, 18, 6, 11, 20, 18, 28, 5, 10, 12, 36, 12, 20, 14, 12, 23, 21, 8, 52, 20, 18, 58, 60, 6, 12, 66, 22, 35, 9, 20, 30, 39, 54, 82, 8, 28, 11, 12, 10, 36, 48, 30, 100, 51, 12, 106, 36, 36, 28, 44, 12, 24, 110, 20, 100, 7, 14, 130, 18, 36, 68, 138, 46, 60, 28, 42, 148, 15, 24, 20, 52, 52, 33, 162, 20, 83, 156, 18, 172, 60, 58, 178, 180, 60, 36, 40, 18, 95, 96, 12, 196, 99, 66, 84, 20, 66, 90, 210, 70, 28, 15, 18, 24, 37, 60, 226, 76, 30, 29, 92, 78, 119, 24, 162, 84, 36, 82, 50, 110, 8, 16, 36, 84, 131, 52, 22, 268, 135, 12, 20, 92, 30, 70, 94, 36, 60, 136, 48, 292, 116, 90, 132, 42, 100, 60, 102, 102, 155, 156, 12, 316, 140, 106, 72, 60, 36, 69, 30, 36, 132, 21, 28, 10, 147, 44, 346, 348, 36, 88, 140, 24, 179, 342, 110, 36, 183, 60, 156, 372, 100, 84, 378, 14, 191, 60, 42, 388, 88, 130, 156, 44, 18, 200, 60, 108, 180, 204, 68, 174, 164, 138, 418, 420, 138, 40, 60, 60, 43, 72, 28, 198, 73, 42, 442, 44, 148, 224, 20, 30, 12, 76, 72, 460, 231, 20, 466, 66, 52, 70, 180, 156, 239, 36, 66, 48, 243, 162, 490, 56, 60, 105, 166, 166, 251, 100, 156, 508, 9, 18, 204, 230, 172, 260, 522, 60, 40, 253, 174, 60, 212, 178, 210, 540, 180, 36, 546, 60, 252, 39, 36, 556, 84, 40, 562, 28, 54, 284, 114, 190, 220, 144, 96, 246, 260, 12, 586, 90, 196, 148, 24, 198, 299, 25, 66, 220, 303, 84, 276, 612, 20, 154, 618, 198, 33, 500, 90, 72, 45, 210, 28, 84, 210, 64, 214, 28, 323, 290, 30, 652, 260, 18, 658, 660, 24, 36, 308, 74, 60, 48, 180, 676, 48, 226, 22, 68, 76, 156, 230, 30, 276, 40, 58, 700, 36, 92, 300, 708, 78, 55, 60, 238, 359, 51, 24, 140, 121, 486, 56, 244, 84, 330, 246, 36, 371, 148, 246, 318, 375, 50, 60, 756, 110, 380, 36, 24, 348, 384, 16, 772, 20, 36, 180, 70, 252, 52, 786, 262, 84, 60, 52, 796, 184, 66, 90, 132, 268, 404, 270, 270, 324, 126, 12, 820, 411, 20, 826, 828, 92, 168, 332, 90, 419, 812, 70, 156, 330, 94, 396, 852, 36, 428, 858, 60, 431, 172, 136, 390, 132, 48, 300, 876, 292, 55, 882, 116, 443, 21, 270, 414, 356, 132, 140, 104, 42, 180, 906, 300, 91, 410, 60, 390, 153, 102, 420, 180, 102, 464, 126, 310, 40, 117, 156, 940, 220, 36, 946, 36, 316, 68, 380, 140, 204, 155, 318, 96, 483, 72, 194, 138, 60, 488, 110, 36, 491, 196, 138, 154, 495, 30, 396, 332, 36, 60, 232, 132, 468, 504, 42, 92, 84, 84, 1018, 340, 10, 20, 156, 294, 515, 258, 132, 120, 519, 346, 444, 180, 348, 262, 350, 108, 420, 15, 88, 1060, 531, 140, 240, 356, 24, 252, 140, 358, 492, 253, 342, 60, 543, 330, 1090, 364, 36, 274, 156, 366, 29, 24, 180, 1108, 100, 156, 148, 1116, 372, 522, 1122, 300, 231, 564, 84, 510, 452, 378, 264, 162, 42, 76, 180, 382, 575, 288, 60, 132, 180, 126, 166, 116, 388, 249, 1170, 88, 460, 530, 390, 236, 156, 156, 1186, 140, 44, 298, 476, 18, 180, 300, 200, 24, 280, 60, 516, 1212, 324, 152, 572, 180, 611, 420, 204, 1228, 615, 204, 36, 1236, 174, 72, 140, 164, 28, 156, 138, 534, 100, 418, 1258, 48, 420, 220, 180, 414, 20, 198, 40, 1276, 639, 60, 1282, 16, 60, 161, 1290, 86, 36, 648, 72, 1300, 651, 84, 1306, 120, 198, 300, 524, 146, 659, 60, 126, 260, 221, 442, 1210, 70, 44, 285, 204, 444, 312, 268, 224, 630, 96, 20, 540, 638, 30, 680, 644, 12, 683, 1332, 76, 1372, 100, 216, 588, 1380, 460, 92, 18, 462, 636, 99, 60, 70, 233, 466, 660, 140, 66, 704, 328, 156, 188, 36, 70, 84, 237, 180, 1426, 84, 468, 179, 60, 478, 719, 130, 36, 136, 723, 66, 1450, 1452, 48, 115, 486, 486, 90, 292, 162, 84, 245, 490, 580, 210, 56, 370, 1482, 180, 743, 744, 210, 1492, 132, 166, 1498, 234, 498, 84, 340, 502, 755, 88, 100, 180, 105, 156, 1522, 60, 508, 690, 1530, 18, 204, 364, 54, 66, 771, 204, 24, 1548, 230, 194, 620, 516, 779, 111, 260, 156, 783, 522, 1570, 660, 60, 738, 526, 40, 791, 316, 506, 678, 252, 522, 140, 532, 60, 400, 228, 212, 803, 201, 534, 52, 72, 210, 1618, 1620, 540, 300, 542, 180, 87, 385, 36, 1636, 740, 546, 260, 276, 180, 48, 84, 252, 60, 92, 78, 30, 831, 36, 1666, 1668, 556, 357, 660, 84, 99, 820, 120, 84, 24, 562, 198, 1692, 28, 848, 566, 162, 780, 20, 284, 244, 812, 114, 588, 200, 570, 215, 574, 220, 260, 36, 144, 1732, 692, 96, 828, 1740, 246, 348, 1746, 260, 408, 146, 36, 150, 879, 586, 140, 88, 90, 420, 330, 588, 140, 74, 148, 204, 891, 24, 1786, 596, 198, 810, 716, 598, 48, 25, 50, 684, 276, 198, 362, 252, 220, 429, 424, 606, 911, 180, 84, 290, 305, 276, 732, 830, 612, 393, 144, 60, 923, 602, 154, 72, 156, 618, 780, 1860, 594, 372, 1866, 66, 935, 936, 500, 1876, 939, 90, 804, 84, 72, 472, 60, 90, 756, 135, 210, 1900, 860, 28, 1906, 902, 84, 239, 764, 630, 900, 56, 64, 60, 460, 214, 1930, 644, 84, 444, 276, 646, 924, 388, 290, 1948, 975, 30, 88, 306, 652, 468, 60, 260, 210, 890, 18, 1972, 780, 658, 1978, 282, 660, 44, 1986, 24, 180, 996, 36, 1996, 333][deck_size >> 1]", "def faro_cycles(deck_size):\n    if deck_size <= 2:\n        return 1\n    k = 1\n    while 2 ** k % (deck_size - 1) != 1:\n        k += 1\n    return k"], "starter_code": "def faro_cycles(deck_size):\n", "input_output": {"fn_name": "faro_cycles", "inputs": [[2], [52], [542], [1250], [1954]], "outputs": [[1], [8], [540], [156], [30]]}, "difficulty": "EASY", "raw_tags": ["Fundamentals", "Iterators", "Lists"], "name": null, "source": "codewars", "tags": ["Fundamentals", "Data structures"], "skill_types": ["Data structures"], "url": "https://www.codewars.com/kata/57bc802c615f0ba1e3000029", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "faro_cycles", "task_id": "TACO_lite/10"}
{"gt": "U", "requirement": "Given an array A of size N of integers. Your task is to find the sum of minimum and maximum element in the array.\nExample 1:\nInput:\nN = 5\nA[] = {-2, 1, -4, 5, 3}\nOutput: 1\nExplanation: min = -4, max =  5. Sum = -4 + 5 = 1\n \nExample 2:\nInput:\nN = 4\nA[]  = {1, 3, 4, 1}\nOutput: 5\nExplanation: min = 1, max = 4. Sum = 1 + 4 = 5\n \nYour Task:  \nYou don't need to read input or print anything. Your task is to complete the function findSum() which takes the array A[] and its size N as inputs and returns the summation of minimum and maximum element of the array.\n \nExpected Time Complexity: O(N)\nExpected Auxiliary Space: O(1)\n \nConstraints:\n1 <= N <= 10^{5}\n-10^{9} <= A_{i} <= 10^{9}", "solutions": ["def findsum(A, N):\n    A.sort()\n    return A[0] + A[len(A) - 1]", "def findsum(A, N):\n    return max(A) + min(A)", "def findsum(A, N):\n    maxval = A[0]\n    minval = maxval\n    for i in range(1, N):\n        if A[i] > maxval:\n            maxval = A[i]\n            continue\n        if A[i] < minval:\n            minval = A[i]\n            continue\n    return minval + maxval", "def findsum(A, N):\n    self.A = A\n    self.N = N\n    max_val = max(A)\n    min_val = min(A)\n    return max_val + min_val", "def findsum(A, N):\n    A.sort()\n    sum = A[0] + A[N - 1]\n    return sum", "def findsum(A, N):\n    a = min(A)\n    b = max(A)\n    return a + b", "def findsum(arr, arr_size):\n    max = 0\n    min = 0\n    i = 0\n    if arr_size % 2 == 1:\n        max = arr[0]\n        min = arr[0]\n        i = 1\n    else:\n        if arr[0] < arr[1]:\n            max = arr[1]\n            min = arr[0]\n        else:\n            max = arr[0]\n            min = arr[1]\n        i = 2\n    while i < arr_size:\n        if arr[i] < arr[i + 1]:\n            if arr[i] < min:\n                min = arr[i]\n            if arr[i + 1] > max:\n                max = arr[i + 1]\n        else:\n            if arr[i] > max:\n                max = arr[i]\n            if arr[i + 1] < min:\n                min = arr[i + 1]\n        i = i + 2\n    return max + min", "def findsum(A, N):\n    a = A[0]\n    b = A[0]\n    for i in range(N):\n        if a > A[i]:\n            a = A[i]\n        if b < A[i]:\n            b = A[i]\n    return a + b", "def findsum(A, N):\n    d = min(A)\n    m = max(A)\n    result = d + m\n    return result", "def findsum(A, N):\n    min = 99999999\n    max = -999999\n    for i in range(0, N):\n        if A[i] < min:\n            min = A[i]\n        if A[i] > max:\n            max = A[i]\n    return max + min", "def findsum(A, N):\n    min_a = 10 ** 9\n    max_b = -10 ** 9\n    for i in range(len(A)):\n        if a[i] > max_b:\n            max_b = a[i]\n        if a[i] < min_a:\n            min_a = a[i]\n    return min_a + max_b", "def findsum(A, N):\n    largest_element = A[0]\n    for i in range(N):\n        if A[i] > largest_element:\n            largest_element = A[i]\n    smallest_element = A[0]\n    for i in range(N):\n        if A[i] < smallest_element:\n            smallest_element = A[i]\n    return largest_element + smallest_element", "def findsum(A, N):\n    maxx = -10000000\n    minn = 10000000\n    for i in range(N):\n        if A[i] > maxx:\n            maxx = A[i]\n        if A[i] < minn:\n            minn = A[i]\n    return maxx + minn", "def findsum(A, N):\n    Amax = Amin = A[0]\n    for i in range(1, N):\n        if A[i] > Amax:\n            Amax = A[i]\n        elif A[i] < Amin:\n            Amin = A[i]\n    return Amax + Amin", "def findsum(A, N):\n    ma = -999999999\n    mi = 9999999999\n    for i in range(N):\n        if A[i] < mi:\n            mi = A[i]\n        if ma < A[i]:\n            ma = A[i]\n    return ma + mi", "def findsum(arr, n):\n    maxi = arr[0]\n    mini = arr[0]\n    for i in range(1, n):\n        if arr[i] > maxi:\n            maxi = arr[i]\n        if arr[i] < mini:\n            mini = arr[i]\n    return maxi + mini", "def findsum(A, N):\n    min_elem = A[0]\n    max_elem = A[0]\n    for i in range(1, N):\n        if A[i] < min_elem:\n            min_elem = A[i]\n        elif A[i] > max_elem:\n            max_elem = A[i]\n    return min_elem + max_elem", "def findsum(A, N):\n    min = A[0]\n    max = A[0]\n    for x in A:\n        if x < min:\n            min = x\n        elif x > max:\n            max = x\n    return max + min", "def findsum(A, N):\n    maxi = A[0]\n    mini = A[0]\n    for i in range(N):\n        if A[i] >= maxi:\n            maxi = A[i]\n        if A[i] <= mini:\n            mini = A[i]\n    return mini + maxi", "def findsum(A, N):\n    max = A[0]\n    min = A[0]\n    for i in A:\n        if i > max:\n            max = i\n    for i in A:\n        if i < min:\n            min = i\n    return max + min", "def findsum(A, N):\n    index = 0\n    minimum = A[0]\n    maximum = A[0]\n    while index < N:\n        if minimum > A[index]:\n            minimum = A[index]\n        if maximum < A[index]:\n            maximum = A[index]\n        index += 1\n    return maximum + minimum", "def findsum(arr, N):\n    arr.sort()\n    return arr[0] + arr[N - 1]", "def findsum(arr, N):\n    return max(arr) + min(arr)", "def findsum(A, N):\n    min_num = max_num = A[0]\n    for i in range(1, N):\n        if A[i] < min_num:\n            min_num = A[i]\n        elif A[i] > max_num:\n            max_num = A[i]\n    return min_num + max_num", "def findsum(A, N):\n    newarray = sorted(A)\n    firstelement = newarray[0]\n    lastelement = newarray[-1]\n    sumofelement = firstelement + lastelement\n    return sumofelement", "def findsum(A, N):\n    max_a = max(A)\n    min_a = min(A)\n    sum_a = max_a + min_a\n    return sum_a", "def findsum(A, N):\n    max1 = max(A)\n    min1 = min(A)\n    return max1 + min1", "def findsum(A, N):\n    min_val = max_val = A[0]\n    for num in A:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    return min_val + max_val", "def findsum(A, N):\n\n    def maxMin(A):\n        (max, min) = (float('-inf'), float('inf'))\n        for i in A:\n            if i > max:\n                max = i\n            if i < min:\n                min = i\n        return [min, max]\n    return sum(maxMin(A))", "import numpy as np\n\ndef findsum(A, N):\n    Ar = np.array(A)\n    Ar.sort()\n    return Ar[0] + Ar[N - 1]", "def findsum(A, N):\n    min_val = float('inf')\n    max_val = float('-inf')\n    for i in range(N):\n        if A[i] < min_val:\n            min_val = A[i]\n        if A[i] > max_val:\n            max_val = A[i]\n    sum_val = min_val + max_val\n    return sum_val", "def findsum(A, N):\n    x = max(A)\n    y = min(A)\n    return x + y", "def findsum(A, N):\n    minimum = A[0]\n    maximum = A[0]\n    sum = 0\n    for x in range(0, len(A), +1):\n        if A[x] < minimum:\n            minimum = A[x]\n        elif A[x] > maximum:\n            maximum = A[x]\n        sum = maximum + minimum\n    return sum", "def findsum(A, N):\n    min = A[0]\n    max = A[0]\n    sum = 0\n    for x in range(0, len(A), +1):\n        if A[x] < min:\n            min = A[x]\n        elif A[x] > max:\n            max = A[x]\n    sum = min + max\n    return sum", "def findsum(A, N):\n    maximum = max(A)\n    minimum = min(A)\n    Sum = minimum + maximum\n    return Sum", "def findsum(A, N):\n    m = min(A)\n    n = max(A)\n    return m + n", "def findsum(A, N):\n    s = sorted(A)\n    low = s[0]\n    high = s[n - 1]\n    result = low + high\n    return result", "def findsum(A, N):\n    c = max(a)\n    d = min(a)\n    s = c + d\n    return s", "def findsum(A, N):\n    maxele = -float('inf')\n    for i in range(N):\n        if maxele < A[i]:\n            maxele = A[i]\n    minele = float('inf')\n    for i in range(N):\n        if minele > A[i]:\n            minele = A[i]\n    return maxele + minele", "def findsum(A, N):\n    min = A[0]\n    max = A[0]\n    for i in range(0, len(A)):\n        if A[i] < min:\n            min = A[i]\n        if A[i] > max:\n            max = A[i]\n    sum = max + min\n    return sum", "def findsum(A, N):\n    if N == 0:\n        return Null\n    else:\n        return min(A) + max(A)", "def findsum(A, N):\n    min_elem = float('inf')\n    max_elem = float('-inf')\n    for i in range(N):\n        if A[i] < min_elem:\n            min_elem = A[i]\n        if A[i] > max_elem:\n            max_elem = A[i]\n    return min_elem + max_elem", "def findsum(A, N):\n    import math\n    min = math.inf\n    max = -math.inf\n    for i in range(0, len(A)):\n        if A[i] < min:\n            min = A[i]\n        if A[i] > max:\n            max = A[i]\n    return max + min", "def findsum(A, N):\n    s = A[0]\n    l = A[0]\n    for i in range(N):\n        if s > A[i]:\n            s = A[i]\n        if l < A[i]:\n            l = A[i]\n    return l + s", "def findsum(A, N):\n    if N == 1:\n        sum = A[0] + A[0]\n        return sum\n    else:\n        (min, max) = (A[0], A[0])\n        for i in range(N):\n            if A[i] < min:\n                min = A[i]\n            elif A[i] > max:\n                max = A[i]\n        sum = min + max\n    return sum", "def findsum(a, n):\n    e = min(a)\n    b = max(a)\n    return e + b", "def findsum(A, N):\n    mini = min(A)\n    maxi = max(A)\n    return mini + maxi", "def findsum(A, N):\n    l = min(A)\n    g = max(A)\n    s = 0\n    s = int(l + g)\n    return s", "def findsum(A, N):\n    Z = max(A)\n    X = min(A)\n    sum = Z + X\n    return sum", "def findsum(A, N):\n    mx = max(A)\n    mn = min(A)\n    s = mx + mn\n    return s", "def findsum(A, N):\n    l = list(A)\n    mi = min(l)\n    ma = max(l)\n    sum = int(mi) + int(ma)\n    return sum", "def findsum(A, N):\n    if N == 0:\n        return 0\n    if N == 1:\n        return 2 * A[0]\n    A.sort()\n    return A[0] + A[-1]", "def findsum(A, N):\n    min_A = min(A)\n    max_A = max(A)\n    sum_mm = max_A + min_A\n    return sum_mm", "def findsum(A, N):\n    x = min(A)\n    Y = max(A)\n    return x + Y", "def findsum(A, N):\n    N = len(A)\n    if N % 2 == 0:\n        mx = max(A[0], A[1])\n        mn = min(A[0], A[1])\n        i = 2\n    else:\n        mx = mn = A[0]\n        i = 1\n    while i < N - 1:\n        if A[i] < A[i + 1]:\n            mx = max(mx, A[i + 1])\n            mn = min(mn, A[i])\n        else:\n            mx = max(mx, A[i])\n            mn = min(mn, A[i + 1])\n        i += 2\n    return mx + mn", "def findsum(A, N):\n    maxi = -99999\n    mini = 99999\n    for i in range(N):\n        maxi = max(A[i], maxi)\n        mini = min(A[i], mini)\n    sum = maxi + mini\n    return sum", "def findsum(A, N):\n    maxi = float('-inf')\n    mini = float('inf')\n    for i in A:\n        if i > maxi:\n            maxi = i\n        if i < mini:\n            mini = i\n    return maxi + mini", "def findsum(A, N):\n    A.sort()\n    mini = A[0]\n    maxi = A[-1]\n    return mini + maxi", "def findsum(A, N):\n    minn = 1000000\n    maxx = -1000000\n    for i in A:\n        if i > maxx:\n            maxx = i\n        if i < minn:\n            minn = i\n    return minn + maxx", "def findsum(A, N):\n    l = max(A)\n    b = min(A)\n    s = l + b\n    return s"], "starter_code": "def findsum(A,N):\n", "input_output": {"inputs": ["N = 5\r\nA[] = {-2, 1, -4, 5, 3}", "N = 4\r\nA[]  = {1, 3, 4, 1}"], "outputs": ["1", "5"]}, "difficulty": "EASY", "raw_tags": ["Algorithms", "Greedy"], "name": null, "source": "geeksforgeeks", "tags": ["Greedy algorithms"], "skill_types": ["Greedy algorithms"], "url": "https://practice.geeksforgeeks.org/problems/max-min/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N)", "entry_point": "findsum", "task_id": "TACO_lite/11"}
{"gt": "U", "requirement": "Write a method that will search an array of strings for all strings that contain another string, ignoring capitalization. Then return an array of the found strings. \n\nThe method takes two parameters, the query string and the array of strings to search, and returns an array. \n\nIf the string isn't contained in any of the strings in the array, the method returns an array containing a single string: \"Empty\" (or `Nothing` in Haskell, or \"None\" in Python and C)\n\n### Examples\nIf the string to search for is \"me\", and the array to search is [\"home\", \"milk\", \"Mercury\", \"fish\"], the method should return [\"home\", \"Mercury\"].", "solutions": ["def word_search(query, seq):\n    return [x for x in seq if query.lower() in x.lower()] or ['None']", "def word_search(query, seq):\n    query = query.lower()\n    result = [x for x in seq if query in x.lower()]\n    return result if result else ['None']", "import re\n\ndef word_search(query, seq):\n    return [w for w in seq if re.search(query, w, re.I)] or ['None']", "def word_search(query, seq):\n    l = [i for i in seq if query.lower() in i.lower()]\n    return [l, ['None']][not l]", "def word_search(query, seq):\n    query = query.lower()\n    return [word for word in seq if query in word.lower()] or ['None']", "def word_search(q, l):\n    return [w for w in l if q.lower() in w.lower()] or ['None']", "def word_search(query, seq):\n    query = query.lower()\n    return [a for a in seq if query in a.lower()] or ['None']", "def word_search(query, seq):\n    return [i for i in seq if query.lower() in i.lower()] or ['None']", "def word_search(query, seq):\n    array = []\n    for x in seq:\n        if query.lower() in x.lower():\n            array.append(x)\n        else:\n            pass\n    if array != []:\n        return array\n    else:\n        array = ['None']\n        return array"], "starter_code": "def word_search(query, seq):\n", "input_output": {"fn_name": "word_search", "inputs": [["ab", ["za", "ab", "abc", "zab", "zbc"]], ["aB", ["za", "ab", "abc", "zab", "zbc"]], ["ab", ["za", "aB", "Abc", "zAB", "zbc"]], ["abcd", ["za", "aB", "Abc", "zAB", "zbc"]]], "outputs": [[["ab", "abc", "zab"]], [["ab", "abc", "zab"]], [["aB", "Abc", "zAB"]], [["None"]]]}, "difficulty": "EASY", "raw_tags": ["Strings", "Fundamentals", "Arrays"], "name": null, "source": "codewars", "tags": ["String algorithms", "Fundamentals", "Data structures"], "skill_types": ["Data structures"], "url": "https://www.codewars.com/kata/54b81566cd7f51408300022d", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "word_search", "task_id": "TACO_lite/12"}
{"gt": "U", "requirement": "You're a statistics professor and the deadline for submitting your students' grades is tonight at midnight. Each student's grade is determined by their mean score across all of the tests they took this semester.\n\nYou've decided to automate grade calculation by writing a function `calculate_grade()` that takes a list of test scores as an argument and returns a one character string representing the student's grade calculated as follows:\n\n * 90% <= mean score <= 100%: `\"A\"`,\n * 80% <= mean score < 90%: `\"B\"`,\n * 70% <= mean score < 80%: `\"C\"`,\n * 60% <= mean score < 70%: `\"D\"`,\n * mean score < 60%: `\"F\"`\n\nFor example, `calculate_grade([92, 94, 99])` would return `\"A\"` since the mean score is `95`, and `calculate_grade([50, 60, 70, 80, 90])` would return `\"C\"` since the mean score is `70`.\n\nYour function should handle an input list of any length greater than zero.", "solutions": ["from bisect import bisect\nfrom statistics import mean\n\ndef calculate_grade(scores):\n    return 'FDCBA'[bisect([60, 70, 80, 90], mean(scores))]", "def calculate_grade(scores):\n    for score in scores:\n        mean = sum(scores) / len(scores)\n        if mean >= 90 and mean <= 100:\n            return 'A'\n        elif mean >= 80 and mean < 90:\n            return 'B'\n        elif mean >= 70 and mean < 80:\n            return 'C'\n        elif mean >= 60 and mean < 70:\n            return 'D'\n        else:\n            return 'F'", "import statistics\n\ndef calculate_grade(scores):\n    mean = statistics.mean(scores)\n    if mean >= 90:\n        return 'A'\n    if mean >= 80:\n        return 'B'\n    if mean >= 70:\n        return 'C'\n    if mean >= 60:\n        return 'D'\n    return 'F'", "def calculate_grade(scores):\n    s = sum(scores) / len(scores)\n    return 'ABCDF'[(s < 90) + (s < 80) + (s < 70) + (s < 60)]", "def calculate_grade(scores):\n    import numpy as np\n    mean_score = np.mean(scores)\n    if mean_score >= 90:\n        return 'A'\n    elif mean_score >= 80:\n        return 'B'\n    elif mean_score >= 70:\n        return 'C'\n    elif mean_score >= 60:\n        return 'D'\n    else:\n        return 'F'", "def calculate_grade(scores):\n    mean = sum(scores) / len(scores)\n    return 'ABCDF'[(mean < 90) + (mean < 80) + (mean < 70) + (mean < 60)]", "def calculate_grade(scores):\n    score = sum(scores) / len(scores) / 100\n    grades = {0.6: 'D', 0.7: 'C', 0.8: 'B', 0.9: 'A'}\n    return grades[round(score, 1)] if score > 0.6 else 'F'", "def calculate_grade(scores):\n    avg_grade = sum(scores) / len(scores)\n    if avg_grade < 60:\n        return 'F'\n    elif avg_grade < 70:\n        return 'D'\n    elif avg_grade < 80:\n        return 'C'\n    elif avg_grade < 90:\n        return 'B'\n    else:\n        return 'A'"], "starter_code": "def calculate_grade(scores):\n", "input_output": {"fn_name": "calculate_grade", "inputs": [[[92, 94, 99]], [[50, 60, 70, 80, 90]], [[50, 55]]], "outputs": [["A"], ["C"], ["F"]]}, "difficulty": "EASY", "raw_tags": ["Fundamentals"], "name": null, "source": "codewars", "tags": ["Fundamentals"], "skill_types": [], "url": "https://www.codewars.com/kata/586e0dc9b98de0064b000247", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "calculate_grade", "task_id": "TACO_lite/13"}
{"gt": "U", "requirement": "Given 2 integers n and r. You task is to calculate ^{n}Cr%1000003.\n \nExample 1:\nInput: n = 5, r = 2\nOutput: 10\nExplanation: ^{5}C2 = 5! / (2! * 3!) = 10\nExample 2:\nInput: n = 3, r = 2\nOutput: 3\nExplanation: ^{3}C2 = 3! / (2! * 1!) = 3\n \nYour Task:\nYou don't need to read or print anything. Your task is to complete the function nCr() which takes n and r as input parameter and returns nCr modulo 1000003.\n \nExpected Time Complexity: O(m * log_{m}n) where m = 1000003\nExpected Space Complexity: O(m)\n \nConstraints:\n1 <= n <= r <= 10^{16}", "solutions": ["M = 1000003\n\ndef __init__():\n    self.f = [1] * M\n    for i in range(1, M):\n        self.f[i] = self.f[i - 1] * i % M\n\ndef ncr(n, r):\n    if r > n:\n        return 0\n    if r == 0:\n        return 1\n    if n < M and r < M:\n        return self.f[n] * pow(self.f[r], M - 2, M) * pow(self.f[n - r], M - 2, M) % M\n    return self.ncr(n // M, r // M) * self.ncr(n % M, r % M) % M", "def fact(dp, p):\n    dp[0] = 1\n    for i in range(1, p):\n        dp[i] = dp[i - 1] * i % p\n\ndef inverse(x, p):\n    if not x:\n        return 1\n    for i in range(1, p):\n        if int(x * i % p) == int(1 % p):\n            return i\n\ndef find(n, r, p, dp):\n    if n < r:\n        return 0\n    num = dp[n]\n    den = dp[n - r] * dp[r] % p\n    val = num * self.inverse(den, p) % p\n    return val\n\ndef lucas(n, r, dp, p):\n    if r == 0:\n        return 1\n    ni = int(n % p)\n    ri = int(r % p)\n    return self.lucas(n / p, r / p, dp, p) * self.find(ni, ri, p, dp) % p\n\ndef ncr(n, r):\n    p = 1000003\n    dp = [0] * 1000004\n    self.fact(dp, p)\n    return self.lucas(n, r, dp, p)", "def ncr(n, r):\n    mod = 1000003\n\n    def bin_expo(a, b):\n        ans = 1\n        while b > 0:\n            if b & 1:\n                ans = ans * a % mod\n            a = a * a % mod\n            b = b // 2\n        return ans\n\n    def mod_inverse(a):\n        return bin_expo(a, mod - 2)\n\n    def fermat(n, r):\n        if n < r:\n            return 0\n        if r == 0 or n == r:\n            return 1\n        if r == n - 1 or r == 1:\n            return n\n        fact = [0] * (n + 1)\n        fact[0] = 1\n        for i in range(1, n + 1):\n            fact[i] = fact[i - 1] * i % mod\n        a = fact[n]\n        b = mod_inverse(fact[r])\n        c = mod_inverse(fact[n - r])\n        return a * b % mod * c % mod % mod\n\n    def lucas(n, r):\n        if r == 0:\n            return 1\n        ni = n % mod\n        ri = r % mod\n        return lucas(n // mod, r // mod) * fermat(ni, ri) % mod\n    return lucas(n, r)", "def ncrfarment(n, r):\n    p = 1000003\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * pow(den, p - 2, p) % p\n\ndef ncr(n, r):\n    p = 1000003\n    if r == 0:\n        return 1\n    ni = int(n % p)\n    ri = int(r % p)\n    return self.ncr(int(n / p), int(r / p)) * self.ncrfarment(ni, ri) % p", "def ncr(n, r):\n    large = 1000003\n    (num, den) = self.test(n, r)\n    inv = self.modular_inverse(den, large)\n    return num * inv % large\n\ndef test(n, r):\n    if r == 0:\n        return (1, 1)\n    large = 1000003\n    r = min(r, n - r)\n    until = r % large + large if r > large else r\n    n_i = (n - r) % large\n    r_i = 0\n    num = 1\n    den = 1\n    zero = 0\n    while r_i < until:\n        n_i = (n_i + 1) % large\n        r_i += 1\n        if n_i == 0:\n            zero += 1\n            if zero > until // large:\n                return (0, 1)\n        else:\n            num = num * n_i % large\n        if r_i % large > 0:\n            den = den * (r_i % large) % large\n    (num_1, den_1) = self.test(n // large, r // large)\n    num = num * num_1 % large\n    den = den * den_1 % large\n    return (num, den)\n\ndef modular_inverse(a, n):\n    x1 = 0\n    x2 = 1\n    while a != 0:\n        q = n // a\n        (n, a) = (a, n % a)\n        (x1, x2) = (x2, x1 - x2 * q)\n    return x1", "def fact(dp, p):\n    dp[0] = 1\n    for i in range(1, p):\n        dp[i] = dp[i - 1] * i % p\n\ndef inverse(x, p):\n    if x == 0:\n        return 1\n    for i in range(1, p):\n        if x * i % p == 1 % p:\n            return i\n\ndef ncr(dp, n, r, p):\n    if n < r:\n        return 0\n    num = dp[n] % p\n    den = dp[n - r] * dp[r] % p\n    return num * self.inverse(den, p) % p\n\ndef lucas(dp, n, r, p):\n    if r == 0:\n        return 1\n    n_ = int(n % p)\n    r_ = int(r % p)\n    return self.lucas(dp, n / p, r / p, p) * self.ncr(dp, n_, r_, p) % p\n\ndef ncr(n, r):\n    p = 1000003\n    dp = [0 for _ in range(p + 1)]\n    self.fact(dp, p)\n    return self.lucas(dp, n, r, p)", "M = 1000003\n\ndef lucas(n, r, m):\n    if r == 0:\n        return 1\n    if n < m and r < m:\n        (f, r) = ([1] * (n + 1), min(r, n))\n        for i in range(1, len(f)):\n            f[i] = f[i - 1] * i % m\n        return f[n] * pow(f[r], m - 2, m) * pow(f[n - r], m - 2, m) % m\n    return lucas(n // m, r // m, m) * lucas(n % m, r % m, m) % m\n\ndef ncr(n, r):\n\n    def count(x):\n        res = 0\n        while x > 0:\n            res += x // M\n            x //= M\n        return res\n    if count(n) > count(r) + count(n - r):\n        return 0\n    return lucas(n, r, M)\n\ndef __init__():\n    self.a = [1] * M\n    for i in range(1, len(self.a)):\n        self.a[i] = self.a[i - 1] * i % M", "def __init__():\n    self.m = 1000003\n    self.fact = [1] * self.m\n    for i in range(1, self.m):\n        self.fact[i] = self.fact[i - 1] * i % self.m\n\ndef fast_pow(base, exp):\n    res = 1\n    while exp:\n        if exp % 2:\n            res = res * base % self.m\n        base = base * base % self.m\n        exp //= 2\n    return res\n\ndef inverse(a):\n    return self.fast_pow(a, self.m - 2)\n\ndef small(n, r):\n    if r > n:\n        return 0\n    return self.fact[n] * self.inverse(self.fact[r] * self.fact[n - r] % self.m) % self.m\n\ndef ncr(n, r):\n    if n == 0 or r == 0:\n        return 1\n    return self.ncr(n // self.m, r // self.m) * self.small(n % self.m, r % self.m) % self.m", "def __init__():\n    self.m = 1000003\n    self.fact = [1] * self.m\n    for i in range(1, self.m):\n        self.fact[i] = self.fact[i - 1] * i % self.m\n\ndef inverse(a):\n    return pow(a, self.m - 2, self.m)\n\ndef small(n, r):\n    if r > n:\n        return 0\n    return self.fact[n] * self.inverse(self.fact[r] * self.fact[n - r] % self.m) % self.m\n\ndef ncr(n, r):\n    if n == 0 or r == 0:\n        return 1\n    return self.ncr(n // self.m, r // self.m) * self.small(n % self.m, r % self.m) % self.m"], "starter_code": "def ncr(n, r):\n", "input_output": {"inputs": ["n = 5, r = 2", "n = 3, r = 2"], "outputs": ["10", "3"]}, "difficulty": "MEDIUM_HARD", "raw_tags": ["Combinatorial", "Algorithms", "Modular Arithmetic"], "name": null, "source": "geeksforgeeks", "tags": ["Number theory", "Combinatorics"], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/ncr-mod-m-part-10038/1", "Expected Auxiliary Space": "O(m)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(m * log_{m}n) where m = 1000003", "entry_point": "ncr", "task_id": "TACO_lite/14"}
{"gt": "U", "requirement": "You probably know the \"like\" system from Facebook and other pages. People can \"like\" blog posts, pictures or other items. We want to create the text that should be displayed next to such an item.\n\nImplement a function `likes :: [String] -> String`, which must take in input array, containing the names of people who like an item. It must return the display text as shown in the examples:\n\n```python\nlikes([]) # must be \"no one likes this\"\nlikes([\"Peter\"]) # must be \"Peter likes this\"\nlikes([\"Jacob\", \"Alex\"]) # must be \"Jacob and Alex like this\"\nlikes([\"Max\", \"John\", \"Mark\"]) # must be \"Max, John and Mark like this\"\nlikes([\"Alex\", \"Jacob\", \"Mark\", \"Max\"]) # must be \"Alex, Jacob and 2 others like this\"\n```\n\nFor 4 or more names, the number in `and 2 others` simply increases.", "solutions": ["def likes(names):\n    n = len(names)\n    return {0: 'no one likes this', 1: '{} likes this', 2: '{} and {} like this', 3: '{}, {} and {} like this', 4: '{}, {} and {others} others like this'}[min(4, n)].format(*names[:3], others=n - 2)", "def likes(names):\n    if len(names) == 0:\n        return 'no one likes this'\n    elif len(names) == 1:\n        return '%s likes this' % names[0]\n    elif len(names) == 2:\n        return '%s and %s like this' % (names[0], names[1])\n    elif len(names) == 3:\n        return '%s, %s and %s like this' % (names[0], names[1], names[2])\n    else:\n        return '%s, %s and %s others like this' % (names[0], names[1], len(names) - 2)", "def likes(names):\n    if not names:\n        return 'no one likes this'\n    if len(names) == 1:\n        first = ''\n        second = names[0]\n    elif len(names) == 2:\n        first = names[0]\n        second = names[1]\n    elif len(names) == 3:\n        first = ', '.join(names[:2])\n        second = names[-1]\n    else:\n        first = ', '.join(names[:2])\n        second = '%d others' % (len(names) - 2)\n    if first:\n        return first + ' and ' + second + ' like this'\n    else:\n        return second + ' likes this'", "def likes(names):\n    l = len(names)\n    if l == 0:\n        return 'no one likes this'\n    if l == 1:\n        return '{} likes this'.format(names[0])\n    if l == 2:\n        return '{} and {} like this'.format(names[0], names[1])\n    if l == 3:\n        return '{}, {} and {} like this'.format(names[0], names[1], names[2])\n    return '{}, {} and {} others like this'.format(names[0], names[1], len(names) - 2)", "def likes(names):\n    if not names:\n        return 'no one likes this'\n    size = len(names)\n    if size == 1:\n        return '%s likes this' % names[0]\n    if size == 2:\n        return '%s and %s like this' % (names[0], names[1])\n    if size == 3:\n        return '%s, %s and %s like this' % (names[0], names[1], names[2])\n    if size >= 4:\n        return '%s, %s and %s others like this' % (names[0], names[1], len(names[2:]))", "def likes(names):\n    l = len(names)\n    s = 'no one likes this'\n    if l == 1:\n        s = names[0] + ' likes this'\n    elif l == 2:\n        s = ' and '.join(names) + ' like this'\n    elif l == 3:\n        s = ', '.join(names[:-1]) + ' and ' + names[-1] + ' like this'\n    elif l != 0:\n        s = ', '.join(names[:2]) + ' and ' + str(l - 2) + ' others like this'\n    return s"], "starter_code": "def likes(names):\n", "input_output": {"fn_name": "likes", "inputs": [[[]], [["Peter"]], [["Jacob", "Alex"]], [["Max", "John", "Mark"]], [["Alex", "Jacob", "Mark", "Max"]]], "outputs": [["no one likes this"], ["Peter likes this"], ["Jacob and Alex like this"], ["Max, John and Mark like this"], ["Alex, Jacob and 2 others like this"]]}, "difficulty": "EASY", "raw_tags": ["Strings", "Fundamentals"], "name": null, "source": "codewars", "tags": ["String algorithms", "Fundamentals"], "skill_types": [], "url": "https://www.codewars.com/kata/5266876b8f4bf2da9b000362", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "likes", "task_id": "TACO_lite/15"}
{"gt": "U", "requirement": "Given 3 characters 'a', 'b', 'c'. Find the number of strings of length n that can be formed from these 3 characters. Given that : we can use ‘a’ as many times as we want, ‘b’ maximum once, and ‘c’ maximum twice.\n \nExample 1:\nInput: n = 2\nOutput: 8\nExpalantion: There are total 8 possible\nstrings and these are: {aa, ab, ba, ac,\nca, bc, cb, cc}.\nExample 2:\nInput: n = 3\nOutput: 19\nExplanation: There are total 19 possible\nstrings.\n \nYour Task:\nYou don't need to read or print anything. Your task is to complete the function no_ofString() which takes n as input parameter ans returns the no. of total possible strings than can be formed using characters 'a', 'b' and 'c' modulo 10^{9} + 7.\n \nExpected Time Complexity: O(n)\nExpected Space Compelxity: O(n)\n \nConstraints:\n1 <= n <= 100000", "solutions": ["def no_ofstring(n):\n    l = 10 ** 9 + 7\n    return (1 + n * 2 + n * (n * n - 1) // 2) % l", "def no_ofstring(n):\n    m = 1000000007\n    ans = 1 + 2 * (n % m) + n % m * (n % m - 1) * (n % m + 1) // 2\n    return ans % m", "def no_ofstring(n):\n    return (n * n * n + (3 * n + 2)) // 2 % 1000000007", "def no_ofstring(n):\n    m = 10 ** 9 + 7\n    ans = 1 + 2 * (n % m) + n % m * (n % m - 1) * (n % m + 1) // 2\n    return ans % m", "def no_ofstring(n):\n    if n == 1:\n        return 3\n    mod = int(10 ** 9 + 7)\n    total = 1 + n % mod + n * n % mod + n * (n - 1) * (n - 1) // 2 % mod\n    return total % mod", "def no_ofstring(n):\n    if n == 1:\n        return 3\n    total = 0\n    for i in range(3):\n        combination = 1\n        bottom_part = 1\n        for x in range(i):\n            combination *= n - x\n            bottom_part *= x + 1\n        total = (total + combination // bottom_part) % (10 ** 9 + 7)\n    for i in range(3):\n        combination = 1\n        bottom_part = 1\n        for x in range(i):\n            combination *= n - 1 - x\n            bottom_part *= x + 1\n        total = (total + n * (combination // bottom_part)) % (10 ** 9 + 7)\n    return total", "def possibilities(x):\n    count = 1\n    while x > 1:\n        count *= x\n        x -= 1\n    return count\n\ndef no_ofstring(n):\n    if n == 1:\n        return 3\n    all_a = 1\n    one_b_other_a = n % (10 ** 9 + 7)\n    one_c_other_a = n % (10 ** 9 + 7)\n    one_c_one_b = n % (10 ** 9 + 7)\n    if n > 2:\n        one_c_one_b = n * (n - 1) % (10 ** 9 + 7)\n    two_c = 1\n    if n > 2:\n        two_c = int(n * (n - 1) / 2) % (10 ** 9 + 7)\n    one_b_two_c = 0\n    if n > 2:\n        one_b_two_c = int(n * (n - 1) * (n - 2) / 2) % (10 ** 9 + 7)\n    return (all_a + one_b_other_a + one_c_other_a + one_c_one_b + two_c + one_b_two_c) % (10 ** 9 + 7)"], "starter_code": "def no_ofstring(n):\n", "input_output": {"inputs": ["n = 2", "n = 3"], "outputs": ["8", "19"]}, "difficulty": "EASY", "raw_tags": ["Algorithms", "Mathematical", "permutation"], "name": null, "source": "geeksforgeeks", "tags": ["Combinatorics", "Mathematics"], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/total-number-of-strings5726/1", "Expected Auxiliary Space": "O(n)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(n)", "entry_point": "no_ofstring", "task_id": "TACO_lite/16"}
{"gt": "U", "requirement": "A frog starts at the point 0. In his first turn, he can make a jump of 1 unit. Now for all consequent turns, if the frog is currently at a distance x (from the start), his jump will take him x units forward. Given a leaf at a distance N, you have to find if the frog can reach that leaf or not.\n \nExample 1:\nInput:\nN = 3\nOutput:\nFalse\nExplanation:\nThe frog can't reach the position 3.\nExample 2:\nInput:\nN = 2\nOutput:\nTrue\nExplanation:\nThe frog will jump to position 1 in\nthe first jump. Now, he is at a distance\nof 1 from the start, so he cam jump 1m.\nSo, he reaches the point 2.\n \nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function canJump() which takes an Integer N as input and return \"True\" if the frog can reach N else return \"False\".\n \nExpected Time Complexity: O(1)\nExpected Auxiliary Space: O(1)\n \nConstraints:\n1 <= N <= 10^{18}", "solutions": ["def canjump(N):\n    if N == 1:\n        return True\n    if N % 2 == 1:\n        return False\n    else:\n        while N > 2:\n            N = N / 2\n            if N % 2 == 1:\n                return False\n                break\n        if N == 2:\n            return True", "def canjump(N):\n    prev = 1\n    while prev <= N:\n        if prev == N:\n            return True\n        prev += prev\n    return False", "def canjump(n):\n    if n & n - 1 == 0:\n        return True\n    else:\n        return False", "def canjump(N):\n    if N & N - 1 == 0:\n        return 'True'\n    return 'False'", "def canjump(N):\n    i = 0\n    a = 2 ** i\n    while a < N:\n        i += 1\n        a = 2 ** i\n    return a == N", "def canjump(N):\n    return not N & N - 1", "def canjump(N):\n    distance = 0\n    while distance <= N:\n        if distance == 0 or distance == 1:\n            distance += 1\n        else:\n            distance *= 2\n        if distance == N:\n            return True\n    return False", "import math\n\ndef canjump(N):\n    num = int(math.log(N, 2))\n    if 2 ** num == N:\n        return 'True'\n    else:\n        return 'False'", "def canjump(n):\n    return not n & n - 1", "def canjump(N):\n    if N == 1 or (N and (not N & N - 1)) is True:\n        return True\n    return False", "def canjump(N):\n    return N & N - 1 == 0", "def canjump(N):\n    if N == 1 or N == 2:\n        return True\n    b = 2\n    while b < N:\n        b += b\n    if b == N:\n        return True\n    else:\n        return False", "def canjump(N):\n    while True:\n        if N == 1:\n            return True\n        elif N % 2 == 0:\n            N = N // 2\n        else:\n            return False", "def canjump(N):\n    return bin(N).count('1') == 1", "def canjump(N):\n    jump_dist = 1\n    dist = 0\n    incr = 0\n    while dist < N:\n        dist += jump_dist\n        if dist == N:\n            return True\n        jump_dist = dist\n    return False", "def canjump(N):\n    res = 0\n    while pow(2, res) <= N:\n        if pow(2, res) == N:\n            return 'True'\n        res += 1\n    return False", "def canjump(n):\n    k = 1\n    while k <= n:\n        if k == n:\n            return True\n        k = k * 2\n    return False", "def canjump(N):\n    j = 1\n    while j <= N:\n        if j == N:\n            return True\n        j = 2 * j\n    return False", "def canjump(N):\n    current = 1\n    prev = 0\n    result = False\n    while prev <= N:\n        if prev == N:\n            result = True\n        prev += current\n        current = prev\n    return result", "def canjump(x):\n    if x == 1 or (x and (not x & x - 1)) is True:\n        return True\n    else:\n        return False", "import math\n\ndef canjump(N):\n    if math.log(N, 2).is_integer():\n        return True\n    return False", "def canjump(N):\n\n    def possible(curr, prev):\n        if curr == N:\n            return True\n        if curr > N:\n            return False\n        if prev == 0:\n            return possible(curr + 1, 1)\n        else:\n            return possible(curr + prev, curr + prev)\n    return possible(0, 0)", "import math\n\ndef canjump(N):\n    return math.log(int(N), 2).is_integer()", "def canjump(N):\n    if N == 1:\n        return True\n    Flag = False\n    curr = 1\n    while curr < N:\n        curr += curr\n    if curr == N:\n        Flag = True\n    return Flag", "def canjump(N):\n    if N == 1:\n        return True\n    c_jump = 1\n    jump = 0\n    while jump < N:\n        jump = jump + c_jump\n        c_jump = jump\n    if jump == N:\n        return True\n    else:\n        return False", "def canjump(N):\n    count = 0\n    step = 1\n    while count < N:\n        count += step\n        step = count\n        if count == N:\n            return True\n    return False", "import math\n\ndef canjump(N):\n    if N == 0:\n        return true\n    n = math.log2(N)\n    if n == int(n):\n        return True\n    return False", "import math\n\ndef canjump(N):\n    if N & N - 1 == 0:\n        return True\n    else:\n        return False", "def canReach(n, i):\n    if i == n:\n        return True\n    elif i > n:\n        return False\n    return self.canReach(n, i + i)\n\ndef canjump(N):\n    if N == 0:\n        return True\n    i = 1\n    return self.canReach(N, i)", "def canjump(N):\n    for i in range(100):\n        n = pow(2, i)\n        if n == N:\n            return 'True'\n    return 'False'", "import math\n\ndef canjump(N):\n    x = math.log(N, 2)\n    if pow(2, int(x)) == N or N == 1:\n        return True\n    else:\n        return False", "def canjump(N):\n    if N == 0:\n        return True\n    if N == 1:\n        return True\n    ans = 1\n    for i in range(1, N):\n        ans = ans * 2\n        if ans == N:\n            return True\n        if ans > N:\n            return False\n    return False", "def canjump(N):\n    x = 0\n    i = 1\n    while x < N:\n        x += i\n        i = x\n    if x == N:\n        return True\n    return False", "def canjump(N):\n    position = 0\n    num = N\n    flag = 0\n    while position <= num:\n        if position == num:\n            flag = 1\n        if position == 0:\n            position = position + 1\n        else:\n            position = 2 * position\n    if flag == 0:\n        return False\n    else:\n        return True", "def canjump(N):\n    s = 0\n    a = False\n    i = 1\n    while i <= N:\n        if i == N:\n            a = True\n            break\n        else:\n            i = i * 2\n    return a", "def canjump(N):\n    n = N\n    return n == 0 or n & n - 1 == 0", "def canjump(N):\n    cj = 1\n    j = 0\n    while j < N:\n        j = j + cj\n        cj = j\n    if j == N:\n        return 'True'\n    return 'False'", "def canjump(N):\n\n    def isposs(n, N):\n        if n == N:\n            return True\n        if n > N:\n            return False\n        return isposs(2 * n, N)\n    return isposs(1, N)", "def canjump(N):\n    curr_jump = 1\n    jump = 0\n    while jump < N:\n        jump += curr_jump\n        curr_jump = jump\n    return jump == N", "def canjump(N):\n    if N == 0 or N == 1:\n        return True\n    elif not N & N - 1:\n        return True\n    else:\n        return False", "import math\n\ndef canjump(N):\n    x = math.log(N) / math.log(2)\n    if 2 ** x == 2 ** int(x):\n        return True\n    return False", "import math\n\ndef canjump(N):\n    if N == 0 or N == 1:\n        return 'True'\n    res = math.log2(N)\n    if int(res) == res:\n        return 'True'\n    return 'False'"], "starter_code": "def canjump(N):\n", "input_output": {"inputs": ["N = 3", "N = 2"], "outputs": ["False", "True"]}, "difficulty": "EASY", "raw_tags": ["Algorithms", "Mathematical"], "name": null, "source": "geeksforgeeks", "tags": ["Mathematics"], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/pattern-jumping4855/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(1)", "entry_point": "canjump", "task_id": "TACO_lite/17"}
{"gt": "U", "requirement": "Given a dictionary of words and a pattern. Every character in the pattern is uniquely mapped to a character in the dictionary. Find all such words in the dictionary that match the given pattern. \nExample 1:\nInput:\nN = 4\ndict[] = {abb,abc,xyz,xyy}\npattern  = foo\nOutput: abb xyy\nExplanation: xyy and abb have the same\ncharacter at index 1 and 2 like the\npattern.\nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function findMatchedWords() which takes an array of strings dict[] consisting of the words in the dictionary and a string, Pattern and returns an array of strings consisting of all the words in the dict[] that match the given Pattern in lexicographical order.\nExpected Time Complexity: O(N*K) (where K is the length of the pattern).\nExpected Auxiliary Space: O(N).\nConstraints:\n1 <= N <= 10", "solutions": ["def findspecificpattern(Dict, pattern):\n    ans = []\n    for i in Dict:\n        dic = {}\n        dic2 = {}\n        if len(i) == len(pattern):\n            flag = True\n            for (j, k) in zip(i, pattern):\n                if j not in dic and k not in dic2:\n                    dic[j] = k\n                    dic2[k] = j\n                elif dic.get(j) != k or dic2.get(k) != j:\n                    flag = False\n            if flag:\n                ans.append(i)\n    return ans", "def findspecificpattern(dict, pattern):\n    lst = []\n    for i in dict:\n        if len(set(i)) == len(set(pattern)) == len(set(zip(i, pattern))) and len(i) == len(pattern):\n            lst.append(i)\n    return lst", "def findspecificpattern(Dict, pattern):\n    d = {}\n    for i in pattern:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    b = list(d.values())\n    b.sort()\n    a = []\n    c = []\n    for i in Dict:\n        d2 = {}\n        for j in i:\n            if j in d2:\n                d2[j] += 1\n            else:\n                d2[j] = 1\n        x = list(d2.values())\n        x.sort()\n        a.append(x)\n        c.append(i)\n        d2.clear()\n    d = []\n    for i in range(len(a)):\n        if b == a[i]:\n            d.append(c[i])\n    return d", "def findspecificpattern(Dict, pattern):\n    a = []\n    for i in Dict:\n        if len(i) != len(pattern):\n            continue\n        d1 = {}\n        d2 = {}\n        for j in range(len(i)):\n            if i[j] not in d1.keys() or pattern[j] not in d2.keys():\n                d1[i[j]] = pattern[j]\n                d2[pattern[j]] = i[j]\n            elif d1[i[j]] != pattern[j] or d2[pattern[j]] != i[j]:\n                break\n        if len(d1) == len(d2):\n            a.append(i)\n    return a", "def encodeString(Str):\n    map = {}\n    res = ''\n    i = 0\n    for ch in Str:\n        if ch not in map:\n            map[ch] = i\n            i += 1\n        res += str(map[ch])\n    return res\n\ndef findMatchedWords(dict, pattern):\n    Len = len(pattern)\n    hash = encodeString(pattern)\n    res = []\n    for word in dict:\n        if len(word) == Len and encodeString(word) == hash:\n            res.append(word)\n    return res\n\ndef findspecificpattern(Dict, pattern):\n    return findMatchedWords(Dict, pattern)", "def findspecificpattern(Dict, pattern):\n    ans = []\n    flag = False\n    for stri in Dict:\n        flag = False\n        if len(stri) == len(pattern):\n            for i in range(len(pattern) - 1):\n                if stri[i] != stri[i + 1] and pattern[i] != pattern[i + 1] or (stri[i] == stri[i + 1] and pattern[i] == pattern[i + 1]):\n                    flag = True\n                else:\n                    flag = False\n                    break\n            if flag == True:\n                dic = {}\n                pic = {}\n                for i in range(len(pattern)):\n                    if stri[i] not in dic:\n                        dic[stri[i]] = 1\n                    else:\n                        dic[stri[i]] += 1\n                    if pattern[i] not in pic:\n                        pic[pattern[i]] = 1\n                    else:\n                        pic[pattern[i]] += 1\n                for i in range(len(pattern)):\n                    if dic[stri[i]] != pic[pattern[i]]:\n                        flag = False\n                        break\n            if len(stri) == 1 and len(pattern) == 1:\n                ans.append(stri)\n        if flag == True:\n            ans.append(stri)\n    return ans", "def findspecificpattern(Dict, pattern):\n    a = []\n    for i in Dict:\n        if len(set(i)) == len(set(pattern)) and len(i) == len(pattern):\n            a.append(i)\n    return a", "def hash_fn(word):\n    k = 0\n    mapper = {}\n    res = ''\n    for i in word:\n        if i not in mapper:\n            mapper[i] = k\n            k += 1\n        res += str(mapper[i])\n    return res\n\ndef findspecificpattern(Dict, pattern):\n    ptrn_hsh = hash_fn(pattern)\n    l = len(pattern)\n    res = []\n    for i in Dict:\n        if len(i) == l and hash_fn(i) == ptrn_hsh:\n            res.append(i)\n    return res", "def findspecificpattern(Dict, pattern):\n    matched_words = []\n    for word in Dict:\n        if len(word) == len(pattern):\n            matched = True\n            pattern_dict = {}\n            for i in range(len(word)):\n                if word[i] not in pattern_dict:\n                    if pattern[i] in pattern_dict.values():\n                        matched = False\n                        break\n                    pattern_dict[word[i]] = pattern[i]\n                elif pattern_dict[word[i]] != pattern[i]:\n                    matched = False\n                    break\n            if matched:\n                matched_words.append(word)\n    matched_words.sort()\n    return matched_words", "def findspecificpattern(Dict, pattern):\n    pattern_list = []\n    for item in Dict:\n        if len(item) != len(pattern):\n            pattern_list.append('')\n            continue\n        new_pattern = pattern\n        char_dict = {}\n        temp_str = ''\n        for i in range(len(item)):\n            if item[i] in char_dict:\n                temp_str = temp_str + char_dict[item[i]]\n            elif new_pattern != '':\n                char_dict[item[i]] = new_pattern[0]\n                new_pattern = new_pattern.replace(new_pattern[0], '')\n                temp_str = temp_str + char_dict[item[i]]\n        pattern_list.append(temp_str)\n    final_pattern = []\n    for i in range(len(pattern_list)):\n        if pattern_list[i] == pattern:\n            final_pattern.append(Dict[i])\n    return final_pattern\n    return final_pattern", "def findspecificpattern(Dict, pattern):\n    d = {}\n    for (i, char) in enumerate(pattern):\n        if char in d:\n            d[char].append(i)\n        else:\n            d[char] = [i]\n    control = sorted(d.values())\n    output = []\n    for word in Dict:\n        temp = {}\n        for (i, char) in enumerate(word):\n            if char in temp:\n                temp[char].append(i)\n            else:\n                temp[char] = [i]\n        if sorted(temp.values()) == control:\n            output.append(word)\n    return sorted(output)", "def findspecificpattern(Dict, pattern):\n    dct = {}\n    arr = [0] * len(pattern)\n    j = 0\n    ans = []\n    for i in pattern:\n        if i in dct:\n            dct[i] += 1\n            arr[j] = dct[i]\n        else:\n            arr[j] = 1\n            dct[i] = 1\n        j += 1\n    for p in Dict:\n        arr2 = [0] * len(p)\n        j = 0\n        dct = {}\n        for i in p:\n            if i in dct:\n                dct[i] += 1\n                arr2[j] = dct[i]\n            else:\n                arr2[j] = 1\n                dct[i] = 1\n            j += 1\n        if arr == arr2:\n            ans.append(p)\n    return ans", "def findspecificpattern(Dict, pattern):\n    res = []\n\n    def helper(pattern, elem):\n        d = {}\n        n = len(pattern)\n        if n != len(elem):\n            return\n        for i in range(n):\n            if pattern[i] in d and elem[i] != d[pattern[i]]:\n                break\n            elif pattern[i] not in d and elem[i] in d.values():\n                break\n            else:\n                d[pattern[i]] = elem[i]\n        else:\n            return elem\n    for x in Dict:\n        if helper(pattern, x):\n            res.append(helper(pattern, x))\n    return res", "def findspecificpattern(Dict, pattern):\n    length = len(pattern)\n    hash = encodeString(pattern)\n    result = []\n    for word in Dict:\n        if len(word) == length and encodeString(word) == hash:\n            result.append(word)\n    return result\n\ndef encodeString(Str):\n    map = {}\n    res = ''\n    i = 0\n    for ch in Str:\n        if ch not in map:\n            map[ch] = i\n            i += 1\n        res += str(map[ch])\n    return res", "def encodeString(string):\n    map = {}\n    res = ''\n    i = 0\n    for ch in string:\n        if ch not in map:\n            map[ch] = i\n            i += 1\n        res += str(map[ch])\n    return res\n\ndef findspecificpattern(Dict, pattern):\n    size = len(pattern)\n    hash_map = encodeString(pattern)\n    output = []\n    for word in Dict:\n        if len(word) == size and encodeString(word) == hash_map:\n            output.append(word)\n    return output", "def findspecificpattern(Dict, pattern):\n\n    def encode(word):\n        m = {}\n        s = ''\n        counter = 0\n        for c in word:\n            if c not in m:\n                m[c] = counter\n                counter += 1\n            s += str(m[c])\n        return s\n    pattern_hash = encode(pattern)\n    result = []\n    for word in Dict:\n        word_hash = encode(word)\n        if pattern_hash == word_hash:\n            result.append(word)\n    return result", "def findspecificpattern(Dict, pattern):\n    d = {}\n    da = []\n    p = 0\n    s = set(pattern)\n    for i in Dict:\n        if len(set(i)) == len(s):\n            da.append(i)\n    for i in da:\n        l1 = []\n        l2 = []\n        c = 0\n        p += 1\n        for j in i:\n            if l1 == []:\n                l1.append(j)\n                c += 1\n            elif l1[-1] == j:\n                l1.append(j)\n                c += 1\n            elif l1[-1] != j:\n                l1.append(j)\n                l2.append(c)\n                c = 1\n        if l1[-1] == i[-1]:\n            l2.append(c)\n            l2.insert(0, p)\n            l2.insert(1, i)\n        else:\n            l2.append(1)\n            l2.insert(0, p)\n            l2.insert(1, i)\n        if i not in d:\n            d[i] = [l2]\n        else:\n            d[i].append(l2)\n    k = []\n    l11 = []\n    l22 = []\n    c1 = 0\n    for i in pattern:\n        if l11 == []:\n            l11.append(i)\n            c1 += 1\n        elif l11[-1] == i:\n            l11.append(i)\n            c1 += 1\n        elif l11[-1] != i:\n            l11.append(i)\n            l22.append(c1)\n            c1 = 1\n    if l11[-1] == pattern[-1]:\n        l22.append(c1)\n    else:\n        l22.append(1)\n    k.append(l22)\n    l3 = []\n    l4 = []\n    for i in d:\n        if d[i][0][2:] == k[-1]:\n            l3.append(d[i][0] * len(d[i]))\n    l3.sort()\n    for i in l3:\n        l4 += [i[1]] * len(d[i[1]])\n    return l4", "from collections import OrderedDict\n\ndef findspecificpattern(Dict, t):\n    l = []\n    n = len(t)\n    for j in Dict:\n        d = {}\n        m = len(j)\n        if m != n:\n            continue\n        flag = 1\n        for i in range(m):\n            if j[i] not in d and t[i] not in d.values():\n                d[j[i]] = t[i]\n            elif j[i] in d and d[j[i]] != t[i]:\n                flag = 0\n            elif j[i] not in d and t[i] in d.values():\n                flag = 0\n        if flag:\n            l.append(j)\n    return l", "from collections import OrderedDict\n\ndef findspecificpattern(Dict, pattern):\n    l = []\n    for i in Dict:\n        if len(i) != len(pattern) and len(set(i)) != len(set(pattern)):\n            continue\n        else:\n            temp = i\n            for j in list(zip(list(OrderedDict.fromkeys(temp)), list(OrderedDict.fromkeys(pattern)))):\n                temp = temp.replace(j[0], j[1])\n            if temp == pattern:\n                l.append(i)\n    return l", "def findspecificpattern(Dict, pattern):\n    lis = []\n    for i in range(len(Dict)):\n        word = Dict[i]\n        if len(set(word)) == len(set(pattern)) and len(word) == len(pattern):\n            l = {}\n            check = 1\n            for i in range(len(pattern)):\n                if pattern[i] in l:\n                    if l[pattern[i]] != word[i]:\n                        check = 0\n                        break\n                else:\n                    l[pattern[i]] = word[i]\n            if check == 1:\n                lis.append(word)\n    return lis", "def findspecificpattern(Dict, pattern):\n    pattern_mapp = {}\n    pattern_str = ''\n    for (idx, char) in enumerate(pattern):\n        if char not in pattern_mapp:\n            pattern_mapp[char] = str(idx)\n            pattern_str += str(idx)\n        else:\n            pattern_str += pattern_mapp[char]\n    hashes = []\n    for i in range(len(Dict)):\n        dict_map = {}\n        hash = ''\n        for (idx, char) in enumerate(Dict[i]):\n            if char not in dict_map:\n                dict_map[char] = str(idx)\n                hash += str(idx)\n            else:\n                hash += dict_map[char]\n        if hash == pattern_str:\n            hashes.append(Dict[i])\n    return hashes", "def Pattern(pattern):\n    code = {}\n    num = 1\n    temp = ''\n    for i in range(len(pattern)):\n        if not code.get(pattern[i]):\n            code[pattern[i]] = num\n            num += 1\n        else:\n            num += 1\n            code[pattern[i]] = num\n    for i in pattern:\n        temp += str(code[i])\n    return temp\n\ndef findspecificpattern(Dict, pattern):\n    checker = Pattern(pattern)\n    li = []\n    for i in Dict:\n        temp = Pattern(i)\n        if temp == checker:\n            li.append(i)\n    return li", "def get_hashmap(stra):\n    hash_d = dict()\n    for k in range(len(stra)):\n        if hash_d.get(stra[k]):\n            hash_d[stra[k]].append(k)\n        else:\n            hash_d[stra[k]] = [k]\n    return set((tuple(i) for i in list(hash_d.values())))\n\ndef findspecificpattern(Dict, pattern):\n    array_pat = []\n    hash_vals = get_hashmap(pattern)\n    for word in Dict:\n        if get_hashmap(word) == hash_vals:\n            array_pat.append(word)\n    array_pat.sort()\n    return array_pat", "from collections import Counter\n\ndef findspecificpattern(Dict, pattern):\n    ans = []\n    dicpat = Counter(pattern)\n    dicpatv = list(dicpat.values())\n    for i in range(0, len(Dict)):\n        if len(Dict[i]) == len(pattern):\n            dici = Counter(Dict[i])\n            dicv = list(dici.values())\n            if len(dicv) == len(dicpatv):\n                for j in range(0, len(dicv)):\n                    if dicv[j] != dicpatv[j]:\n                        dici = {}\n                        diciv = []\n                        continue\n                ans.append(Dict[i])\n                dici = {}\n                diciv = []\n    return ans", "def findspecificpattern(Dict, pattern):\n\n    def getPattern(pattern):\n        patt_str = ''\n        val_m = {}\n        count = 1\n        for val in pattern:\n            if val in val_m:\n                patt_str += str(val_m[val])\n            else:\n                patt_str += str(count)\n                val_m[val] = count\n                count += 1\n        return patt_str\n    result = []\n    match = getPattern(pattern)\n    for val in Dict:\n        p = getPattern(val)\n        if p == match:\n            result.append(val)\n    return result", "def findspecificpattern(Dict, pattern):\n    Dict.append(pattern)\n    res = []\n    c = 0\n    p = ''\n    i = 0\n    k = 0\n    j = 0\n    for i in Dict:\n        while j < len(i):\n            if j == len(i) - 1:\n                p += str(c)\n                j += 1\n                c += 1\n                break\n            while i[j] == i[j + 1]:\n                p += str(c)\n                k = 1\n                j += 1\n                if j == len(i) - 1:\n                    break\n            if j == len(i) - 1:\n                p += str(c)\n                j += 1\n                break\n            p += str(c)\n            j += 1\n            c += 1\n            k = 0\n        res.append(p)\n        p = ''\n        j = 0\n        c = 0\n    p1 = res[-1]\n    res1 = []\n    res.pop()\n    for (i, j) in enumerate(res):\n        if j == p1:\n            res1.append(Dict[i])\n    return res1", "def findspecificpattern(Dict, pattern):\n    L = []\n    n = 0\n    e = ''\n    x = ''\n    pattern = pattern + '.'\n    for i in pattern:\n        if i == e:\n            n += 1\n        else:\n            x = x + str(n)\n            n = 1\n            e = i\n    for i in Dict:\n        n = 0\n        e = ''\n        y = ''\n        i = i + '.'\n        for j in i:\n            if j == e:\n                n += 1\n            else:\n                y = y + str(n)\n                n = 1\n                e = j\n        if y == x:\n            L.append(i[:-1])\n    return L", "def findspecificpattern(Dict, pattern):\n    result = []\n    for word in Dict:\n        hash = {}\n        flag = True\n        if len(word) != len(pattern):\n            continue\n        for (i, c) in enumerate(pattern):\n            if c not in hash:\n                hash[c] = word[i]\n            elif hash[c] != word[i]:\n                flag = False\n        if flag:\n            result.append(word)\n    return result", "def convert(p):\n    m = {}\n    r = ''\n    for i in p:\n        if i not in m:\n            m[i] = 1\n        else:\n            m[i] += 1\n        r = r + str(m[i])\n    return r\n\ndef findspecificpattern(Dict, pattern):\n    ans = []\n    pat = convert(pattern)\n    for i in Dict:\n        if convert(i) == pat:\n            ans.append(i)\n    return ans", "def findspecificpattern(Dict, pattern):\n    from collections import defaultdict, OrderedDict\n    (dnew, dnew2) = (defaultdict(int), defaultdict(int))\n    (dnew3, dnew4) = (OrderedDict(), OrderedDict())\n    (L, res) = ([], [])\n    for i in Dict:\n        if len(set(i)) == len(set(pattern)):\n            L.append(i)\n    for i in range(len(pattern)):\n        dnew[pattern[i]] += 1\n        dnew3[pattern[i]] = dnew[pattern[i]]\n    for k in L:\n        for i in range(len(k)):\n            dnew2[k[i]] += 1\n            dnew4[k[i]] = dnew2[k[i]]\n        if list(dnew4.values()) == list(dnew3.values()):\n            res.append(k)\n        dnew2 = defaultdict(int)\n        dnew4 = OrderedDict()\n    return res", "def findspecificpattern(dictt, pattern):\n    res = []\n\n    def patterniser(strg):\n        d = dict()\n        lst = []\n        pointer = 1\n        for i in strg:\n            if i not in d:\n                d[i] = pointer\n                pointer += 1\n            lst.append(d[i])\n        return lst\n\n    def checker(pat1, pat2):\n        for i in range(len(pat1)):\n            if pat1[i] != pat2[i]:\n                return False\n        return True\n    pat1 = patterniser(pattern)\n    for i in dictt:\n        if len(i) == len(pattern):\n            pat2 = patterniser(i)\n            if checker(pat1, pat2):\n                res.append(i)\n    return res", "def findspecificpattern(Dict, pattern):\n    a = {}\n    aa = []\n    for i in range(len(pattern)):\n        try:\n            if a[pattern[i]] == 0:\n                pass\n        except:\n            a[pattern[i]] = 0\n            aa.append(pattern[i])\n    pp = ''\n    p = {}\n    ans = []\n    for i in range(len(aa)):\n        p[aa[i]] = i\n    for i in range(len(pattern)):\n        pp += str(p[pattern[i]])\n    for j in range(len(Dict)):\n        a = {}\n        aa = []\n        for i in range(len(Dict[j])):\n            try:\n                if a[Dict[j][i]] == 0:\n                    pass\n            except:\n                a[Dict[j][i]] = 0\n                aa.append(Dict[j][i])\n        ppp = ''\n        po = {}\n        for i in range(len(aa)):\n            po[aa[i]] = i\n        for i in range(len(Dict[j])):\n            ppp += str(po[Dict[j][i]])\n        if pp == ppp:\n            ans.append(Dict[j])\n    return ans", "def findspecificpattern(Dict, pattern):\n    dic1 = {}\n    count1 = []\n    for i in pattern:\n        if i not in dic1:\n            dic1[i] = 1\n            count1.append(dic1[i])\n        else:\n            dic1[i] += 1\n            count1.append(dic1[i])\n    dic2 = {}\n    count2 = []\n    output = []\n    for x in Dict:\n        for y in x:\n            if y not in dic2:\n                dic2[y] = 1\n                count2.append(dic2[y])\n            else:\n                dic2[y] += 1\n                count2.append(dic2[y])\n        if count1 == count2:\n            output.append(x)\n        count2 = []\n        dic2 = {}\n    return output", "def ispattern(str1, pattern, n, p):\n    if n != p:\n        return False\n    d = {}\n    for i in range(n):\n        if str1[i] in d:\n            val = d[str1[i]]\n            if val != pattern[i]:\n                return False\n        elif pattern[i] not in d.values():\n            d[str1[i]] = pattern[i]\n        else:\n            return False\n    return True\n\ndef findspecificpattern(Dict, pattern):\n    ans = []\n    p = len(pattern)\n    for i in Dict:\n        if ispattern(i, pattern, len(i), p):\n            ans.append(i)\n    return ans", "def findspecificpattern(Dict, pat):\n    n = len(pat)\n    c = 1\n    l = []\n    for i in range(n - 1):\n        if pat[i] == pat[i + 1]:\n            c += 1\n        else:\n            l.append(c)\n            c = 1\n    l.append(c)\n    h = []\n    for i in Dict:\n        c = 1\n        b = []\n        n = len(i)\n        for j in range(n - 1):\n            if i[j] == i[j + 1]:\n                c += 1\n            else:\n                b.append(c)\n                c = 1\n        b.append(c)\n        if b == l:\n            h.append(i)\n    return h", "def hashmap(Strng):\n    Dic = {}\n    for i in Strng:\n        if i not in Dic:\n            Dic[i] = 1\n        else:\n            Dic[i] += 1\n    return Dic\n\ndef findspecificpattern(Dict, pattern):\n    kiss = []\n    k = 0\n    cont = 0\n    ptr = {}\n    for i in pattern:\n        if i not in ptr:\n            ptr[i] = 1\n        else:\n            ptr[i] += 1\n    lptrn = len(ptr)\n    while k < len(Dict):\n        j = hashmap(Dict[k])\n        ldic = len(j)\n        if lptrn == ldic:\n            if list(ptr.values()) == list(j.values()):\n                kiss.append(Dict[k])\n        k += 1\n    return kiss", "def search(s, n):\n    dp = [1] * n\n    for i in range(1, n):\n        if s[i - 1] == s[i]:\n            dp[i] = dp[i - 1] + 1\n    return dp\n\ndef findspecificpattern(Dict, pattern):\n    p_dp = search(pattern, len(pattern))\n    ans = []\n    for i in Dict:\n        if search(i, len(i)) == p_dp:\n            ans.append(i)\n    return ans", "def findspecificpattern(Dict, pattern):\n    n = len(pattern)\n    dp = [1] * n\n    for i in range(1, n):\n        if pattern[i - 1] == pattern[i]:\n            dp[i] = dp[i - 1] + 1\n    ans = []\n    for i in Dict:\n        p = [1] * len(i)\n        for j in range(1, len(i)):\n            if i[j - 1] == i[j]:\n                p[j] = p[j - 1] + 1\n        if dp == p:\n            ans.append(i)\n    return ans", "def findspecificpattern(Dict, pattern):\n    ans = []\n    for word in Dict:\n        char1ToChar2 = {}\n        char2ToChar1 = {}\n        if len(word) == len(pattern):\n            for (c1, c2) in zip(word, pattern):\n                if c1 in char1ToChar2 and char1ToChar2[c1] != c2:\n                    break\n                if c2 in char2ToChar1 and char2ToChar1[c2] != c1:\n                    break\n                char1ToChar2[c1] = c2\n                char2ToChar1[c2] = c1\n            else:\n                ans.append(word)\n    return ans", "def findspecificpattern(Dict, pattern):\n    ans = []\n    for word in Dict:\n        h = {}\n        flag = 1\n        if len(word) == len(pattern):\n            for (i, j) in zip(pattern, word):\n                if i not in h:\n                    h[i] = j\n                elif h[i] != j:\n                    flag = 0\n                    break\n        else:\n            flag = 0\n        if flag:\n            ans.append(word)\n    return ans", "def findspecificpattern(Dict, pattern):\n    pattern_map = {}\n    for i in range(len(pattern)):\n        if pattern[i] not in pattern_map:\n            pattern_map[pattern[i]] = 1\n        else:\n            pattern_map[pattern[i]] += 1\n    pattern_string = ''\n    values = sorted(pattern_map.values())\n    for things in values:\n        pattern_string += str(things)\n    res = []\n    for words in Dict:\n        dict_map = {}\n        for j in range(len(words)):\n            if words[j] not in dict_map:\n                dict_map[words[j]] = 1\n            else:\n                dict_map[words[j]] += 1\n        dict_string = ''\n        values2 = sorted(dict_map.values())\n        for things2 in values2:\n            dict_string += str(things2)\n        if len(words) == len(pattern) and pattern_string == dict_string:\n            res.append(words)\n    return res", "def findspecificpattern(Dict, pattern):\n    map_pattern = {}\n    for i in range(len(pattern)):\n        if pattern[i] not in map_pattern:\n            map_pattern[pattern[i]] = 1\n        else:\n            map_pattern[pattern[i]] += 1\n    pattern_string = ''\n    values = sorted(map_pattern.values())\n    for things in values:\n        pattern_string += str(things)\n    res = []\n    for element in Dict:\n        dict_map = {}\n        for i in range(len(element)):\n            if element[i] not in dict_map:\n                dict_map[element[i]] = 1\n            else:\n                dict_map[element[i]] += 1\n        dict_string = ''\n        values1 = sorted(dict_map.values())\n        for things2 in values1:\n            dict_string += str(things2)\n        if len(element) == len(pattern) and pattern_string == dict_string:\n            res.append(element)\n    return res", "def get_pattern(s):\n    d = {}\n    c = 0\n    unique = []\n    for i in range(len(s)):\n        if s[i] not in unique:\n            c += 1\n            unique.append(s[i])\n            d[c] = [i]\n        else:\n            d[c].append(i)\n    return d\n\ndef findspecificpattern(Dict, pattern):\n    golden = get_pattern(pattern)\n    ans = []\n    for i in Dict:\n        temp = get_pattern(i)\n        if temp == golden:\n            ans.append(i)\n    return ans", "def findspecificpattern(Dict, pattern):\n    l = len(pattern)\n    arr = [0] * l\n    arr[0] = 1\n    for i in range(1, l):\n        if pattern[i] == pattern[i - 1]:\n            arr[i] = 1 + arr[i - 1]\n        else:\n            arr[i] = 1\n    lst = []\n    for i in range(len(Dict)):\n        if len(Dict[i]) == l:\n            b = [0] * l\n            b[0] = 1\n            for j in range(1, l):\n                if Dict[i][j] == Dict[i][j - 1]:\n                    b[j] = 1 + b[j - 1]\n                else:\n                    b[j] = 1\n            if b == arr:\n                lst.append(Dict[i])\n    lst.sort()\n    return lst", "def check_isomorphic(str1, str2):\n    if len(str1) != len(str2):\n        return False\n    map = {}\n    for i in range(len(str1)):\n        if str1[i] in map:\n            if map[str1[i]] != str2[i]:\n                return False\n        elif str2[i] not in map.values():\n            map[str1[i]] = str2[i]\n        else:\n            return False\n    return True\n\ndef findspecificpattern(Dict, pattern):\n    res = []\n    N = len(Dict)\n    for i in range(N):\n        if check_isomorphic(Dict[i], pattern):\n            res.append(Dict[i])\n    return res", "from collections import Counter\n\ndef findspecificpattern(dic, pattern):\n    n = len(pattern)\n    mp = [0] * n\n    mp[0] = 1\n    for i in range(1, n):\n        if pattern[i] == pattern[i - 1]:\n            mp[i] = 1 + mp[i - 1]\n        else:\n            mp[i] = 1\n    res = []\n    for i in range(len(dic)):\n        if len(dic[i]) == n:\n            k = [0] * n\n            k[0] = 1\n            for j in range(1, n):\n                if dic[i][j] == dic[i][j - 1]:\n                    k[j] = 1 + k[j - 1]\n                else:\n                    k[j] = 1\n            if k == mp:\n                res.append(dic[i])\n    res.sort()\n    return res", "from collections import deque\n\ndef findspecificpattern(d, p):\n\n    def check(p, w):\n        if len(p) != len(w):\n            return False\n        ch = [0 for i in range(128)]\n        for i in range(len(p)):\n            if ch[ord(p[i])] == 0:\n                ch[ord(p[i])] = w[i]\n            elif ch[ord(p[i])] != w[i]:\n                return False\n        return True\n    res = deque()\n    for i in range(len(d)):\n        if check(p, d[i]):\n            res.append(d[i])\n    return res", "def encode(word):\n    hashMap = {}\n    result = ''\n    i = 1\n    for ch in word:\n        if ch not in hashMap:\n            hashMap[ch] = i\n            i = i + 1\n        result += str(hashMap[ch])\n    return result\n\ndef findspecificpattern(Dict, pattern):\n    final = []\n    for word in Dict:\n        if len(word) == len(pattern) and encode(word) == encode(pattern):\n            final.append(word)\n    return final", "def findspecificpattern(Dict, pattern):\n    count1 = 0\n    count2 = 0\n    for i in range(len(pattern) - 1):\n        if pattern[i] != pattern[i + 1]:\n            count1 += 1\n        else:\n            count2 += 1\n    temp = []\n    for i in Dict:\n        count3 = 0\n        count4 = 0\n        for j in range(len(i) - 1):\n            if i[j] != i[j + 1]:\n                count3 += 1\n            else:\n                count4 += 1\n        if count1 == count3 and count2 == count4:\n            temp.append(i)\n    return temp", "from collections import defaultdict\n\ndef findspecificpattern(Dict, pattern):\n    res = []\n    p = len(pattern)\n    for s in Dict:\n        if len(s) != p:\n            continue\n        d = defaultdict(str)\n        flag = True\n        for i in range(p):\n            if s[i] not in d.keys() and pattern[i] not in d.values():\n                d[s[i]] = pattern[i]\n            elif d[s[i]] == pattern[i]:\n                continue\n            else:\n                flag = False\n                break\n        if flag == True:\n            res.append(s)\n    return res", "def encode_helper(word):\n    count = 0\n    helper_map = {}\n    s = ''\n    for character in word:\n        if character not in helper_map:\n            helper_map[character] = count\n            count += 1\n    for character in word:\n        s = s + str(helper_map[character])\n    return s\n\ndef findspecificpattern(Dict, pattern):\n    encoded_pattern = encode_helper(pattern)\n    res = []\n    for i in Dict:\n        if encoded_pattern == encode_helper(i):\n            res.append(i)\n    return res", "def encode(word):\n    count = 0\n    dit = {}\n    s = ''\n    for i in word:\n        if i not in dit:\n            dit[i] = count\n            count += 1\n    for i in word:\n        s = s + str(dit[i])\n    return s\n\ndef findspecificpattern(Dict, pattern):\n    l = []\n    k = encode(pattern)\n    for i in Dict:\n        ans = encode(i)\n        check = True\n        if len(k) == len(ans):\n            for j in range(len(k)):\n                if k[j] != ans[j]:\n                    check = False\n                    break\n            if check:\n                l.append(i)\n    return l", "def findspecificpattern(Dict, pattern):\n\n    def makepattern(word):\n        pr = -1\n        d = {}\n        res = []\n        for c in word:\n            if c in d:\n                ind = d[c]\n            else:\n                d[c] = pr + 1\n                pr += 1\n            res.append(d[c])\n        return res\n    ans = []\n    given_pattern = makepattern(pattern)\n    for word in Dict:\n        if given_pattern == makepattern(word):\n            ans.append(word)\n    return ans"], "starter_code": "def findspecificpattern(Dict, pattern):\n", "input_output": {"fn_name": "findSpecificPattern", "inputs": ["N = 4\ndict[] = {abb,abc,xyz,xyy}\npattern  = foo"], "outputs": ["abb xyy"]}, "difficulty": "EASY", "raw_tags": ["Data Structures", "Strings", "Hash"], "name": null, "source": "geeksforgeeks", "tags": ["String algorithms", "Data structures"], "skill_types": ["Data structures"], "url": "https://practice.geeksforgeeks.org/problems/match-specific-pattern/1", "Expected Auxiliary Space": "O(N).", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N*K) (where K is the length of the pattern).", "entry_point": "findspecificpattern", "task_id": "TACO_lite/18"}
{"gt": "U", "requirement": "Given a singly linked list, delete middle of the linked list. For example, if given linked list is 1->2->3->4->5 then linked list should be modified to 1->2->4->5.\nIf there are even nodes, then there would be two middle nodes, we need to delete the second middle element. For example, if given linked list is 1->2->3->4->5->6 then it should be modified to 1->2->3->5->6.\nIf the input linked list is NULL or has 1 node, then it should return NULL\nExample 1:\nInput:\nLinkedList: 1->2->3->4->5\nOutput: 1 2 4 5\nExample 2:\nInput:\nLinkedList: 2->4->6->7->5->1\nOutput: 2 4 6 5 1\nYour Task:\nThe task is to complete the function deleteMid() which should delete the middle element from the linked list and return the head of the modified linked list. If the linked list is empty then it should return NULL.\nExpected Time Complexity: O(N).\nExpected Auxiliary Space: O(1).\nConstraints:\n1 <= N <= 1000\n1 <= value <= 1000", "solutions": ["def deleteMid(head):\n    temp = head\n    c = 0\n    while temp != None:\n        c += 1\n        temp = temp.next\n    mid = c // 2 - 1\n    i = 0\n    temp = head\n    while i < mid:\n        temp = temp.next\n        i += 1\n    temp.next = temp.next.next\n    return head", "def deleteMid(head):\n    if head.next == None or head == None:\n        return None\n    elif head.next.next == None:\n        head.next = None\n    else:\n        p = head\n        n = 1\n        while p.next != None:\n            n += 1\n            p = p.next\n        m = n // 2\n        n = 1\n        p = head\n        while n != m:\n            n += 1\n            p = p.next\n        p.next = p.next.next\n    return head", "def deleteMid(head):\n    slow = head\n    fast = head\n    prev = None\n    while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n    prev.next = slow.next\n    slow = None\n    return head", "def deleteMid(head):\n    temp = head\n    size = 0\n    while temp != None:\n        size += 1\n        temp = temp.next\n    reach = size // 2\n    i = 0\n    temp = head\n    prev = None\n    while temp != None and i < reach:\n        i += 1\n        prev = temp\n        temp = temp.next\n    prev.next = temp.next\n    return head", "def deleteMid(head):\n    temp = head\n    count = 0\n    while temp != None:\n        count += 1\n        temp = temp.next\n    if count % 2 == 0:\n        i = 1\n        j = count // 2\n        temp = head\n        prev = None\n        while i < j + 1:\n            prev = temp\n            temp = temp.next\n            i += 1\n        prev.next = temp.next\n    else:\n        i = 1\n        j = count // 2\n        prev = None\n        temp = head\n        while i <= j:\n            prev = temp\n            temp = temp.next\n            i += 1\n        prev.next = temp.next\n    return head", "def deleteMid(head):\n    n = 0\n    m = head\n    while m != None:\n        n += 1\n        m = m.next\n    a = head\n    for i in range(int(n / 2) - 1):\n        a = a.next\n    a.next = a.next.next\n    return head", "def deleteMid(head):\n    if not head.next:\n        return\n    slow = head\n    fast = head.next.next\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    slow.next = slow.next.next\n    return head", "def deleteMid(head):\n    if head == None or head.next == None:\n        return None\n    prev = head\n    slow = head\n    fast = head\n    while fast.next != None and fast.next.next != None:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n    if fast.next == None:\n        prev.next = slow.next\n    else:\n        slow.next = slow.next.next\n    return head", "def deleteMid(head):\n    if head == None or head.next == None:\n        return head\n    fast_pointer = head\n    prev_of_slow = None\n    slow_pointer = head\n    while fast_pointer != None and fast_pointer.next != None:\n        prev_of_slow = slow_pointer\n        slow_pointer = slow_pointer.next\n        fast_pointer = fast_pointer.next.next\n    prev_of_slow.next = slow_pointer.next\n    return head", "def deleteMid(head):\n    slow = head\n    fast = head\n    prev = head\n    if fast.next is None:\n        return None\n    while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n    prev.next = slow.next\n    return head", "def deleteMid(head):\n    length = 0\n    dummy = head\n    while dummy:\n        dummy = dummy.next\n        length += 1\n    if not head or length == 1:\n        return None\n    dummy = head\n    k = length // 2\n    while k - 1 > 0:\n        dummy = dummy.next\n        k -= 1\n    x = dummy.next.next\n    dummy.next = x\n    return head", "def deleteMid(head):\n    if head == None:\n        return None\n    if head.next == None:\n        del head\n        return None\n    temp = head\n    cnt = 0\n    while temp:\n        temp = temp.next\n        cnt = cnt + 1\n    mid = cnt // 2\n    temp = head\n    k = 1\n    while temp:\n        if k == mid:\n            temp.next = temp.next.next\n        temp = temp.next\n        k = k + 1\n    return head", "def deleteMid(head):\n    if head is None or head.next is None:\n        return None\n    count = 0\n    fast = head\n    while fast.next is not None:\n        count += 1\n        fast = fast.next\n    fast = head\n    mid = count / 2\n    loc = 0\n    while loc < mid - 1:\n        loc += 1\n        fast = fast.next\n    tempNode = None\n    tempNode = fast.next\n    if tempNode is None:\n        fast.next = None\n    else:\n        fast.next = tempNode.next\n    return head", "def deleteMid(head):\n    new = head\n    i = 1\n    while new.next != None:\n        i = i + 1\n        new = new.next\n    i = i // 2\n    j = 1\n    new = head\n    while j < i:\n        new = new.next\n        j = j + 1\n    new.next = new.next.next\n    return head", "def deleteMid(head):\n    temp = head\n    count = 0\n    while temp:\n        count += 1\n        temp = temp.next\n    temp = head\n    count = count // 2\n    while count:\n        prev = temp\n        temp = temp.next\n        count -= 1\n    prev.next = temp.next\n    return head", "def deleteMid(head):\n    if head == None or head.next == None:\n        return None\n    else:\n        p = head\n        q = head\n        prev = None\n        while q and q.next:\n            prev = p\n            p = p.next\n            q = q.next.next\n        if p != None:\n            prev.next = p.next\n        return head", "def getmidprev(head):\n    prev = None\n    (slow, fast) = (head, head)\n    while fast is not None and fast.next is not None:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n    return prev\n\ndef deleteMid(head):\n    midprev = getmidprev(head)\n    if midprev is None:\n        return None\n    midprev.next = midprev.next.next\n    return head", "def deleteMid(head):\n    cur = head\n    fast = head\n    prev = Node(0)\n    h = prev\n    prev.next = cur\n    while fast and fast.next:\n        cur = cur.next\n        prev = prev.next\n        fast = fast.next.next\n    prev.next = cur.next\n    return h.next", "def deleteMid(head):\n    slow = head\n    fast = head.next.next\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    slow.next = slow.next.next\n    return head", "def deleteMid(head):\n    if head.next is None:\n        return None\n    temp = head\n    len = 0\n    while temp:\n        len += 1\n        temp = temp.next\n    temp = head\n    for i in range(len // 2 - 1):\n        temp = temp.next\n    node2Del = temp.next\n    temp.next = temp.next.next\n    node2Del.next = None\n    return head", "def deleteMid(head):\n    slow = head\n    fast = head.next\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    temp = slow.next\n    slow.next = temp.next\n    del temp\n    return head", "def deleteMid(head):\n    fast = slow = head\n    pre = None\n    while fast and fast.next:\n        pre = slow\n        slow = slow.next\n        fast = fast.next.next\n    pre.next = pre.next.next\n    return head", "def deleteMid(head):\n    if not head or not head.next:\n        return None\n    (ptr1, ptr2) = (head, head.next)\n    while ptr2 and ptr2.next:\n        ptr1 = ptr1.next\n        ptr2 = ptr2.next.next if ptr2.next else ptr2.next\n    ptr1.data = ptr1.data if ptr2 else ptr1.next.data\n    ptr1.next = ptr1.next.next\n    return head", "def deleteMid(head):\n    cur = head\n    count = n = 0\n    while cur:\n        count = count + 1\n        cur = cur.next\n    if count == 0 or count == 1:\n        return NULL\n    if count % 2 == 0:\n        cur = head\n        while n != count / 2 - 1:\n            n = n + 1\n            cur = cur.next\n        temp = cur.next\n        cur.next = cur.next.next\n        del temp\n        return head\n    else:\n        cur = head\n        while n != count // 2 - 1:\n            n = n + 1\n            cur = cur.next\n        temp = cur.next\n        cur.next = cur.next.next\n        del temp\n        return head", "def deleteMid(head):\n    if head is None or head.next is None:\n        return head\n    slow_ptr = head\n    fast_ptr = head.next.next\n    while fast_ptr is not None and fast_ptr.next is not None:\n        slow_ptr = slow_ptr.next\n        fast_ptr = fast_ptr.next.next\n    temp = slow_ptr.next\n    slow_ptr.next = temp.next\n    temp = None\n    return head\n\ndef __init__(data):\n    self.data = data\n    self.next = None", "def deleteMid(head):\n    if head.next == None:\n        return None\n    if head.next.next == None:\n        head.next = head.next.next\n        return head\n    fast = head\n    slow = head\n    while fast.next and fast.next.next:\n        fast = fast.next.next\n        slow = slow.next\n    if fast.next:\n        slow = slow.next\n    slow.data = slow.next.data\n    slow.next = slow.next.next\n    return head", "def deleteMid(head):\n    if head is None or head.next is None:\n        return head\n    curr = head\n    prev = head\n    next = None\n    while curr != None and curr.next != None:\n        curr = curr.next.next\n        next = prev\n        prev = prev.next\n    next.next = prev.next\n    return head", "def deleteMid(head):\n    slow = head\n    fast = head\n    dummy = Node(-1)\n    dummy.next = head\n    prev = dummy\n    while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n    prev.next = slow.next\n    return dummy.next", "def deleteMid(head):\n    l = 0\n    a = head\n    while a != None:\n        l += 1\n        a = a.next\n    mid = l // 2\n    l = 0\n    prev = None\n    cur = head\n    front = head.next\n    while l < mid:\n        l += 1\n        prev = cur\n        cur = front\n        front = front.next\n    prev.next = front\n    return head", "def deleteMid(head):\n    p = head\n    q = head\n    temp = None\n    while p and p.next:\n        temp = q\n        q = q.next\n        p = p.next.next\n    if temp == None:\n        return None\n    temp.next = temp.next.next\n    return head", "def deleteMid(head):\n    c = 0\n    temp = head\n    while temp:\n        c += 1\n        temp = temp.next\n    mid = c // 2\n    temp = head\n    k = 1\n    while temp:\n        if k == mid:\n            temp.next = temp.next.next\n        temp = temp.next\n        k += 1\n    return head", "def deleteMid(head):\n    c = 0\n    curr = head\n    while curr != None:\n        c += 1\n        curr = curr.next\n    curr = head\n    for i in range(c // 2 - 1):\n        curr = curr.next\n    curr.next = curr.next.next\n    return head", "def deleteMid(head):\n    fast = head\n    slow = head\n    while fast != None and fast.next != None:\n        slow = slow.next\n        fast = fast.next.next\n    mid = slow\n    temp = head\n    while temp.next != mid:\n        temp = temp.next\n    val = mid.next\n    temp.next = val\n    mid = None\n    return head", "def deleteMid(head):\n    start = head\n    length = 0\n    while start != None:\n        length += 1\n        start = start.next\n    mid = int(length / 2) + 1\n    start = 1\n    start_node = head\n    while start < mid - 1:\n        start += 1\n        start_node = start_node.next\n    start_node.next = start_node.next.next\n    return head", "def deleteMid(head):\n    n = head\n    i = 0\n    while n is not None:\n        i = i + 1\n        n = n.next\n    x = i // 2\n    if i - x == 1:\n        head.next = None\n    else:\n        n = head\n        for i in range(0, x):\n            n = n.next\n        n.data = n.next.data\n        n.next = n.next.next\n    return head", "def deleteMid(head):\n    slow = fast = head\n    t = None\n    while fast and fast.next:\n        tmp = slow\n        slow = slow.next\n        fast = fast.next.next\n    tmp.next = slow.next\n    return head", "def deleteMid(head):\n    pre = None\n    rabbit = head\n    tortoise = head\n    while rabbit and rabbit.next:\n        pre = tortoise\n        rabbit = rabbit.next.next\n        tortoise = tortoise.next\n    pre.next = tortoise.next\n    return head", "def deleteMid(head):\n    temp = head\n    count = 0\n    while temp:\n        count += 1\n        temp = temp.next\n    temp = head\n    for i in range(count // 2 - 1):\n        temp = temp.next\n    temp.next = temp.next.next\n    return head", "def deleteMid(head):\n    temp = head\n    count = 0\n    while temp != None:\n        count += 1\n        temp = temp.next\n    temp = head\n    count = count // 2\n    while count - 1:\n        temp = temp.next\n        count -= 1\n    temp.next = temp.next.next\n    return head", "def deleteMid(head):\n    if head is None:\n        return head\n    if head.next is None:\n        return None\n    fast = slow = head\n    pre = None\n    while fast and fast.next:\n        fast = fast.next.next\n        pre = slow\n        slow = slow.next\n    if pre is not None:\n        pre.next = slow.next\n    return head", "def deleteMid(head):\n    count = 0\n    temp = head\n    if head == None:\n        return head\n    if head.next == None:\n        return None\n    while temp:\n        count += 1\n        temp = temp.next\n    mid = count // 2\n    st = head\n    while mid > 1:\n        st = st.next\n        mid = mid - 1\n    temp = st.next\n    st.next = st.next.next\n    del temp\n    return head", "def deleteMid(head):\n    slow = head\n    fast = head\n    temp = None\n    while fast != None and fast.next != None:\n        temp = slow\n        slow = slow.next\n        fast = fast.next.next\n    if temp == None:\n        return None\n    temp.next = temp.next.next\n    return head", "def deleteMid(head):\n    if head is None:\n        return None\n    temp = head\n    temp2 = head\n    count = 0\n    while temp is not None:\n        count = count + 1\n        temp = temp.next\n    i = 1\n    while i < count // 2:\n        i = i + 1\n        temp2 = temp2.next\n    temp_next = temp2.next\n    temp2.next = temp_next.next\n    temp_next.next = None\n    return head", "def deleteMid(head):\n    p = head\n    c1 = 0\n    c2 = 0\n    while p:\n        c1 = c1 + 1\n        p = p.next\n    c3 = c1 // 2 + 1\n    if c3 <= 1:\n        return None\n    p = head\n    q = None\n    while p:\n        c2 = c2 + 1\n        if c2 == c3:\n            q.next = p.next\n        q = p\n        p = p.next\n    return head", "def deleteMid(head):\n    temp = head\n    if head == None:\n        return head\n    c = 0\n    while temp != None:\n        c += 1\n        temp = temp.next\n    d = int(c / 2)\n    temp = head\n    for i in range(d - 1):\n        temp = temp.next\n    temp.next = temp.next.next\n    return head", "def deleteMid(head):\n    fast = head\n    slow = head\n    tail = None\n    while fast != None and fast.next != None:\n        tail = slow\n        slow = slow.next\n        fast = fast.next.next\n    tail.next = slow.next\n    del slow\n    return head", "def deleteMid(head):\n    if head == None:\n        return None\n    if head.next == None:\n        del head\n        return None\n    (temp, count) = (head, 0)\n    while temp:\n        temp = temp.next\n        count += 1\n    m = count // 2\n    (temp, k) = (head, 1)\n    while temp:\n        if k == m:\n            temp.next = temp.next.next\n        temp = temp.next\n        k += 1\n    return head", "def deleteMid(head):\n    slow = head\n    fast = head\n    new = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    if fast.next:\n        if fast.next.next == None:\n            slow.next = slow.next.next\n    else:\n        while new.next != slow:\n            new = new.next\n        new.next = new.next.next\n    return head", "def deleteMid(head):\n    slow = head\n    fast = head\n    prev = Node(0)\n    while fast != None and fast.next != None:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n    prev.next = prev.next.next\n    return head", "def deleteMid(head):\n    cur = head\n    ans = []\n    while cur:\n        ans.append(cur.data)\n        cur = cur.next\n    ind = len(ans) // 2\n    ans.pop(ind)\n    l = Node(0)\n    h = l\n    for i in ans:\n        n = Node(i)\n        l.next = n\n        l = l.next\n    return h.next", "def deleteMid(head):\n    temp = head\n    r = head\n    count = 0\n    while temp is not None:\n        temp = temp.next\n        count += 1\n    for i in range(count // 2 - 1):\n        head = head.next\n    head.next = head.next.next\n    return r", "def deleteMid(head):\n    c = a = b = head\n    b = b.next.next\n    while b and b.next:\n        a = a.next\n        b = b.next.next\n    a.next = a.next.next\n    return c", "def deleteMid(head):\n    i = 0\n    t = head\n    while t:\n        t = t.next\n        i += 1\n    t1 = head\n    for j in range(i):\n        if j == i // 2 - 1:\n            t1.next = t1.next.next\n            break\n        t1 = t1.next\n    return head", "def deleteMid(head):\n    slow = head\n    fast = head\n    ptr = None\n    if head == None:\n        return None\n    while fast and fast.next:\n        ptr = slow\n        slow = slow.next\n        fast = fast.next.next\n    ptr.next = slow.next\n    slow.next = None\n    return head", "def deleteMid(head):\n    count = 0\n    curr = head\n    while curr is not None:\n        count += 1\n        curr = curr.next\n    if count <= 1:\n        return None\n    nodeToDel = count // 2 + 1\n    cnt = 0\n    curr = head\n    while cnt < nodeToDel - 2:\n        cnt += 1\n        curr = curr.next\n    curr.next = curr.next.next\n    return head", "def deleteMid(head):\n    lst = []\n    while head:\n        lst.append(head.data)\n        head = head.next\n    del lst[len(lst) // 2]\n    a = Node(0)\n    temp = a\n    for i in lst:\n        temp.next = Node(i)\n        temp = temp.next\n    return a.next", "def deleteMid(head):\n    if head == None or head.next == None:\n        return None\n    temp = head\n    length = 0\n    while temp != None:\n        length += 1\n        temp = temp.next\n    length = length // 2\n    i = 0\n    temp = head\n    prev = None\n    while i < length:\n        prev = temp\n        temp = temp.next\n        i += 1\n    prev.next = temp.next\n    temp.next = None\n    return head", "def deleteMid(head):\n    c = length(head)\n    mid = c // 2\n    itr = head\n    i = 0\n    while itr:\n        if mid - 1 == i:\n            itr.next = itr.next.next\n        i += 1\n        itr = itr.next\n    return head\n\ndef length(head):\n    c = 0\n    itr = head\n    while itr:\n        c += 1\n        itr = itr.next\n    return c", "def deleteMid(head):\n    if head == None:\n        return None\n    if head.next == None:\n        del head\n        return None\n    c = 0\n    t = head\n    while t:\n        c += 1\n        t = t.next\n    mid = c // 2\n    t = head\n    k = 1\n    while t:\n        if k == mid:\n            t.next = t.next.next\n        t = t.next\n        k += 1\n    return head", "def deleteMid(head):\n    fast = slow = head\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    curr = head\n    while curr.next != slow:\n        curr = curr.next\n    if slow.next is None:\n        curr.next = None\n    else:\n        curr.next = slow.next\n    return head", "import math\n\ndef deleteMid(head):\n    count = 1\n    temp = head\n    while temp.next:\n        count += 1\n        temp = temp.next\n    n = math.floor(count / 2)\n    temp1 = head\n    i = 0\n    while i < n - 1:\n        temp1 = temp1.next\n        i += 1\n    temp1.next = temp1.next.next\n    return head", "def deleteMid(head):\n    if head is None:\n        return head\n    if head.next is None:\n        return Null\n    temp = head\n    c = 0\n    while temp:\n        c += 1\n        temp = temp.next\n    b = c // 2\n    temp = head\n    i = 1\n    while temp:\n        if i == b:\n            temp.next = temp.next.next\n        temp = temp.next\n        i += 1\n    return head", "def deleteMid(head):\n    stack = [head]\n    count = 0\n    while len(stack) > 0:\n        current = stack.pop()\n        count += 1\n        if current.next:\n            stack.append(current.next)\n    if count > 1:\n        stack.append(head)\n        for i in range(count // 2 - 1):\n            current = stack.pop()\n            stack.append(current.next)\n        current = stack.pop()\n        current.next = current.next.next\n        return head\n    else:\n        return None", "def deleteMid(head):\n    temp = head\n    length = 1\n    while temp.next:\n        temp = temp.next\n        length += 1\n    mid = length // 2\n    temp = head\n    k = 1\n    while temp:\n        if k == mid:\n            temp.next = temp.next.next\n        temp = temp.next\n        k += 1\n    return head", "def deleteMid(head):\n    ans = Node(123)\n    p = ans\n    p.next = head\n    s = head\n    f = head.next\n    while f and f.next:\n        f = f.next.next\n        s = s.next\n        p = p.next\n    if f:\n        s.next = s.next.next\n        return ans.next\n    elif not f:\n        p.next = p.next.next\n        return ans.next", "def deleteMid(head):\n    dummy = Node(0)\n    dummy.next = head\n    (slow, fast) = (dummy, head)\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    slow.next = slow.next.next\n    return dummy.next", "def deleteMid(head):\n    slow = head\n    fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    mid = slow\n    temp = head\n    while temp.next != mid:\n        temp = temp.next\n    temp.next = mid.next\n    return head"], "starter_code": "def __init__(data):\n", "input_output": {"inputs": ["LinkedList:1->2->3->4->5", "LinkedList:2->4->6->7->5->1"], "outputs": ["1 2 4 5", "2 4 6 5 1"]}, "difficulty": "EASY", "raw_tags": ["Data Structures", "Algorithms", "two-pointer-algorithm", "Linked List"], "name": null, "source": "geeksforgeeks", "tags": ["Data structures", "Amortized analysis"], "skill_types": ["Amortized analysis", "Data structures"], "url": "https://practice.geeksforgeeks.org/problems/delete-middle-of-linked-list/1", "Expected Auxiliary Space": "O(1).", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N).", "entry_point": "__init__", "task_id": "TACO_lite/19"}
{"gt": "U", "requirement": "Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n\nExample:\n\n\nInput: \n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\nOutput: 4", "solutions": ["def maximalsquare(matrix):\n    if not matrix:\n        return 0\n    (m, n) = (len(matrix), len(matrix[0]))\n    dp = [int(matrix[i][0]) for i in range(m)]\n    vmax = max(dp)\n    pre = 0\n    for j in range(1, n):\n        (pre, dp[0]) = (int(matrix[0][j - 1]), int(matrix[0][j]))\n        for i in range(1, m):\n            cur = dp[i]\n            dp[i] = 0 if matrix[i][j] == '0' else min(dp[i - 1], dp[i], pre) + 1\n            pre = cur\n        vmax = max(vmax, max(dp))\n    return vmax ** 2", "def maximalsquare(matrix):\n    if len(matrix) == 0 or len(matrix[0]) == 0:\n        return 0\n    (n, m) = (len(matrix), len(matrix[0]))\n    dp = [[0 for i in range(m)] for j in range(n)]\n    for i in range(n):\n        dp[i][0] = int(matrix[i][0])\n    for j in range(m):\n        dp[0][j] = int(matrix[0][j])\n    for i in range(1, n):\n        for j in range(1, m):\n            if matrix[i][j] == '1':\n                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n    ans = 0\n    for i in range(n):\n        ans = max(ans, max(dp[i]))\n    return ans ** 2", "def maximalsquare(matrix):\n    if not matrix:\n        return 0\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    dp = list(map(int, matrix[0][:]))\n    maxLen = 1 if sum(dp) > 0 else 0\n    for i in range(1, rows):\n        tmp = dp[0]\n        dp[0] = int(matrix[i][0])\n        maxLen = max(maxLen, dp[0])\n        pre = tmp\n        for j in range(1, cols):\n            tmp = dp[j]\n            if matrix[i][j] == '1':\n                dp[j] = min(dp[j], dp[j - 1], pre) + 1\n                maxLen = max(maxLen, dp[j])\n            else:\n                dp[j] = 0\n            pre = tmp\n    return maxLen * maxLen", "def maximalsquare(matrix):\n    if not matrix:\n        return 0\n    (rows, cols) = (len(matrix), len(matrix[0]))\n    dp = [0] * cols\n    maxLen = 1 if sum(dp) > 0 else 0\n    for i in range(0, rows):\n        for j in range(0, cols):\n            if matrix[i][j] == '1':\n                if j == 0:\n                    dp[j] = int(matrix[i][j])\n                else:\n                    k = min(dp[j], dp[j - 1])\n                    dp[j] = k + 1 if matrix[i - k][j - k] == '1' else k\n                maxLen = max(maxLen, dp[j])\n            else:\n                dp[j] = 0\n    return maxLen * maxLen", "def maximalsquare(matrix):\n    if not matrix or len(matrix) == 0:\n        return 0\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0 for i in range(n)] for j in range(m)]\n    dp[0] = list(map(lambda x: int(x), matrix[0]))\n    maxLength = 1 if 1 in dp[0] else 0\n    for i in range(1, m):\n        dp[i][0] = int(matrix[i][0])\n        if dp[i][0] == 1:\n            maxLength = 1\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == '0':\n                dp[i][j] = 0\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n                maxLength = max(maxLength, dp[i][j])\n    return maxLength ** 2", "def maximalsquare(matrix):\n    (m, n) = (len(matrix), len(matrix[0]) if matrix else 0)\n    dp = [0] * n\n    best = 0\n    for r in range(m):\n        ndp = [0] * n\n        for c in range(n):\n            if matrix[r][c] == '1':\n                ndp[c] = min(dp[c - 1], dp[c], ndp[c - 1]) + 1 if r and c else 1\n                if ndp[c] > best:\n                    best = ndp[c]\n        dp = ndp\n    return best ** 2", "def maximalsquare(matrix):\n    g = 0\n    li = [[0 for a in x] for x in matrix]\n    for i in range(0, len(matrix)):\n        for j in range(0, len(matrix[0])):\n            c = int(matrix[i][j])\n            if c == 0:\n                li[i][j] = 0\n                continue\n            if i == 0 or j == 0:\n                li[i][j] = c\n                if c > g:\n                    g = c\n                continue\n            m = min(li[i - 1][j], li[i][j - 1])\n            if li[i - 1][j - 1] <= m:\n                li[i][j] = 1 + li[i - 1][j - 1]\n            else:\n                li[i][j] = 1 + m\n            if li[i][j] > g:\n                g = li[i][j]\n    return g ** 2", "def maximalsquare(matrix):\n    if len(matrix) == 0 or len(matrix[0]) == 0:\n        return 0\n    dp = [[0 for i in range(len(matrix[0]))] for i in range(len(matrix))]\n    largest = 0\n    for i in range(len(matrix)):\n        dp[i][0] = int(matrix[i][0])\n        largest = max(largest, dp[i][0])\n    for j in range(len(matrix[0])):\n        dp[0][j] = int(matrix[0][j])\n        largest = max(largest, dp[0][j])\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            if matrix[i][j] == '1':\n                if dp[i - 1][j] >= dp[i - 1][j - 1] and dp[i][j - 1] >= dp[i - 1][j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = min(int(dp[i - 1][j]), int(dp[i][j - 1])) + 1\n            else:\n                dp[i][j] = 0\n            largest = max(largest, dp[i][j])\n    return largest * largest"], "starter_code": "def maximalsquare(matrix: List[List[str]]) -> int:\n", "input_output": {"inputs": [], "outputs": []}, "difficulty": "MEDIUM_HARD", "raw_tags": ["Array", "Dynamic Programming", "Matrix"], "name": null, "source": "leetcode", "tags": ["Matrices", "Dynamic programming", "Data structures"], "skill_types": ["Dynamic programming", "Data structures"], "url": "https://leetcode.com/problems/maximal-square/", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "maximalsquare", "task_id": "TACO_lite/20"}
{"gt": "U", "requirement": "Given an unsorted array Arr of size N of positive integers. One number 'A' from set {1, 2,....,N} is missing and one number 'B' occurs twice in array. Find these two numbers.\nExample 1:\nInput:\nN = 2\nArr[] = {2, 2}\nOutput: 2 1\nExplanation: Repeating number is 2 and \nsmallest positive missing number is 1.\nExample 2:\nInput:\nN = 3\nArr[] = {1, 3, 3}\nOutput: 3 2\nExplanation: Repeating number is 3 and \nsmallest positive missing number is 2.\nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function findTwoElement() which takes the array of integers arr and n as parameters and returns an array of integers of size 2 denoting the answer ( The first index contains B and second index contains A.)\nExpected Time Complexity: O(N)\nExpected Auxiliary Space: O(1)\nConstraints:\n2 ≤ N ≤ 10^{5}\n1 ≤ Arr[i] ≤ N", "solutions": ["def findtwoelement(arr, n):\n    unordered_map = {}\n    rep = 0\n    miss = 0\n    for i in arr:\n        if i not in unordered_map:\n            unordered_map[i] = 1\n        else:\n            rep = i\n    for i in range(1, n + 1):\n        if i not in unordered_map:\n            miss = i\n            return [rep, miss]", "def findtwoelement(arr, n):\n    sei = [False] * n\n    for i in arr:\n        if sei[i - 1]:\n            repeated = i\n        else:\n            sei[i - 1] = True\n    for i in range(n):\n        if not sei[i]:\n            return [repeated, i + 1]", "def findtwoelement(arr, n):\n    d = {}\n    b = 0\n    for i in arr:\n        try:\n            d[i] += 1\n            r = i\n        except:\n            d[i] = 1\n    f = False\n    for i in range(1, max(arr)):\n        if i not in d:\n            l = i\n            f = True\n            break\n    if f == False:\n        return (r, max(arr) + 1)\n    return (r, l)", "def findtwoelement(arr, n):\n    a = list(range(1, len(arr) + 1))\n    res = sum(a)\n    tot = sum(arr)\n    arr = set(arr)\n    sum_arr = sum(arr)\n    missing = res - sum_arr\n    repeated = tot - sum_arr\n    return (repeated, missing)", "def findtwoelement(arr, n):\n    l = []\n    s1 = sum(arr)\n    k = set(arr)\n    k = list(k)\n    s2 = sum(k)\n    l.append(s1 - s2)\n    s3 = n * (n + 1) // 2\n    l.append(s3 - s2)\n    return l", "from collections import Counter\n\ndef findtwoelement(arr, n):\n    a = set(range(1, n + 1))\n    missing = list(a - set(arr))[0]\n    dic = {}\n    for i in arr:\n        if i not in dic:\n            dic[i] = 1\n        else:\n            dic[i] += 1\n        if dic[i] > 1:\n            return [i, missing]", "def findtwoelement(arr, n):\n    m = max(arr)\n    b = [i for i in range(1, n + 1)]\n    s = list(set(b) - set(arr))\n    dic = {}\n    for i in arr:\n        if i in dic:\n            s.insert(0, i)\n            return s\n        else:\n            dic[i] = 1", "def findtwoelement(arr, n):\n    A = set(range(1, n + 1))\n    missing = list(A - set(arr))[0]\n    dic = {}\n    for i in arr:\n        if i not in dic:\n            dic[i] = 0\n        dic[i] += 1\n        if dic[i] >= 2:\n            return [i, missing]", "def findtwoelement(arr, n):\n    (a, b) = (0, 0)\n    for i in range(n):\n        if arr[abs(arr[i]) - 1] < 0:\n            a = abs(arr[i])\n        else:\n            arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1]\n    for i in range(n):\n        if arr[i] > 0:\n            b = i + 1\n            break\n    return (a, b)", "def findtwoelement(arr, n):\n    arr.sort()\n    missing = None\n    r = None\n    for i in range(n - 1):\n        if arr[i] == arr[i + 1]:\n            r = arr[i]\n            arr.remove(r)\n            break\n    for i in range(1, n):\n        if i != arr[i - 1]:\n            missing = i\n            break\n    if not missing:\n        missing = arr[n - 2] + 1\n    return [r, missing]", "def findtwoelement(arr, n):\n    temp = [0] * (n + 1)\n    ans = []\n    for i in range(n):\n        temp[arr[i]] += 1\n    for i in range(1, n + 1):\n        if temp[i] > 1:\n            ans.insert(0, i)\n        if temp[i] == 0:\n            ans.insert(1, i)\n    return ans", "def findtwoelement(arr, size):\n    for i in arr:\n        if arr[abs(i) - 1] > 0:\n            arr[abs(i) - 1] = -arr[abs(i) - 1]\n        else:\n            rep = abs(i)\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            nonRep = i + 1\n    return (rep, nonRep)", "def findtwoelement(arr, n):\n    dict = {}\n    for i in arr:\n        if i not in dict:\n            dict[i] = 1\n        else:\n            a = i\n            dict[i] += 1\n            break\n    s = sum(arr) - a\n    s1 = n * (n + 1) // 2 - s\n    return [a, s1]", "def findtwoelement(arr, n):\n    total_sum = n * (n + 1) // 2\n    s1 = sum(set(arr))\n    s2 = sum(arr)\n    s = s2 - s1\n    k = total_sum - s1\n    return (s, k)", "def findtwoelement(arr, n):\n    missing = -1\n    repeat = -1\n    mp = [0] * (n + 1)\n    for i in range(n):\n        mp[arr[i]] += 1\n    for i in range(n + 1):\n        if mp[i] == 2:\n            repeat = i\n        elif mp[i] == 0:\n            missing = i\n    return [repeat, missing]", "def findtwoelement(arr, n):\n    repeat = -1\n    missing = -1\n    for i in range(n):\n        if arr[abs(arr[i]) - 1] > 0:\n            arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1]\n        else:\n            repeat = abs(arr[i])\n    for i in range(n):\n        if arr[i] > 0:\n            missing = i + 1\n    return [repeat, missing]", "def findtwoelement(arr, n):\n    val_hash = {}\n    answer = []\n    actual_sum = int(n * (n + 1) / 2)\n    sum = 0\n    for val in arr:\n        if val_hash.get(val, 0) != 1:\n            sum += val\n            val_hash[val] = 1\n        else:\n            answer.append(val)\n    answer.append(actual_sum - sum)\n    return answer", "def findtwoelement(arr, n):\n    t = n * (n + 1) // 2\n    s1 = sum(set(arr))\n    s2 = sum(arr)\n    k = s2 - s1\n    p = t - s1\n    return (k, p)", "def findtwoelement(arr, n):\n\n    def repeatNumber(arr):\n        mp = {}\n        for element in arr:\n            if element not in mp:\n                mp[element] = element\n            else:\n                return element\n    sm = sum(arr)\n    oneToN = [i for i in range(1, n + 1)]\n    smOneToN = sum(oneToN)\n    eq = sm - smOneToN\n    rptNumber = repeatNumber(arr)\n    msgNumber = rptNumber - eq\n    return [rptNumber, msgNumber]", "def findtwoelement(arr, n):\n    s = n * (n + 1) // 2\n    s2 = n * (n + 1) * (2 * n + 1) // 6\n    asum = 0\n    a2sum = 0\n    for ele in arr:\n        asum += ele\n        a2sum += ele * ele\n    val1 = asum - s\n    val2 = a2sum - s2\n    val2 = val2 // val1\n    x = (val1 + val2) // 2\n    y = x - val1\n    return [x, y]", "def findtwoelement(arr, n):\n    ans = [0] * 2\n    for i in range(n):\n        if arr[abs(arr[i]) - 1] > 0:\n            arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1]\n        else:\n            ans[0] = abs(arr[i])\n    for i in range(n):\n        if arr[i] > 0:\n            ans[1] = i + 1\n    return ans", "def findtwoelement(arr, n):\n    for i in range(n):\n        arr[arr[i] % n - 1] += n\n    missing = -1\n    repated = -1\n    for i in range(n):\n        if arr[i] <= n:\n            missing = i + 1\n        if arr[i] > 2 * n:\n            repated = i + 1\n    return [repated, missing]", "def findtwoelement(arr, n):\n    missing = 0\n    dup = 0\n    local_dict = dict.fromkeys(arr, 0)\n    for item in arr:\n        local_dict[item] += 1\n    for number in range(1, n + 1):\n        if not local_dict.get(number):\n            missing = number\n        elif local_dict[number] == 2:\n            dup = number\n    return [dup, missing]", "from collections import Counter\n\ndef findtwoelement(arr, n):\n    A = Counter(arr)\n    B = 0\n    for (i, j) in A.items():\n        if j > 1:\n            B = i\n    A = sum(arr) - B\n    total = n * (n + 1) // 2\n    A = total - A\n    return (B, A)", "def findtwoelement(arr, n):\n    sumn = n * (n + 1) / 2\n    sumsn = n * (n + 1) * (2 * n + 1) / 6\n    sumi = sum(arr)\n    sums = 0\n    for i in range(n):\n        sums += arr[i] * arr[i]\n    val1 = sumi - sumn\n    val2 = sums - sumsn\n    val2 = val2 / val1\n    x = (val1 + val2) / 2\n    y = x - val1\n    return (int(x), int(y))", "def findtwoelement(arr, n):\n    h = [0] * (n + 1)\n    for i in range(n):\n        h[arr[i]] += 1\n    mi = -1\n    twi = -1\n    for i in range(1, n + 1):\n        if h[i] == 2:\n            twi = i\n        elif h[i] == 0:\n            mi = i\n        if mi != -1 and twi != -1:\n            break\n    return (twi, mi)", "def findtwoelement(arr, n):\n    from collections import defaultdict\n    ans = []\n    m = defaultdict(int)\n    for i in range(1, n + 1):\n        m[i] = 0\n    for i in arr:\n        m[i] += 1\n    for (k, v) in m.items():\n        if v == 2:\n            ans.append(k)\n    for (k, v) in m.items():\n        if v == 0:\n            ans.append(k)\n    return ans", "import math\n\ndef findtwoelement(arr, n):\n    sumArr = sum(arr)\n    repeatingEle = 0\n    for i in range(n):\n        ele = abs(arr[i])\n        if arr[ele - 1] > 0:\n            arr[ele - 1] = -1 * arr[ele - 1]\n        else:\n            repeatingEle = ele\n            break\n    sumN = n * (n + 1) // 2\n    missingEle = sumN - sumArr + repeatingEle\n    return (repeatingEle, missingEle)", "def findtwoelement(arr, n):\n    A = set(range(1, n + 1))\n    mis = list(A - set(arr))[0]\n    dic = {}\n    for i in arr:\n        if i not in dic:\n            dic[i] = 0\n        dic[i] += 1\n    for (key, val) in dic.items():\n        if val == 2:\n            return [key, mis]", "def findtwoelement(arr, n):\n    s = n * (n + 1) // 2\n    p = n * (n + 1) * (2 * n + 1) // 6\n    missing = 0\n    repeating = 0\n    ans = []\n    for i in arr:\n        s -= i\n        p -= i * i\n    missing = (s + p // s) // 2\n    repeating = missing - s\n    ans.append(repeating)\n    ans.append(missing)\n    return ans", "def findtwoelement(arr, n):\n    x = []\n    arr.sort()\n    c = arr[0]\n    for i in range(1, n):\n        c += arr[i]\n        if arr[i] == arr[i - 1]:\n            x.append(arr[i])\n    c = c - x[0]\n    sum = n * (n + 1) // 2\n    x.append(sum - c)\n    return x", "def findtwoelement(arr, n):\n    arr_set = set()\n    repeated_num = 0\n    missing_num = 0\n    for num in arr:\n        if num not in arr_set:\n            arr_set.add(num)\n        else:\n            repeated_num = num\n    for i in range(1, n + 1):\n        if i not in arr_set:\n            missing_num = i\n            break\n    result = (repeated_num, missing_num)\n    return result", "def findtwoelement(arr, n):\n    ans = [0, 0]\n    l = [i for i in range(1, n + 1)]\n    ans[1] = sum(l) - sum(set(arr))\n    ans[0] = sum(arr) + ans[1] - sum(l)\n    return ans", "def findtwoelement(arr, n):\n    (missing, repeating) = (None, None)\n    for i in range(len(arr)):\n        if arr[abs(arr[i]) - 1] < 0:\n            repeating = abs(arr[i])\n        else:\n            arr[abs(arr[i]) - 1] *= -1\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            missing = i + 1\n    return [repeating, missing]", "def findtwoelement(arr, n):\n    counter = {}\n    for num in arr:\n        if num in counter:\n            a = num\n        else:\n            counter[num] = 1\n    b = [0] * n\n    for num in arr:\n        b[num - 1] = 1\n    x = []\n    for i in range(n):\n        if b[i] == 0:\n            x.append(i + 1)\n    x.append(a)\n    return (a, x[0])", "def findtwoelement(arr, n):\n    freq = [0] * (n + 1)\n    missing_num = 0\n    repeated_num = 0\n    for i in range(n):\n        freq[arr[i]] += 1\n    for i in range(1, n + 1):\n        if freq[i] == 0:\n            missing_num = i\n        elif freq[i] == 2:\n            repeated_num = i\n    return (repeated_num, missing_num)", "def findtwoelement(arr, n):\n    freq = [0] * n\n    for i in range(n):\n        freq[arr[i] - 1] += 1\n    return (freq.index(2) + 1, freq.index(0) + 1)", "def findtwoelement(arr, n):\n    ans = [0] * n\n    r = [-1, -1]\n    for i in range(len(arr)):\n        ans[arr[i] - 1] += 1\n    for i in range(len(ans)):\n        if ans[i] == 0:\n            r[1] = i + 1\n        if ans[i] == 2:\n            r[0] = i + 1\n    return r", "def findtwoelement(arr, n):\n    SN = n * (n + 1) // 2\n    S2N = n * (n + 1) * (2 * n + 1) // 6\n    (missingNum, repeatingNum) = (0, 0)\n    for i in range(n):\n        SN -= arr[i]\n        S2N -= arr[i] * arr[i]\n    missingNum = (SN + S2N // SN) // 2\n    repeatingNum = missingNum - SN\n    ans = []\n    ans.append(repeatingNum)\n    ans.append(missingNum)\n    return ans", "def findtwoelement(arr, n):\n    n = len(arr)\n    seen = set()\n    repeating_num = missing_num = None\n    for num in arr:\n        if num in seen:\n            repeating_num = num\n        seen.add(num)\n    for i in range(1, n + 1):\n        if i not in seen:\n            missing_num = i\n            break\n    return (repeating_num, missing_num)", "def findtwoelement(arr, n):\n    l = [0 for i in range(len(arr))]\n    for i in arr:\n        l[i - 1] += 1\n    return [l.index(2) + 1, l.index(0) + 1]", "from collections import *\n\ndef findtwoelement(arr, n):\n    A = set(range(1, n + 1))\n    B = set(arr)\n    missing = list(A - B)[0]\n    dic = Counter(arr)\n    twice = 0\n    for (key, val) in dic.items():\n        if val == 2:\n            twice = key\n            break\n    return [twice, missing]", "def findtwoelement(a, n):\n    n = len(a)\n    SN = n * (n + 1) // 2\n    S2N = n * (n + 1) * (2 * n + 1) // 6\n    (S, S2) = (0, 0)\n    for i in range(n):\n        S += a[i]\n        S2 += a[i] * a[i]\n    val1 = S - SN\n    val2 = S2 - S2N\n    val2 = val2 // val1\n    x = (val1 + val2) // 2\n    y = x - val1\n    return [x, y]", "def findtwoelement(arr, n):\n    d = {}\n    ans = []\n    for i in arr:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n            ans.append(i)\n    k = range(1, n + 1)\n    k = set(k).difference(set(arr))\n    for i in k:\n        ans.append(i)\n    return ans", "def findtwoelement(A, n):\n    (x, y) = (None, None)\n    n = len(A)\n    a = n * (n + 1) // 2\n    a_dashed = sum(A)\n    b = n * (n + 1) * (2 * n + 1) // 6\n    b_dashed = 0\n    for i in A:\n        b_dashed += i * i\n    rel1 = a - a_dashed\n    rel2 = b - b_dashed\n    rel3 = rel2 // rel1\n    y = (rel3 + rel1) // 2\n    x = y - rel1\n    return [x, y]", "def findtwoelement(arr, n):\n    sumofn = n * (n + 1) // 2\n    sumsetarr = sum(set(arr))\n    sumarr = sum(arr)\n    missingnumber = sumofn - sumsetarr\n    repeatednumber = sumarr - sumsetarr\n    return [repeatednumber, missingnumber]", "def get_duplicate(arr, n):\n    for i in range(n):\n        idx = abs(arr[i]) - 1\n        if arr[idx] < 0:\n            return idx + 1\n        arr[idx] = -arr[idx]\n    return -1\n\ndef get_missing(arr, n):\n    for i in range(n):\n        idx = abs(arr[i]) - 1\n        if arr[idx] > 0:\n            arr[idx] = -arr[idx]\n    for i in range(n):\n        if arr[i] > 0:\n            return i + 1\n\ndef findtwoelement(arr, n):\n    duplicate = self.get_duplicate(arr, n)\n    missing = self.get_missing(arr, n)\n    return (duplicate, missing)", "def findtwoelement(arr, n):\n    v = n * (n + 1) // 2\n    g = sum(arr)\n    j = set(arr)\n    rep_element = g - sum(j)\n    missing_element = v - sum(j)\n    return (rep_element, missing_element)", "def findtwoelement(arr, n):\n    (d, l, repeated_elem) = ({}, list(range(1, n + 1)), -1)\n    for elem in arr:\n        d.update({elem: d.get(elem, 0) + 1})\n        if d[elem] == 2:\n            repeated_elem = elem\n    if repeated_elem == -1:\n        return [0, 0]\n    for elem in l:\n        if elem not in d:\n            return [repeated_elem, elem]", "def findtwoelement(arr, n):\n    repeatingElement = 0\n    missingElement = 0\n    for i in range(len(arr)):\n        if arr[abs(arr[i]) - 1] > 0:\n            arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1]\n        else:\n            repeatingElement = abs(arr[i])\n    incrCount = 0\n    decrCount = 0\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            missingElement = i + 1\n    return [repeatingElement, missingElement]", "def findtwoelement(arr, n):\n    xor = 0\n    for i in range(n):\n        xor = xor ^ arr[i]\n        xor = xor ^ i + 1\n    while xor & xor - 1 != 0:\n        xor = xor & xor - 1\n    a = 0\n    b = 0\n    for i in range(n):\n        if arr[i] & xor:\n            a = a ^ arr[i]\n        else:\n            b = b ^ arr[i]\n        if i + 1 & xor:\n            a = a ^ i + 1\n        else:\n            b = b ^ i + 1\n    if a in arr:\n        return [a, b]\n    return [b, a]", "from collections import Counter\n\ndef findtwoelement(arr, n):\n    A = Counter(arr)\n    (re, mi) = (-1, -1)\n    for i in range(1, n + 1):\n        if A[i] == 1:\n            pass\n        elif A[i] == 2:\n            re = i\n        else:\n            mi = i\n    return [re, mi]", "def findtwoelement(arr, n):\n    arr.sort()\n    repeat = 0\n    for i in range(n - 1):\n        if arr[i] == arr[i + 1]:\n            repeat = arr[i]\n    arr2 = set([i for i in range(1, n + 1)])\n    arr = set(arr)\n    missing = arr2.difference(arr)\n    miss = 0\n    for i in missing:\n        miss = i\n    return (repeat, miss)", "def findtwoelement(arr, n):\n    obj = {}\n    lst = [0 for x in range(0, n + 2)]\n    repeating_num = None\n    missing_num = None\n    for i in arr:\n        if repeating_num is None:\n            try:\n                obj[i] = obj[i] + i\n                repeating_num = i\n            except:\n                obj[i] = i\n        try:\n            lst[i] = i\n        except:\n            pass\n    missing_num = lst[1:].index(0) + 1\n    return (repeating_num, missing_num)", "def findtwoelement(arr, n):\n    s_arr = sum(arr)\n    s_arr_ele_sq = sum([ele ** 2 for ele in arr])\n    s_n_natural_no = n * (n + 1) // 2\n    s_sq_n_natural_no = n * (n + 1) * (2 * n + 1) // 6\n    x_minus_y = s_n_natural_no - s_arr\n    x_sq_minus_y_sq = s_sq_n_natural_no - s_arr_ele_sq\n    x_plus_y = x_sq_minus_y_sq // x_minus_y\n    x = (x_plus_y + x_minus_y) // 2\n    y = (x_plus_y - x_minus_y) // 2\n    return [y, x]", "def findtwoelement(arr, n):\n    map = {}\n    for i in range(n):\n        if arr[i] not in map:\n            map[arr[i]] = True\n        else:\n            x = arr[i]\n    for i in range(1, n + 1):\n        if i not in map:\n            l = i\n    return [x, l]", "def findtwoelement(arr, n):\n    a = {}\n    c = 0\n    d = 0\n    for i in arr:\n        if i in a:\n            a[i] += 1\n        else:\n            a[i] = 1\n    count = 1\n    while count < len(arr) + 1:\n        if count in a:\n            if a[count] == 2:\n                c = count\n        if count not in a:\n            d = count\n        count += 1\n    return (c, d)", "def findtwoelement(arr, n):\n    result = []\n    dict = {}\n    for i in arr:\n        if i in dict:\n            result.append(i)\n        else:\n            dict[i] = 1\n    res = n * (n + 1) // 2 - sum(set(arr))\n    result.append(res)\n    return result", "def findtwoelement(arr, n):\n    a = [0] * (n + 1)\n    res = 0\n    mis = 0\n    for idx in range(n):\n        a[arr[idx]] += 1\n    for idx in range(1, len(a)):\n        if a[idx] == 0:\n            mis = idx\n        if a[idx] > 1:\n            res = idx\n    return (res, mis)", "def findtwoelement(nums, n):\n    for i in range(len(nums)):\n        while nums[i] > 0 and nums[i] <= n and (nums[nums[i] - 1] != nums[i]):\n            (nums[nums[i] - 1], nums[i]) = (nums[i], nums[nums[i] - 1])\n    for i in range(n):\n        if arr[i] != i + 1:\n            return [arr[i], i + 1]", "def findtwoelement(arr, n):\n    l = []\n    a = [0] * n\n    for i in arr:\n        if a[i - 1] > 0:\n            l.append(i)\n        a[i - 1] += 1\n    for i in range(n):\n        if a[i] == 0:\n            l.append(i + 1)\n    return l", "def findtwoelement(arr, n):\n    sum1 = sum(arr)\n    sum2 = n * (n + 1) // 2\n    z1 = sum1 - sum2\n    sum3 = 0\n    for i in arr:\n        sum3 += i * i\n    sum4 = 0\n    for j in range(1, n + 1):\n        sum4 = sum4 + j * j\n    z2 = (sum3 - sum4) // z1\n    r = (z1 + z2) // 2\n    m = r - z1\n    return [r, m]", "def findtwoelement(arr, n):\n    arr.sort()\n    l = [0, 0]\n    miss = 1\n    for i in range(0, len(arr)):\n        if arr[i] == miss:\n            miss += 1\n    l[1] = miss\n    for i in range(1, n):\n        if arr[i - 1] == arr[i]:\n            l[0] = arr[i]\n            break\n    return l", "def findtwoelement(arr, n):\n    RmM = sum(arr) - n * (n + 1) // 2\n    R2mM2 = sum([x * x for x in arr]) - n * (n + 1) * (2 * n + 1) // 6\n    RpM = R2mM2 // RmM\n    return [(RpM + RmM) // 2, (RpM - RmM) // 2]", "def findtwoelement(arr, n):\n    mpp = {}\n    li = []\n    for i in arr:\n        if i not in mpp:\n            mpp[i] = 0\n        else:\n            mpp[i] += 1\n    for i in range(1, n + 1):\n        try:\n            mpp[i] += 1\n        except:\n            mpp[i] = 0\n    for i in mpp:\n        if mpp[i] > 1:\n            li.append(i)\n            break\n    for i in mpp:\n        if mpp[i] == 0:\n            li.append(i)\n            break\n    return li", "def findtwoelement1(nums, n):\n    lookup = [0] * (n + 1)\n    for num in nums:\n        lookup[num] += 1\n    result = [None, None]\n    for num in range(1, n + 1):\n        if lookup[num] == 0:\n            result[1] = num\n        elif lookup[num] > 1:\n            result[0] = num\n    return result\n\ndef findtwoelement(nums, n):\n    sumRepeating = 0\n    sumMissing = n * (n + 1) // 2\n    sumSquareRepeating = 0\n    sumSquareMissing = n * (n + 1) * (2 * n + 1) // 6\n    for num in nums:\n        sumRepeating += num\n        sumSquareRepeating += num * num\n    val1 = sumRepeating - sumMissing\n    val2 = sumSquareRepeating - sumSquareMissing\n    val2 = val2 // val1\n    x = (val1 + val2) // 2\n    y = x - val1\n    return [x, y]", "def findtwoelement(nums, n):\n    sumRepeating = 0\n    sumMissing = n * (n + 1) // 2\n    sumSquareRepeating = 0\n    sumSquareMissing = n * (n + 1) * (2 * n + 1) // 6\n    for num in nums:\n        sumRepeating += num\n        sumSquareRepeating += num * num\n    val1 = sumRepeating - sumMissing\n    val2 = sumSquareRepeating - sumSquareMissing\n    val2 = val2 // val1\n    x = (val1 + val2) // 2\n    y = x - val1\n    return [x, y]", "def findtwoelement(nums, n):\n    lookup = [0] * (n + 1)\n    for num in nums:\n        lookup[num] += 1\n    result = [None, None]\n    for num in range(1, n + 1):\n        if lookup[num] == 0:\n            result[1] = num\n        elif lookup[num] > 1:\n            result[0] = num\n    return result", "def findtwoelement(arr, n):\n    repeating_element = -1\n    missing_element = -1\n    for i in range(n):\n        index = abs(arr[i]) - 1\n        if arr[index] < 0:\n            repeating_element = abs(arr[i])\n        else:\n            arr[index] = -arr[index]\n    for i in range(n):\n        if arr[i] > 0:\n            missing_element = i + 1\n            break\n    return [repeating_element, missing_element]", "def findtwoelement(arr, n):\n    d = {}\n    l = []\n    for i in arr:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n            l.append(i)\n    for i in range(1, n + 1):\n        if i not in d:\n            l.append(i)\n            return l", "def findtwoelement(arr, n):\n    h = set()\n    dict1 = {}\n    lst = []\n    for i in range(1, n + 1):\n        h.add(i)\n    for i in arr:\n        if i in dict1:\n            dict1[i] = dict1[i] + 1\n        else:\n            dict1[i] = 1\n        if dict1[i] == 2:\n            lst.append(i)\n    for i in h:\n        if i not in dict1:\n            lst.append(i)\n    return lst", "import math\n\ndef findtwoelement(arr, n):\n    sr = 0\n    srr = 0\n    su = 0\n    sur = 0\n    for i in range(n):\n        sr += (i + 1) ** 2\n        srr += arr[i] ** 2\n        su += i + 1\n        sur += arr[i]\n    s1 = sr - srr\n    m_r = su - sur\n    m = round((s1 + m_r ** 2) / (2 * m_r))\n    r = m - m_r\n    return [r, m]", "def findtwoelement(arr, n):\n    l = []\n    arr.sort()\n    d = {}\n    for i in arr:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] = d[i] + 1\n    for (key, value) in d.items():\n        if d[key] == 2:\n            l.append(key)\n    s = 0\n    s1 = 0\n    for i in range(1, n + 1):\n        s = s + i\n    for i in range(n):\n        s1 = s1 + arr[i]\n    diff = s - (s1 - l[0])\n    l.append(diff)\n    return l", "def findtwoelement(arr, n):\n    ans = [0, 0]\n    x = n * (n + 1) // 2\n    x2 = n * (n + 1) * (2 * n + 1) // 6\n    y = 0\n    y2 = 0\n    for i in arr:\n        y += i\n        y2 += i ** 2\n    e1 = x - y\n    e2 = (x2 - y2) // e1\n    ans[1] = (e1 + e2) // 2\n    ans[0] = (e2 - e1) // 2\n    return ans", "def findtwoelement(arr, n):\n    missing = 0\n    duplicate = 0\n    seen = set()\n    for i in range(n):\n        if arr[i] in seen:\n            duplicate = arr[i]\n            break\n        seen.add(arr[i])\n    arr_sum = 0\n    for i in range(n):\n        arr_sum += arr[i]\n    arr_sum -= duplicate\n    missing = n * (n + 1) // 2 - arr_sum\n    return [duplicate, missing]", "def findtwoelement(arr, n):\n    d = {}\n    for i in range(n):\n        d[i + 1] = 0\n    for ele in arr:\n        d[ele] += 1\n    return (max(d, key=d.get), min(d, key=d.get))\n    while i < n:\n        if arr[i] != arr[arr[i] - 1]:\n            temp = arr[i]\n            arr[i] = arr[arr[i] - 1]\n            arr[arr[i] - 1] = temp\n        else:\n            i += 1\n    for i in range(n):\n        if arr[i] != arr[arr[i] - 1]:\n            return (arr[i], i + 1)", "def findtwoelement(arr, n):\n    res = []\n    for i in range(n):\n        if arr[abs(arr[i]) - 1] > 0:\n            arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1]\n        else:\n            res.append(abs(arr[i]))\n    for i in range(n):\n        if arr[i] > 0:\n            res.append(i + 1)\n    return res", "def findtwoelement(arr, n):\n    d = {}\n    for i in range(n):\n        d[i + 1] = 0\n    for ele in arr:\n        d[ele] += 1\n    return (max(d, key=d.get), min(d, key=d.get))", "def findtwoelement(arr, n):\n    res = []\n    for i in range(0, n):\n        while arr[i] - 1 != i:\n            j = arr[i] - 1\n            (arr[i], arr[j]) = (arr[j], arr[i])\n            if arr[i] == arr[j]:\n                break\n    for i in range(0, n):\n        if arr[i] - 1 != i:\n            res.append(arr[i])\n            res.append(i + 1)\n    return res", "def findtwoelement(arr, n):\n    Nsum = n * (n + 1) / 2\n    realSum = sum(arr)\n    den = Nsum - realSum\n    sqSum = 0\n    for i in arr:\n        sqSum += i * i\n    realSq = n * (n + 1) * (2 * n + 1) / 6\n    num = realSq - sqSum\n    s = num / den\n    missing = (s + den) / 2\n    repeat = s - missing\n    return [int(repeat), int(missing)]", "def findtwoelement(arr, n):\n    a_b = n * (n + 1) // 2 - sum(arr)\n    a2_b2 = n * (n + 1) * (2 * n + 1) // 6 - sum([x ** 2 for x in arr])\n    a = (a2_b2 + a_b ** 2) // (2 * a_b)\n    return [a - a_b, a]", "from collections import Counter\n\ndef findtwoelement(arr, n):\n    hm = Counter(arr)\n    a = [0] * 2\n    for i in range(1, n + 1):\n        if i not in hm:\n            a[1] = i\n        if hm[i] > 1:\n            a[0] = i\n    return a", "def findtwoelement(arr, n):\n    arr.sort()\n    A = []\n    for i in range(len(arr) - 1):\n        if arr[i] == arr[i + 1]:\n            A.append(arr[i])\n            break\n    a = set(arr)\n    arr = list(a)\n    N = n * (n + 1) // 2\n    sum1 = 0\n    for i in range(len(arr)):\n        sum1 += arr[i]\n    A.append(N - sum1)\n    return A", "def findtwoelement(arr, n):\n    N = n\n    sum_N = n * (n + 1) // 2\n    sum_N_squares = n * (n + 1) * (2 * n + 1) // 6\n    sum_arr = sum(arr)\n    sum_arr_squares = sum((x ** 2 for x in arr))\n    diff_sum = sum_N - sum_arr\n    diff_sum_squares = sum_N_squares - sum_arr_squares\n    repeating = (diff_sum_squares // diff_sum - diff_sum) // 2\n    missing = diff_sum + repeating\n    return [repeating, missing]", "def findtwoelement(arr, n):\n    a = []\n    b = [0, 0]\n    for i in range(1, n + 1):\n        a.append(i)\n    b[1] = sum(a) - sum(set(arr))\n    b[0] = sum(arr) + b[1] - sum(a)\n    return b", "def findtwoelement(arr, n):\n    freq = [0] * (10 ** 5 + 1)\n    for num in arr:\n        freq[num] += 1\n    result = [0] * 2\n    for i in range(1, n + 1):\n        if freq[i] == 0:\n            result[1] = i\n        if freq[i] == 2:\n            result[0] = i\n    return result"], "starter_code": "def findtwoelement( self,arr, n):\n", "input_output": {"inputs": ["N = 2\r\nArr[] = {2, 2}", "N = 3\r\nArr[] = {1, 3, 3}"], "outputs": ["2 1", "3 2"]}, "difficulty": "MEDIUM", "raw_tags": ["Data Structures", "Arrays"], "name": null, "source": "geeksforgeeks", "tags": ["Data structures"], "skill_types": ["Data structures"], "url": "https://practice.geeksforgeeks.org/problems/find-missing-and-repeating2512/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N)", "entry_point": "findtwoelement", "task_id": "TACO_lite/21"}
{"gt": "U", "requirement": "There are three piles of pens. A pens in the first pile and B pens in the second Pile.Find the minimum number of pens that should be there in the third pile so that sum of all three piles produces either a prime number or unity. \nNote: there should be atleast one pen in the third pile.\nExample 1:\nInput: A = 1, B = 3\nOutput: 1\nExplanation: A + B + K = prime\nK = 1, 1 + 3 + 1 = 5.So answer = 1\nbecuase 5 is minimum possible prime. \nExample 2:\nInput: A = 4, B = 3\nOutput: 4\nExplanation: A + B + K = prime\nK = 4, 4 + 3 + 4 = 11.So answer = 4\nbecuase 11 is minimum possible prime.\nYour Task:  \nYou dont need to read input or print anything. Complete the function minThirdPiles() which takes A and B as input parameter and returns the the minimum number of pens that should be there in the third pile so that sum of all three piles produces a prime number.\nExpected Time Complexity: O(nlogn)\nExpected Auxiliary Space: O(1)\nConstraints:\n1 <= A <=1000\n1 <= B <=1000", "solutions": ["def isPrime(n):\n    prime = 0\n    if n == 1:\n        return 0\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            prime = 1\n            break\n    if prime:\n        return 0\n    else:\n        return 1\n\ndef minthirdpiles(A, B):\n    i = 1\n    flag = True\n    while flag:\n        p = A + B + i\n        if self.isPrime(p):\n            flag = False\n        else:\n            i += 1\n    return i", "def isPrime(num):\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n            break\n        i += 1\n    return True\n\ndef minthirdpiles(A, B):\n    summ = A + B\n    n = 0\n    i = summ + 1\n    while i < 1000000:\n        if self.isPrime(i):\n            n = i\n            break\n        i += 1\n    return n - summ", "def minthirdpiles(A, B):\n\n    def is_prime(x):\n        if x == 1:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n    ans = None\n    x = A + B\n    for i in range(x + 1, x * x):\n        if is_prime(i):\n            return i - x", "import math\n\ndef minthirdpiles(A, B):\n\n    def isprime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    for x in range(1, 10000):\n        if isprime(A + B + x):\n            return x", "def minthirdpiles(A, B):\n    if A == 0 and B == 0:\n        return 1\n    num = A + B + 1\n    while not self.isPrime(num):\n        num += 1\n    return num - (A + B)\n\ndef isPrime(num):\n    if num <= 1:\n        return False\n    if num == 2 or num == 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True", "def minthirdpiles(A, B):\n    if A == 0 and B == 0:\n        return 1\n    k = A + B\n    for i in range(1, k):\n        s = k + i\n        t = []\n        for j in range(2, s):\n            if s % j == 0:\n                t.append(s)\n                break\n        if len(t) == 0:\n            return i", "def minthirdpiles(A, B):\n\n    def p(n):\n        if n == 0 or n == 1:\n            return False\n        s = int(n ** 0.5)\n        for i in range(2, s + 1):\n            if n % i == 0:\n                return False\n        return True\n    c = A + B\n    d = 0\n    while True:\n        c += 1\n        d += 1\n        if p(c):\n            return d", "def minthirdpiles(A, B):\n\n    def is_prime(n):\n        i = 2\n        if n < 3:\n            return False\n        while i * i <= n:\n            if n % i == 0:\n                return False\n            i += 1\n        return True\n    n = A + B\n    temp = 0\n    if is_prime(n):\n        temp = 1\n    while not is_prime(n + temp):\n        temp += 1\n    return temp", "def minthirdpiles(A, B):\n\n    def isPrime(num):\n        if num < 2:\n            return 0\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return 0\n        return 1\n    sumval = A + B\n    for i in range(1, 1000):\n        if isPrime(i + sumval) == 1:\n            return i", "def minthirdpiles(A, B):\n    prime = [1 for _ in range(2500)]\n    prime[0] = prime[1] = 0\n    for i in range(2, 2500):\n        if prime[i] == 1:\n            for j in range(2 * i, 2500, i):\n                prime[j] = 0\n    for j in range(A + B + 1, 2500):\n        if prime[j] == 1:\n            return j - (A + B)", "from math import *\n\ndef isprime(x):\n    if x <= 1:\n        return 0\n    for i in range(2, int(sqrt(x)) + 1):\n        if x % i == 0:\n            return 0\n    return 1\n\ndef minthirdpiles(A, B):\n    c = A + B\n    if isprime(c):\n        c = c + 1\n        i = 1\n        while not isprime(c):\n            i = i + 1\n            c = c + 1\n        return i\n    else:\n        i = 0\n        while not isprime(c + i):\n            i = i + 1\n        return i", "def is_prime(num):\n    for j in range(2, int(num ** (1 / 2)) + 1):\n        if num % j == 0:\n            return 0\n    return 1\n\ndef minthirdpiles(A, B):\n    n = 1\n    while True:\n        pri = self.is_prime(A + B + n)\n        if pri == 1:\n            break\n        n += 1\n    if A == B:\n        return min(A, n)\n    return n", "def is_prime(num):\n    t = num // 2 + 1\n    while t > 2:\n        if num % t == 0:\n            return 0\n        t -= 1\n    return 1\n\ndef minthirdpiles(A, B):\n    n = 1\n    while True:\n        pri = self.is_prime(A + B + n)\n        if pri == 1:\n            break\n        n += 1\n    if A == B:\n        return min(A, n)\n    return n", "import math as m\n\ndef minthirdpiles(A, B):\n\n    def pr(x):\n        if x < 2:\n            return False\n        for i in range(2, int(m.sqrt(x) + 1)):\n            if x % i == 0:\n                return False\n        return True\n    z = 1\n    while True:\n        if pr(A + B + z):\n            return z\n        z = z + 1", "def minthirdpiles(A, B):\n    a = 0\n    p = 0\n    import math\n    while p == 0:\n        a = a + 1\n        sum = A + B + a\n        for i in range(2, int(math.sqrt(sum)) + 1):\n            if sum % i == 0:\n                p = 1\n        if p == 0:\n            return a\n        p = 0", "from math import sqrt\n\ndef prime(n):\n    if n <= 1:\n        return 0\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return 0\n    else:\n        return 1\n\ndef minthirdpiles(A, B):\n    for i in range(1, A * B):\n        if prime(A + B + i) == 1:\n            return i", "def minthirdpiles(A, B):\n    n = A + B\n    while n > 0:\n        for i in range(2, int(n ** 0.5) + 2):\n            if (n + 1) % i == 0:\n                n += 1\n                break\n        else:\n            return n - (A + B) + 1", "def minthirdpiles(A, B):\n\n    def check_prime(n):\n        if n == 2:\n            return True\n        if n <= 1 or n % 2 == 0:\n            return False\n        else:\n            for i in range(3, n):\n                if n % i == 0:\n                    return False\n            return True\n    for i in range(1, 2000):\n        if check_prime(i + A + B):\n            return i"], "starter_code": "def minthirdpiles(A, B):\n", "input_output": {"inputs": ["A = 1, B = 3", "A = 4, B = 3"], "outputs": ["1", "4"]}, "difficulty": "EASY", "raw_tags": ["Prime Number"], "name": null, "source": "geeksforgeeks", "tags": ["Number theory"], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/collection-of-pens1843/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(nlogn)", "entry_point": "minthirdpiles", "task_id": "TACO_lite/22"}
{"gt": "U", "requirement": "The task is to complete the insert() function which is used to implement Insertion Sort. \nExample 1:\nInput:\nN = 5\narr[] = { 4, 1, 3, 9, 7}\nOutput:\n1 3 4 7 9\nExample 2:\nInput:\nN = 10\narr[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}\nOutput:\n1 2 3 4 5 6 7 8 9 10\nYour Task: \nYou don't have to read input or print anything. Your task is to complete the function insert() and insertionSort() where insert() takes the array, it's size and an index i and insertionSort() uses insert function to sort the array in ascending order using insertion sort algorithm. \nExpected Time Complexity: O(N*N).\nExpected Auxiliary Space: O(1).\nConstraints:\n1 <= N <= 1000\n1 <= arr[i] <= 1000", "solutions": ["def insert(alist, index, n):\n    x = alist[index]\n    j = index - 1\n    while j >= 0 and alist[j] > x:\n        alist[j + 1] = alist[j]\n        j -= 1\n    alist[j + 1] = x\n\ndef insertionSort(alist, n):\n    for i in range(1, n):\n        self.insert(arr, i, n)", "def insert(alist, index, n):\n    j = index\n    while j > 0 and alist[j - 1] > alist[j]:\n        temp = alist[j]\n        alist[j] = alist[j - 1]\n        alist[j - 1] = temp\n        j -= 1\n    return alist\n\ndef insertionSort(alist, n):\n    for i in range(n):\n        alist = self.insert(alist, i, n)\n    return alist", "def insertionSort(alist, n):\n    for i in range(1, len(alist)):\n        key = alist[i]\n        j = i - 1\n        while j >= 0 and alist[j] > key:\n            alist[j + 1] = alist[j]\n            j -= 1\n        alist[j + 1] = key\n    return alist", "def insertionSort(alist, n):\n    for i in range(n):\n        tmp = alist[i]\n        j = i - 1\n        while j >= 0 and alist[j] > tmp:\n            alist[j + 1] = alist[j]\n            j = j - 1\n        alist[j + 1] = tmp", "def insertionSort(alist, n):\n    for i in range(1, n):\n        for j in reversed(range(i)):\n            if alist[j] > alist[j + 1]:\n                (alist[j], alist[j + 1]) = (alist[j + 1], alist[j])\n            else:\n                break\n    return alist", "def insert(alist, index, n):\n    pass\n\ndef insertionSort(alist, n):\n    for i in range(n):\n        mini = i\n        for j in range(i + 1, n):\n            if alist[j] < alist[mini]:\n                mini = j\n        (alist[mini], alist[i]) = (alist[i], alist[mini])\n    return alist", "def insertionSort(alist, n):\n    alist.sort()\n    return alist", "def insert(alist, index, n):\n    for index in range(n):\n        alist.append(alist[index])\n\ndef insertionSort(alist, n):\n    alist.sort()\n    return alist", "def insert(alist, index, n):\n    if index == n:\n        return\n    j = index - 1\n    key = arr[index]\n    while j >= 0 and key <= alist[j]:\n        alist[j + 1] = alist[j]\n        j -= 1\n    alist[j + 1] = key\n    self.insert(alist, index + 1, n)\n\ndef insertionSort(alist, n):\n    self.insert(alist, 1, n)\n    return alist", "def insert(alist, index, n):\n    self.insertionSort(alist, n)\n\ndef insertionSort(alist, n):\n    for index in range(1, n):\n        curr = alist[index]\n        pos = index\n        while curr < alist[pos - 1] and pos > 0:\n            alist[pos] = alist[pos - 1]\n            pos = pos - 1\n        alist[pos] = curr\n    return", "def insert(alist, index, n):\n    key = alist[index]\n    i = index - 1\n    while i >= 0 and alist[i] > key:\n        alist[i + 1] = alist[i]\n        i -= 1\n    alist[i + 1] = key\n\ndef insertionSort(alist, n):\n    for i in range(1, n):\n        self.insert(alist, i, n)", "def insert(arr, index, n):\n    if index > n - 1:\n        return\n    temp = arr[index]\n    j = index - 1\n    while j >= 0 and temp < arr[j]:\n        arr[j + 1] = arr[j]\n        j -= 1\n    arr[j + 1] = temp\n    self.insert(arr, index + 1, n)\n\ndef insertionSort(arr, n):\n    self.insert(arr, 1, n)\n    return arr", "def insert(alist, index, n):\n    return alist.sort()\n\ndef insertionSort(alist, n):\n    return alist.sort()", "def insert(arr, index, n):\n    s = arr.sort()\n    return s\n\ndef insertionSort(arr, n):\n    k = arr.sort()\n    return k", "def insert(alist, index, n):\n    while index != 0:\n        if alist[index] < alist[index - 1]:\n            (alist[index], alist[index - 1]) = (alist[index - 1], alist[index])\n        else:\n            break\n        index -= 1\n\ndef insertionSort(arr, n):\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            self.insert(arr, i + 1, n)", "def insertionSort(arr, n):\n    for i in range(n):\n        current = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > current:\n            arr[j + 1] = arr[j]\n            j = j - 1\n        arr[j + 1] = current", "def insert(alist, index, n):\n    pass\n\ndef insertionSort(alist, n):\n    arr.sort()", "def insertionSort(alist, n):\n    for i in range(1, n):\n        valuetosort = alist[i]\n        while alist[i - 1] > valuetosort and i > 0:\n            (alist[i], alist[i - 1]) = (alist[i - 1], alist[i])\n            i -= 1\n    return arr", "def insert(l, i, n):\n    for j in range(i, 0, -1):\n        if l[j] < l[j - 1]:\n            (l[j], l[j - 1]) = (l[j - 1], l[j])\n        else:\n            break\n\ndef insertionSort(l, n):\n    for i in range(1, n):\n        x = self.insert(l, i, n)", "def insertionSort(a, n):\n    for i in range(1, n):\n        x = a[i]\n        j = i - 1\n        while j >= 0 and a[j + 1] < a[j]:\n            (a[j], a[j + 1]) = (a[j + 1], a[j])\n            j = j - 1", "def insert(alist, index, n):\n    pass\n\ndef insertionSort(alist, n):\n    a = alist.sort()\n    return a", "def insert(alist, index, n):\n    return\n\ndef insertionSort(alist, n):\n    for i in range(1, len(alist)):\n        a = i\n        while a > 0 and alist[a - 1] > alist[a]:\n            (alist[a - 1], alist[a]) = (alist[a], alist[a - 1])\n            a -= 1\n    return alist", "def insert(alist, index, n):\n    currentvalue = alist[index]\n    position = index\n    while position > 0 and alist[position - 1] > currentvalue:\n        alist[position] = alist[position - 1]\n        position = position - 1\n    alist[position] = currentvalue\n\ndef insertionSort(alist, n):\n    for index in range(1, n):\n        self.insert(arr, index, n)", "def insert(a, n, i):\n    if i == n:\n        return\n    temp = a[i]\n    j = i - 1\n    while j >= 0 and a[j] > temp:\n        a[j + 1] = a[j]\n        j -= 1\n    a[j + 1] = temp\n    self.insert(a, n, i + 1)\n\ndef insertionSort(alist, n):\n    self.insert(alist, n, 1)", "def insert(alist, i, n):\n    while i and alist[i] < alist[i - 1]:\n        (alist[i], alist[i - 1]) = (alist[i - 1], alist[i])\n        i -= 1\n\ndef insertionSort(alist, n):\n    if n <= 1:\n        return\n    for i in range(1, n):\n        self.insert(alist, i, n)", "def insert(alist, index, n):\n    current_value = alist[index]\n    while index > 0 and alist[index - 1] > current_value:\n        alist[index] = alist[index - 1]\n        index -= 1\n    alist[index] = current_value\n\ndef insertionSort(alist, n):\n    for index in range(1, n):\n        self.insert(alist, index, n)", "def insertionSort(alist, n):\n    if n <= 1:\n        return\n    Solution().insertionSort(alist, n - 1)\n    last = arr[n - 1]\n    j = n - 2\n    while j >= 0 and alist[j] > last:\n        alist[j + 1] = alist[j]\n        j -= 1\n    alist[j + 1] = last", "def insert(alist, index, n):\n    for i in range(index):\n        if alist[i] > alist[index]:\n            (alist[i], alist[index]) = (alist[index], alist[i])\n\ndef insertionSort(alist, n):\n    for i in range(1, n):\n        self.insert(alist, i, n)", "def insert(alist, index, n):\n    pass\n\ndef insertionSort(arr, n):\n    n = len(arr)\n    for i in range(n):\n        index = i\n        swap = 0\n        while index > 0 and arr[index] <= arr[index - 1]:\n            (arr[index], arr[index - 1]) = (arr[index - 1], arr[index])\n            index -= 1", "def insertionSort(alist, n):\n    for i in range(1, n):\n        prev_range = range(i - 1, -1, -1)\n        val = alist[i]\n        for j in prev_range:\n            if val > alist[j]:\n                alist[j + 1] = val\n                break\n            alist[j + 1] = alist[j]\n        else:\n            alist[j] = val", "def insertionSort(a, n):\n    for i in range(1, n):\n        k = a[i]\n        j = i - 1\n        while j >= 0 and k < a[j]:\n            a[j + 1] = a[j]\n            j = j - 1\n        a[j + 1] = k\n    return a", "def insert(arr, n):\n    for i in range(n, 0, -1):\n        if arr[i - 1] > arr[i]:\n            (arr[i - 1], arr[i]) = (arr[i], arr[i - 1])\n        else:\n            return\n\ndef insertionSort(arr, n):\n    for i in range(1, n):\n        if arr[i - 1] > arr[i]:\n            insert(arr, i)\n    return arr"], "starter_code": "def insert(alist, index, n):\n", "input_output": {"inputs": ["N = 5\narr[] = { 4, 1, 3, 9, 7}", "N = 10\narr[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}"], "outputs": ["1 3 4 7 9", "1 2 3 4 5 6 7 8 9 10"]}, "difficulty": "EASY", "raw_tags": ["Algorithms", "Sorting"], "name": null, "source": "geeksforgeeks", "tags": ["Sorting"], "skill_types": ["Sorting"], "url": "https://practice.geeksforgeeks.org/problems/insertion-sort/1", "Expected Auxiliary Space": "O(1).", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N*N).", "entry_point": "insert", "task_id": "TACO_lite/23"}
{"gt": "U", "requirement": "You are given a binary string s and an integer m. You need to return an integer r. Where r = k%m, k is the binary equivalent of string s.\nExample 1:\nInput:\ns = \"101\" \nm = 2\nOutput:\n1\nExplanation: Here k=5 because (101)_{2} = (5)_{10}.\nHence 5 mod 2 = 1.\nExample 2:\nInput:\ns = \"1000\"\nm = 4\nOutput:\n0\nExplanation: Here k=8 and m=4 hence \nr = k mod m = 8 mod 4 = 0.\nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function modulo() which takes the string s and integer m as input parameters and returns the value of r as described above.\nExpected Time Complexity: O(N)\nExpected Auxiliary Space: O(N)\nConstraints:\n1 <= len(s) <= 10^{7}\n1 <= m <= 100", "solutions": ["def modulo(s, m):\n    k = int(s, 2)\n    return k % m", "def modulo(s, m):\n    rs = 0\n    lenS = len(s)\n    i = 0\n    while i < lenS:\n        while i < lenS and rs < m:\n            rs = (rs << 1) + int(s[i])\n            i += 1\n        if rs >= m:\n            rs = int(rs % m)\n    return rs", "def modulo(s, m):\n    c = int(s, 2)\n    return c % m", "def modulo(s, m):\n    a = int(s, 2)\n    return a % m", "def modulo(s, m):\n    n = len(s)\n    s = s[::-1]\n    res = 0\n    p = [0] * n\n    p[0] = 1\n    tmp = 0\n    for i in range(1, n):\n        p[i] = 2 * p[i - 1] % m\n    for i in range(n):\n        if s[i] == '1':\n            tmp += p[i]\n        tmp %= m\n    return tmp", "def modulo(s, m):\n    r = int(s, 2)\n    return r % m", "def modulo(s, m):\n    dec = int(s, 2)\n    return dec % m", "def modulo(s, m):\n    x = int(s, 2)\n    return x % m", "def modulo(s, m):\n    decimal = 0\n    for digit in s:\n        if digit == '1':\n            decimal = decimal * 2 + 1\n        else:\n            decimal = decimal * 2\n    return decimal % m", "def modulo(s, m):\n    n = int(s, 2)\n    return n % m", "def modulo(s, m):\n    num = int(s, 2)\n    ans = num % m\n    return ans", "def modulo(s, m):\n    res = int(s, 2)\n    return res % m", "def modulo(s, m):\n    total = 0\n    for x in s:\n        total = (total * 2 + int(x)) % m\n    return total", "def modulo(s, m):\n    d = int(s, 2)\n    return d % m", "def modulo(s, m):\n    r = 0\n    for c in s:\n        r = (r * 2 + int(c)) % m\n    return r", "def modulo(s, m):\n    p = [1]\n    for i in range(1, len(s) + 1):\n        p.append(p[-1] * 2 % m)\n    k = 0\n    for i in range(len(s)):\n        k = (k * 2 + int(s[i])) % m\n    return k", "def modulo(s, m):\n    number = int(s, 2)\n    return number % m", "def modulo(s, m):\n    r = 0\n    for c in s:\n        r = r * 2\n        if c == '1':\n            r += 1\n        if r >= m:\n            r -= m\n    return r", "import math\n\ndef modulo(s, m):\n    return int(s, 2) % m", "def modulo(s: str='0', m: int=1) -> int:\n    if not all((char in '01' for char in s)):\n        raise ValueError('Input string must be a binary string.')\n    if m <= 0:\n        raise ValueError('Modulus must be a positive integer greater than zero.')\n    k = int(s, 2)\n    r = k % m\n    return r", "def modulo(s, m):\n    t = int(s, 2)\n    return t % m", "def modulo(s, m):\n    mom = int(s, 2)\n    return mom % m", "def modulo(s, m):\n    v = 0\n    for i in range(len(s)):\n        v = (v * 2 + (1 if s[i] == '1' else 0)) % m\n    return v % m", "def modulo(s, m):\n    temp = 0\n    pow = 1\n    c = 0\n    return int(s, 2) % m", "def modulo(s, m):\n    r = 0\n    n = len(s)\n    power_of_2 = [1] * n\n    for i in range(n - 2, -1, -1):\n        power_of_2[i] = (power_of_2[i + 1] << 1) % m\n    for i in range(n):\n        if s[i] == '1':\n            r = (r + power_of_2[i]) % m\n    return r", "def modulo(s, m):\n    b = 0\n    a = len(s) - 1\n    i = len(s) - 1\n    p = 1\n    while i >= 0:\n        if s[i] == '1':\n            b += p\n            b = b % m\n        p = p * 2\n        p = p % m\n        i -= 1\n    return b", "def modulo(s, m):\n    ans = 0\n    power = 1\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == '1':\n            ans += power\n            ans %= m\n        power *= 2\n        power %= m\n    return ans", "def modulo(s, m):\n    n = len(s)\n    prefix_mod = [0] * n\n    prefix_mod[0] = int(s[0]) % m\n    for i in range(1, n):\n        prefix_mod[i] = (prefix_mod[i - 1] * 2 % m + int(s[i])) % m\n    return prefix_mod[n - 1]", "def modulo(s, m):\n    integerval = int(s, 2)\n    ans = integerval % m\n    return int(ans)", "def modulo(s, m):\n    dig = int(s, 2)\n    return dig % m", "def modulo(s, m):\n    n = len(s)\n    res = 0\n    cur = 1\n    for i in range(n - 1, -1, -1):\n        if s[i] == '1':\n            res += cur\n            res %= m\n        cur <<= 1\n        cur %= m\n    return res % m"], "starter_code": "def modulo(s, m):\n", "input_output": {"inputs": ["s = \"101\" \nm = 2", "s = \"1000\"\nm = 4"], "outputs": ["1", "0"]}, "difficulty": "EASY", "raw_tags": ["Bit Magic", "Mathematical"], "name": null, "source": "geeksforgeeks", "tags": ["Bit manipulation", "Mathematics"], "skill_types": ["Bit manipulation"], "url": "https://practice.geeksforgeeks.org/problems/7488b7721e8aa5e5fc37d56af8b9c89e329c796f/1", "Expected Auxiliary Space": "O(N)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N)", "entry_point": "modulo", "task_id": "TACO_lite/24"}
{"gt": "U", "requirement": "# Kata Task\n\nI have a cat and a dog.\n\nI got them at the same time as kitten/puppy. That was `humanYears` years ago.\n\nReturn their respective ages now as [`humanYears`,`catYears`,`dogYears`]\n\nNOTES:\n* humanYears >= 1\n* humanYears are whole numbers only\n\n## Cat Years\n\n* `15` cat years for first year\n* `+9` cat years for second year\n* `+4` cat years for each year after that\n\n## Dog Years\n\n* `15` dog years for first year\n* `+9` dog years for second year\n* `+5` dog years for each year after that\n\n\n\n**References**\n\n* http://www.catster.com/cats-101/calculate-cat-age-in-cat-years\n* http://www.slate.com/articles/news_and_politics/explainer/2009/05/a_dogs_life.html\n\n\n\nIf you liked this Kata there is another related one here", "solutions": ["def human_years_cat_years_dog_years(x):\n    return [x, 24 + (x - 2) * 4 if x != 1 else 15, 24 + (x - 2) * 5 if x != 1 else 15]", "def human_years_cat_years_dog_years(human_years):\n    catYears = 0\n    dogYears = 0\n    if human_years == 1:\n        catYears += 15\n        dogYears += 15\n        return [human_years, catYears, dogYears]\n    elif human_years == 2:\n        catYears += 24\n        dogYears += 24\n        return [human_years, catYears, dogYears]\n    elif human_years > 2:\n        catYears += 24\n        dogYears += 24\n        years = human_years - 2\n        catYears += years * 4\n        dogYears += years * 5\n        return [human_years, catYears, dogYears]\n    return [0, 0, 0]", "def human_years_cat_years_dog_years(n):\n    cat_years = 15 + 9 * (n > 1) + 4 * (n - 2) * (n > 2)\n    dog_years = 15 + 9 * (n > 1) + 5 * (n - 2) * (n > 2)\n    return [n, cat_years, dog_years]", "def human_years_cat_years_dog_years(hy):\n    return [hy, 16 + 4 * hy, 14 + 5 * hy] if hy > 1 else [1, 15, 15]", "def human_years_cat_years_dog_years(human_years, dog_years=15, cat_years=15):\n    if human_years == 1:\n        pass\n    elif human_years == 2:\n        cat_years = dog_years = 24\n    else:\n        cat_years = 4 * human_years + 16\n        dog_years = 5 * human_years + 14\n    return [human_years, cat_years, dog_years]", "def human_years_cat_years_dog_years(h):\n    (c, d) = (0, 0)\n    if h == 1:\n        (c, d) = (15, 15)\n    elif h >= 2:\n        (c, d) = (24, 24)\n    for i in range(h - 2, 0, -1):\n        c += 4\n        d += 5\n    return [h, c, d]", "def human_years_cat_years_dog_years(human_years):\n    catYears = 15\n    DogYears = 15\n    if human_years == 1:\n        return [human_years, catYears, DogYears]\n    elif human_years == 2:\n        return [human_years, catYears + 9, DogYears + 9]\n    elif human_years >= 3:\n        n = human_years - 3\n        s = 24 + n * 4 + 4\n        f = 24 + n * 5 + 5\n        return [human_years, s, f]", "def human_years_cat_years_dog_years(human_years):\n    if human_years > 2:\n        cat_years = (human_years - 2) * 4 + 24\n        dog_years = (human_years - 2) * 5 + 24\n    elif human_years == 2:\n        cat_years = 24\n        dog_years = 24\n    else:\n        cat_years = 15\n        dog_years = 15\n    return [human_years, cat_years, dog_years]", "human_years_cat_years_dog_years = lambda h: [h] + [15 * (h >= 1) + 9 * (h >= 2) + (h - 2) * y * (h > 2) for y in [4, 5]]", "def human_years_cat_years_dog_years(h):\n    return [h, 15 + 9 * (h >= 2) + 4 * max(h - 2, 0), 15 + 9 * (h >= 2) + 5 * max(h - 2, 0)]", "def human_years_cat_years_dog_years(years):\n    return [years, 16 + 4 * years, 14 + 5 * years] if years > 1 else [1, 15, 15]", "def human_years_cat_years_dog_years(human_years):\n    catYears = 0\n    dogYears = 0\n    if human_years < 2:\n        catYears = human_years * 15\n        dogYears = catYears\n    elif human_years < 3:\n        catYears = 15 + 9\n        dogYears = catYears\n    else:\n        catYears = (human_years - 2) * 4 + 24\n        dogYears = (human_years - 2) * 5 + 24\n    return [human_years, catYears, dogYears]", "def human_years_cat_years_dog_years(human_years):\n    if human_years == 1:\n        return [1, 15, 15]\n    years_after_2nd = human_years - 2\n    cat_years = 24 + 4 * years_after_2nd\n    dog_years = 24 + 5 * years_after_2nd\n    return [human_years, cat_years, dog_years]", "def human_years_cat_years_dog_years(human_years):\n    CAT_YEARS_FIRST = 14\n    DOG_YEARS_FIRST = 14\n    CAT_YEARS_SECOND = 8\n    DOG_YEARS_SECOND = 8\n    CAT_YEARS_THIRD = 4\n    DOG_YEARS_THIRD = 5\n    if human_years == 1:\n        return [human_years, human_years + CAT_YEARS_FIRST, human_years + DOG_YEARS_FIRST]\n    elif human_years == 2:\n        return [human_years, human_years + CAT_YEARS_FIRST + CAT_YEARS_SECOND, human_years + DOG_YEARS_FIRST + DOG_YEARS_SECOND]\n    else:\n        return [human_years, CAT_YEARS_FIRST + CAT_YEARS_SECOND + CAT_YEARS_THIRD * (human_years - 2) + 2, DOG_YEARS_FIRST + DOG_YEARS_SECOND + DOG_YEARS_THIRD * (human_years - 2) + 2]", "from functools import partial\n\ndef human_years_cat_years_dog_years(human_years):\n    return [age_func(human_years) for age_func in (human_age, cat_age, dog_age)]\n\ndef critter_age(human_years, critter_years_multipliers):\n    critter_age = previous_year = 0\n    for (year, multiplier) in critter_years_multipliers:\n        is_older = human_years > year\n        years_difference = (year if is_older else human_years) - previous_year\n        critter_age += multiplier * years_difference\n        if not is_older:\n            break\n        previous_year = year\n    return critter_age\ninfinity = float('inf')\nhuman_age = partial(critter_age, critter_years_multipliers=((infinity, 1),))\ncat_age = partial(critter_age, critter_years_multipliers=((1, 15), (2, 9), (infinity, 4)))\ndog_age = partial(critter_age, critter_years_multipliers=((1, 15), (2, 9), (infinity, 5)))", "def human_years_cat_years_dog_years(human_years):\n    ages = [0, 0, 0]\n    if human_years == 1:\n        ages[0] = 1\n        ages[1] = 15\n        ages[2] = 15\n    if human_years == 2:\n        ages[0] = 2\n        ages[1] = 24\n        ages[2] = 24\n    if human_years >= 3:\n        ages[0] = human_years\n        ages[1] = 24 + (human_years - 2) * 4\n        ages[2] = 24 + (human_years - 2) * 5\n    return ages", "def human_years_cat_years_dog_years(human_years):\n    if human_years == 1:\n        return [1, 15, 15]\n    if human_years == 2:\n        return [2, 24, 24]\n    return [human_years, (human_years - 2) * 4 + 24, (human_years - 2) * 5 + 24]", "def human_years_cat_years_dog_years(human_years):\n    cat_years = 15 if human_years == 1 else 15 + 9 if human_years == 2 else 15 + 9 + (human_years - 2) * 4\n    dog_years = 15 if human_years == 1 else 15 + 9 if human_years == 2 else 15 + 9 + (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "def human_years_cat_years_dog_years(human_years):\n    a = 15 + 9 * int(human_years >> 1 != 0)\n    return [human_years, a + 4 * max(0, human_years - 2), a + 5 * max(0, human_years - 2)]", "def human_years_cat_years_dog_years(human_years):\n    cat_years = (lambda y: 15 + 9 * (0, 1)[y - 1 > 0] + 4 * (y - 2) * (0, 1)[y - 2 > 0])(human_years)\n    dog_years = (lambda y: 15 + 9 * (0, 1)[y - 1 > 0] + 5 * (y - 2) * (0, 1)[y - 2 > 0])(human_years)\n    return [human_years, cat_years, dog_years]", "def human_years_cat_years_dog_years(n):\n    return [n, 15 if n == 1 else 4 * (n + 4), 15 if n == 1 else 5 * n + 14]", "from functools import partial\ninfinity = float('inf')\n\ndef human_years_cat_years_dog_years(human_years):\n    age = Age.from_human(human_years)\n    return [age.as_human, age.as_cat, age.as_dog]\n\ndef __new__(meta, name, bases, namespace):\n    attr_name = namespace.pop('_attr_name_', 'normalized_age')\n    conversions = namespace.pop('_conversions_', {})\n    if conversions:\n\n        def as_(self, year_to_multiplier):\n            age = getattr(self, attr_name)\n            converted_age = previous_year = 0\n            for (year, multiplier) in year_to_multiplier:\n                is_older = age > year\n                years_difference = (year if is_older else age) - previous_year\n                converted_age += multiplier * years_difference\n                if not is_older:\n                    break\n                previous_year = year\n            return converted_age\n        for (name, year_to_multiplier) in conversions.items():\n            namespace['from_' + name] = classmethod(partial(meta.__from, year_to_multiplier=year_to_multiplier))\n            namespace['as_' + name] = property(partial(as_, year_to_multiplier=year_to_multiplier))\n\n    def __init__(self, normalized_age):\n        setattr(self, attr_name, normalized_age)\n    namespace['__init__'] = __init__\n    return super().__new__(meta, name, bases, namespace)\n\ndef __from(cls, age, year_to_multiplier):\n    normalized_age = previous_year = 0\n    for (year, multiplier) in year_to_multiplier:\n        years_difference = year - previous_year\n        max_age_in_range = multiplier * years_difference\n        if age <= max_age_in_range:\n            normalized_age += age / multiplier\n            break\n        age -= max_age_in_range\n        previous_year = year\n        normalized_age += years_difference\n    return cls(normalized_age)", "def human_years_cat_years_dog_years(hy):\n    cy = 15 + (hy > 1) * (4 * hy + 1)\n    dy = 15 + (hy > 1) * (5 * hy - 1)\n    return [hy, cy, dy]", "def human_years_cat_years_dog_years(human_years):\n    cat = sum([15, 9, (human_years - 2) * 4][:human_years])\n    dog = sum([15, 9, (human_years - 2) * 5][:human_years])\n    return [human_years, cat, dog]", "human_years_cat_years_dog_years = lambda n: [n] + [15 * (n > 0) + 9 * (n > 1) + d * max(0, n - 2) for d in (4, 5)]", "human_years_cat_years_dog_years = lambda h: [1, 15, 15] if h == 1 else [2, 24, 24] if h == 2 else [h, 24 + 4 * (h - 2), 24 + 5 * (h - 2)]", "def human_years_cat_years_dog_years(human_years):\n    (cat_years, dog_years) = (0, 0)\n    if human_years > 1:\n        cat_years = 24 + (human_years - 2) * 4\n        dog_years = 24 + (human_years - 2) * 5\n    else:\n        cat_years = dog_years = 15\n    return [human_years, cat_years, dog_years]", "def human_years_cat_years_dog_years(y):\n    return [y, 24 + 4 * (y - 2), 24 + 5 * (y - 2)] if y >= 2 else [y, y * 9 + 6, y * 9 + 6]", "YRS = (15, 15 + 9, (4, 5))\n\ndef human_years_cat_years_dog_years(human_years):\n    return [human_years, *({0: YRS[0]}.get(human_years - 1, k * (human_years - 2) + YRS[1]) for k in YRS[-1])]", "def human_years_cat_years_dog_years(human_years):\n    return [human_years, *(dict(enumerate((15, 24))).get(human_years - 1, k * (human_years - 2) + 24) for k in (4, 5))]", "def human_years_cat_years_dog_years(y):\n    return [y, 16 + 4 * y, 14 + 5 * y] if y > 1 else [1, 15, 15]", "def human_years_cat_years_dog_years(h):\n    cat = sum([15 if x == 0 else 9 if x == 1 else 4 for x in range(h)])\n    return [h, cat, cat + h - 2 if h > 2 else cat]", "def human_years_cat_years_dog_years(h):\n    l = list(range(1, h + 1))\n    return [h, 15 * len(l[0:1]) + 9 * len(l[1:2]) + 4 * len(l[2:]), 15 * len(l[0:1]) + 9 * len(l[1:2]) + 5 * len(l[2:])]", "def human_years_cat_years_dog_years(human_years):\n    catYears = 15\n    if human_years == 2:\n        catYears = 15 + 9\n    if human_years >= 3:\n        catYears = 24 + (human_years - 2) * 4\n    dogYears = 15\n    if human_years == 2:\n        dogYears = 15 + 9\n    if human_years >= 3:\n        dogYears = 24 + (human_years - 2) * 5\n    return [human_years, catYears, dogYears]", "def human_years_cat_years_dog_years(human_years):\n    return [human_years, sum([15 if x == 1 else 9 if x == 2 else 4 for x in range(1, human_years + 1)]), sum([15 if x == 1 else 9 if x == 2 else 5 for x in range(1, human_years + 1)])]", "from typing import List\n\ndef human_years_cat_years_dog_years(human_years: int) -> List[int]:\n    __get_animals_years_multiplier = lambda _def: [{1: 15, 2: 9}.get(_it, _def) for _it in list(range(1, human_years + 1))]\n    return [human_years, sum(__get_animals_years_multiplier(4)), sum(__get_animals_years_multiplier(5))]", "def human_years_cat_years_dog_years(human_years):\n    if human_years == 1:\n        dog = 15\n        cat = 15\n    elif human_years == 2:\n        dog = 24\n        cat = 24\n    else:\n        dog = 24 + int(human_years - 2) * 5\n        cat = 24 + int(human_years - 2) * 4\n    return [human_years, cat, dog]", "def human_years_cat_years_dog_years(human_years):\n    if human_years >= 1:\n        cat_years = 15\n        dog_years = 15\n    if human_years >= 2:\n        cat_years += 9\n        dog_years += 9\n        for i in range(human_years - 2):\n            cat_years += 4\n            dog_years += 5\n    return [human_years, cat_years, dog_years]", "def human_years_cat_years_dog_years(human_years):\n    cat_years = 15 + 9 * (human_years >= 2) + 4 * (human_years - 2) * (human_years >= 3)\n    dog_years = 15 + 9 * (human_years >= 2) + 5 * (human_years - 2) * (human_years >= 3)\n    return [human_years, cat_years, dog_years]", "human_years_cat_years_dog_years = lambda y: [y, y * 4 + (16 if y > 1 else 11 if y == 1 else 0), y * 5 + (14 if y > 1 else 10 if y == 1 else 0)]", "def human_years_cat_years_dog_years(human_years):\n    if human_years >= 2:\n        catYears = 15 + 9 + (human_years - 2) * 4\n        dogYears = 15 + 9 + (human_years - 2) * 5\n        return [human_years, catYears, dogYears]\n    else:\n        return [human_years, 15, 15]", "def human_years_cat_years_dog_years(human_years):\n    catYears = 0\n    dogYears = 0\n    humanYears = human_years\n    for i in range(human_years):\n        if i == 0:\n            catYears = catYears + 15\n            dogYears = dogYears + 15\n        if i == 1:\n            catYears = catYears + 9\n            dogYears = dogYears + 9\n        if i > 1:\n            catYears = catYears + 4\n            dogYears = dogYears + 5\n    return [humanYears, catYears, dogYears]", "def human_years_cat_years_dog_years(human_years):\n    c = 15\n    d = 15\n    if human_years == 2:\n        c = 15 + 9\n        d = 15 + 9\n    if human_years > 2:\n        c = 24 + (human_years - 2) * 4\n        d = 24 + (human_years - 2) * 5\n    return [human_years, c, d]", "def human_years_cat_years_dog_years(hy):\n    return [hy, 15 if hy == 1 else 24 if hy == 2 else 24 + (hy - 2) * 4, 15 if hy == 1 else 24 if hy == 2 else 24 + (hy - 2) * 5]", "def human_years_cat_years_dog_years(human_years):\n    animal_first_two_years = 15 if human_years > 0 else 0\n    animal_first_two_years += 9 if human_years > 1 else 0\n    animal_last_years = max(0, human_years - 2)\n    return [human_years, animal_first_two_years + 4 * animal_last_years, animal_first_two_years + 5 * animal_last_years]", "def human_years_cat_years_dog_years(human_years):\n    b = 0\n    c = 0\n    if human_years == 1:\n        b = 15\n        c = 15\n    elif human_years == 2:\n        b = 24\n        c = 24\n    else:\n        b = 24 + (human_years - 2) * 4\n        c = 24 + (human_years - 2) * 5\n    return [human_years, b, c]", "def human_years_cat_years_dog_years(human_years):\n    dog_years = 15 + min(human_years - 1, 1) * 9 + max(human_years - 2, 0) * 5\n    cat_years = 15 + min(human_years - 1, 1) * 9 + max(human_years - 2, 0) * 4\n    return [human_years, cat_years, dog_years]", "def human_years_cat_years_dog_years(hy):\n    if hy == 1:\n        return [1, 15, 15]\n    elif hy == 2:\n        return [2, 24, 24]\n    elif hy > 2:\n        return [hy, 24 + 4 * (hy - 2), 24 + 5 * (hy - 2)]\n    return [0, 0, 0]", "def human_years_cat_years_dog_years(human):\n    if human == 1:\n        return [human, 15, 15]\n    if human == 2:\n        return [human, 24, 24]\n    if human >= 3:\n        return [human, (human - 2) * 4 + 24, (human - 2) * 5 + 24]", "def human_years_cat_years_dog_years(human):\n    cat = 0\n    dog = 0\n    if human >= 1:\n        cat += 15\n        dog += 15\n    if human >= 2:\n        cat += 9\n        dog += 9\n    if human >= 3:\n        n = human - 2\n        cat += n * 4\n        dog += n * 5\n    return [human, cat, dog]", "def human_years_cat_years_dog_years(hy):\n    base = 15 * (hy >= 1) + 9 * (hy >= 2)\n    rest = max(0, hy - 2)\n    cy = base + 4 * rest\n    dy = base + 5 * rest\n    return [hy, cy, dy]", "def human_years_cat_years_dog_years(h):\n    if h == 1:\n        return [h, 15, 15]\n    if h == 2:\n        return [h, 24, 24]\n    return [h, 24 + (h - 2) * 4, 24 + (h - 2) * 5]", "from itertools import accumulate, repeat\n\ndef human_years_cat_years_dog_years(years):\n    if years >= 2:\n        return [years, 4 * (years - 2) + 24, 5 * (years - 2) + 24]\n    elif years == 1:\n        return [1, 15, 15]", "def human_years_cat_years_dog_years(human_years):\n    cat_years = 0\n    dog_years = 0\n    for y in range(0, human_years):\n        if y == 0:\n            cat_years += 15\n            dog_years += 15\n        elif y == 1:\n            cat_years += 9\n            dog_years += 9\n        else:\n            cat_years += 4\n            dog_years += 5\n    return [human_years, cat_years, dog_years]", "def human_years_cat_years_dog_years(human_years):\n    cat_years = 0\n    dog_years = 0\n    if human_years < 2:\n        cat_years += 15\n        dog_years += 15\n    elif human_years == 2:\n        cat_years += 15 + 9\n        dog_years += 15 + 9\n    else:\n        cat_years += 15 + 9 + (human_years - 2) * 4\n        dog_years += 15 + 9 + (human_years - 2) * 5\n    return [human_years, cat_years, dog_years]", "def human_years_cat_years_dog_years(human_years):\n    if human_years == 1:\n        return [1, 15, 15]\n    elif human_years == 2:\n        return [2, 24, 24]\n    else:\n        return [human_years, (human_years - 2) * 4 + 24, (human_years - 2) * 5 + 24]\n    32", "def human_years_cat_years_dog_years(h):\n    (cat, dog) = (0, 0)\n    if h >= 1:\n        cat += 15\n        dog += 15\n    if h >= 2:\n        cat += 9\n        dog += 9\n    if h >= 3:\n        cat += 4 * (h - 2)\n        dog += 5 * (h - 2)\n    return [h, cat, dog]", "def human_years_cat_years_dog_years(human_years):\n    if human_years == 1:\n        cat_years = 15\n        dog_years = 15\n    elif human_years == 2:\n        cat_years = 24\n        dog_years = 24\n    elif human_years == 3:\n        cat_years = 28\n        dog_years = 29\n    else:\n        cat_years = 28 + (human_years - 3) * 4\n        dog_years = 29 + (human_years - 3) * 5\n    return [human_years, cat_years, dog_years]", "def human_years_cat_years_dog_years(human_years):\n    a = human_years\n    if human_years == 1:\n        d = 15\n        c = 15\n    elif human_years == 2:\n        d = 24\n        c = 24\n    else:\n        d = 24 + abs(human_years - 2) * 5\n        c = 24 + abs(human_years - 2) * 4\n    return [a, c, d]", "def human_years_cat_years_dog_years(human_years):\n    if human_years == 1:\n        cat_years = 15\n        dog_years = 15\n    elif human_years == 2:\n        cat_years = 15 + 9\n        dog_years = 15 + 9\n    elif human_years > 2:\n        cat_years = 24 + (human_years - 2) * 4\n        dog_years = 24 + (human_years - 2) * 5\n    else:\n        None\n    return [human_years, cat_years, dog_years]", "def human_years_cat_years_dog_years(human_years):\n    if human_years == 1:\n        (catYears, dogYears) = (15, 15)\n    elif human_years == 2:\n        (catYears, dogYears) = (24, 24)\n    else:\n        catYears = 24 + (human_years - 2) * 4\n        dogYears = 24 + (human_years - 2) * 5\n    return [human_years, catYears, dogYears]", "def human_years_cat_years_dog_years(human_years):\n    if human_years == 1:\n        (cat_y, dog_y) = (15, 15)\n    elif human_years == 2:\n        (cat_y, dog_y) = (24, 24)\n    else:\n        cat_y = 24 + 4 * (human_years - 2)\n        dog_y = 24 + 5 * (human_years - 2)\n    return [human_years, cat_y, dog_y]", "def human_years_cat_years_dog_years(human_years):\n    if human_years == 1:\n        (cat, dog) = (15, 15)\n    if human_years == 2:\n        (cat, dog) = (24, 24)\n    if human_years >= 3:\n        cat = 24 + (human_years - 2) * 4\n        dog = 24 + (human_years - 2) * 5\n    return [human_years, cat, dog]", "def human_years_cat_years_dog_years(h):\n    if h is 1:\n        c = 15\n        d = 15\n    elif h is 2:\n        c = 24\n        d = 24\n    else:\n        c = 24 + (h - 2) * 4\n        d = 24 + (h - 2) * 5\n    return [h, c, d]", "def human_years_cat_years_dog_years(human_years):\n    years = [0, 0, 0]\n    for i in range(0, human_years):\n        if years[0] == 0:\n            years[0] += 1\n            years[1] += 15\n            years[2] += 15\n        elif years[0] == 1:\n            years[0] += 1\n            years[1] += 9\n            years[2] += 9\n        else:\n            years[0] += 1\n            years[1] += 4\n            years[2] += 5\n    return years", "def human_years_cat_years_dog_years(human_years):\n    caty = 0\n    for i in range(0, human_years):\n        if i == 0:\n            caty += 15\n        elif i == 1:\n            caty += 9\n        else:\n            caty += 4\n    dogy = 0\n    for i in range(0, human_years):\n        if i == 0:\n            dogy += 15\n        elif i == 1:\n            dogy += 9\n        else:\n            dogy += 5\n    return [human_years, caty, dogy]", "def human_years_cat_years_dog_years(y):\n    c = d = 15\n    if y > 1:\n        c = d = 24\n    if y > 2:\n        (c, d) = (c + 4 * (y - 2), d + 5 * (y - 2))\n    return [y, c, d]", "def human_years_cat_years_dog_years(human_years):\n    return [human_years, 15 + (9 if human_years >= 2 else 0) + ((human_years - 2) * 4 if human_years >= 2 else 0), 15 + (9 if human_years >= 2 else 0) + ((human_years - 2) * 5 if human_years >= 2 else 0)]", "def human_years_cat_years_dog_years(y):\n    if y == 1:\n        return [1, 15, 15]\n    elif y == 2:\n        return [2, 24, 24]\n    else:\n        return [y, 24 + (y - 2) * 4, 24 + (y - 2) * 5]", "def human_years_cat_years_dog_years(human_years):\n    f = 15\n    s = 9\n    if human_years == 1:\n        return [human_years, f, f]\n    elif human_years == 2:\n        return [human_years, f + s, f + s]\n    else:\n        return [human_years, f + s + (human_years - 2) * 4, f + s + (human_years - 2) * 5]", "def human_years_cat_years_dog_years(human):\n\n    def animal(h, p):\n        r = 0\n        for i in range(1, h + 1):\n            if i == 1:\n                r += 15\n            elif i == 2:\n                r += 9\n            else:\n                r += p\n        return r\n    return [human, animal(human, 4), animal(human, 5)]", "def human_years_cat_years_dog_years(h):\n    return [h, 15 + 9 * int(h > 1) + 4 * (h - 2) * int(h > 2), 15 + 9 * int(h > 1) + 5 * (h - 2) * int(h > 2)]", "def human_years_cat_years_dog_years(yr):\n    return ['one-liner', [1, 15, 15], [2, 24, 24]][yr] if yr in range(1, 3) else [yr, (yr - 2) * 4 + 24, (yr - 2) * 5 + 24]", "def human_years_cat_years_dog_years(human_years):\n    cat_years = 15 * (human_years >= 1) + 9 * (human_years >= 2) + 4 * max(human_years - 2, 0)\n    return [human_years, cat_years, cat_years + max(human_years - 2, 0)]", "human_years_cat_years_dog_years = lambda h: [h, 15 + (h >= 2) * (9 + (h - 2) * 4), 15 + (h >= 2) * (9 + (h - 2) * 5)]", "def human_years_cat_years_dog_years(human_years):\n    cat_years = 0\n    dog_years = 0\n    human = human_years\n    if human >= 1:\n        cat_years = 15\n        dog_years = 15\n        human = human - 1\n    if human >= 1:\n        cat_years += 9\n        dog_years += 9\n        human = human - 1\n    if human >= 1:\n        cat_years += human * 4\n        dog_years += human * 5\n    return [human_years, cat_years, dog_years]"], "starter_code": "def human_years_cat_years_dog_years(human_years):\n", "input_output": {"fn_name": "human_years_cat_years_dog_years", "inputs": [[1], [2], [10]], "outputs": [[[1, 15, 15]], [[2, 24, 24]], [[10, 56, 64]]]}, "difficulty": "EASY", "raw_tags": ["Fundamentals"], "name": null, "source": "codewars", "tags": ["Fundamentals"], "skill_types": [], "url": "https://www.codewars.com/kata/5a6663e9fd56cb5ab800008b", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "human_years_cat_years_dog_years", "task_id": "TACO_lite/25"}
{"gt": "U", "requirement": "Evaluate the value of an arithmetic expression in Reverse Polish Notation.\n\nValid operators are +, -, *, /. Each operand may be an integer or another expression.\n\nNote:\n\n\n       Division between two integers should truncate toward zero.\n       The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.\n\n\nExample 1:\n\n\nInput: [\"2\", \"1\", \"+\", \"3\", \"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n\n\nExample 2:\n\n\nInput: [\"4\", \"13\", \"5\", \"/\", \"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\n\n\nExample 3:\n\n\nInput: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]\nOutput: 22\nExplanation: \n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22", "solutions": ["def evalrpn(tokens):\n    s = []\n    for token in tokens:\n        if token == '+':\n            a = int(s.pop())\n            b = int(s.pop())\n            s.append(a + b)\n        elif token == '/':\n            a = int(s.pop())\n            b = int(s.pop())\n            s.append(b / a)\n        elif token == '*':\n            a = int(s.pop())\n            b = int(s.pop())\n            s.append(a * b)\n        elif token == '-':\n            a = int(s.pop())\n            b = int(s.pop())\n            s.append(b - a)\n        else:\n            s.append(token)\n    if len(s) is not 1:\n        return False\n    else:\n        return int(s.pop())"], "starter_code": "def evalrpn(tokens: List[str]) -> int:\n", "input_output": {"fn_name": "evalRPN", "inputs": [[["\"2\"", "\"1\""]]], "outputs": [0]}, "difficulty": "MEDIUM_HARD", "raw_tags": ["Stack", "Math", "Array"], "name": null, "source": "leetcode", "tags": ["Data structures", "Mathematics"], "skill_types": ["Data structures"], "url": "https://leetcode.com/problems/evaluate-reverse-polish-notation/", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "evalrpn", "task_id": "TACO_lite/26"}
{"requirement": "Implement function which will return sum of roots of a quadratic equation rounded to 2 decimal places, if there are any possible roots, else return **None/null/nil/nothing**. If you use discriminant,when discriminant = 0, x1 = x2 = root => return sum of both roots. There will always be valid arguments. \n\nQuadratic equation - https://en.wikipedia.org/wiki/Quadratic_equation", "solutions": ["def roots(a, b, c):\n    if b ** 2 >= 4 * a * c:\n        return round(-b / a, 2)", "def roots(a, b, c):\n    import math\n    d = b ** 2 - 4 * a * c\n    if d > 0:\n        return round(-2 * b / (2 * a), 2)\n    elif d == 0:\n        x = -b / (2 * a)\n        return x * 2\n    else:\n        return None", "def roots(a, b, c):\n    return round(-b / a, 2) if b * b - 4 * a * c >= 0 else None", "def roots(a, b, c):\n    d = b ** 2 - 4 * a * c\n    if d < 0:\n        return None\n    elif d == 0:\n        return (-b + d ** 0.5) / (2 * a) * 2\n    else:\n        x1 = (-b + d ** 0.5) / (2 * a)\n        x2 = (-b - d ** 0.5) / (2 * a)\n        return round(x1 + x2, 2)", "def roots(a, b, c):\n    d = b ** 2 - 4 * a * c\n    if d >= 0:\n        return round(-b / a, 2)", "roots = lambda a, b, c: None if b * b < a * c * 4 else round(-b / a, 2)", "def roots(a, b, c):\n    D = b ** 2 - 4 * a * c\n    if D < 0:\n        return None\n    if D == 0:\n        x = (-b + D ** 0.5) / (2 * a)\n        return round(x * 2, 2)\n    if D > 0:\n        x1 = (-b + D ** 0.5) / (2 * a)\n        x2 = (-b - D ** 0.5) / (2 * a)\n        return round(x1 + x2, 2)", "import math\n\ndef roots(a, b, c):\n    dis = b ** 2 - 4 * a * c\n    if dis < 0:\n        return None\n    return round((-b + math.sqrt(dis)) / (2 * a) + (-b - math.sqrt(dis)) / (2 * a), 2)", "import math\n\ndef roots(a, b, c):\n    d = round(b * b - 4 * a * c, 2)\n    if d < 0:\n        return None\n    return round(-b / a, 2)"], "starter_code": "def roots(a,b,c):\n", "input_output": {"fn_name": "roots", "inputs": [[1, -35, -23], [6, 0, -24], [-5, 21, 0], [6, 4, 8], [1, 5, -24], [3, 11, 6], [2, 2, 9], [1, -1.6666666666666667, -26], [1, 6, 10], [7, -2, -5], [1, 8, 20], [2, 3, -2], [1, 4, 12], [3, -2, -5], [3, 4, 9], [5, 4, 0], [4, -5, 0], [1, 4, 9], [1, 0, -49], [2, 8, 8], [1, 0, -0.16], [1, 6, 12], [1, 0, -9], [-3, 0, 12], [1, 3, 9], [3, 7, 0], [5, 3, 6], [1, 4, 4], [-1, 0, 5.29], [1, 12, 36], [1, 0, -0.09], [2, 5, 11], [3, 0, -15], [1, -3, 0], [1, 8, 16], [2, 6, 9], [-1, 36, 0], [5, -8, 0], [1, 5, 12], [-14, 0, 0], [1, 7, 20], [1, -6, 0], [1, -11, 30], [1, 3, 12], [1, 6, 9], [8, 47, 41]], "outputs": [[35], [0], [4.2], [null], [-5], [-3.67], [null], [1.67], [null], [0.29], [null], [-1.5], [null], [0.67], [null], [-0.8], [1.25], [null], [0], [-4], [0], [null], [0], [0], [null], [-2.33], [null], [-4], [0], [-12], [0], [null], [0], [3], [-8], [null], [36], [1.6], [null], [0], [null], [6], [11], [null], [-6], [-5.88]]}, "difficulty": "EASY", "raw_tags": ["Mathematics", "Fundamentals"], "name": null, "source": "codewars", "tags": ["Fundamentals", "Mathematics"], "skill_types": [], "url": "https://www.codewars.com/kata/57d448c6ba30875437000138", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "roots", "task_id": "TACO_lite/27"}
{"requirement": "Given two arrays X[] and Y[] of size M and N respectively. Find number of pairs such that x^{y} > y^{x} where x is an element from X[] and y is an element from Y[].\nExample 1:\nInput:\nM = 3, N = 2\nX[] = {2, 1, 6}, Y = {1, 5}\nOutput: 3\nExplanation: There are total 3 pairs \nwhere pow(x, y) is greater than pow(y, x) \nPairs are (2, 1), (2, 5) and (6, 1).\nExample 2:\nInput:\nM = 3, N = 3\nX[] = {10, 19, 18}, Y[] = {11, 15, 9}\nOutput: 2\nExplanation: There are total 2 pairs \nwhere pow(x, y) is greater than pow(y, x) \nPairs are (10, 11) and (10, 15).\nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function countPairs() which takes array X[], array Y[], m and n as input parameters and returns an integer denoting the number of pairs that are true to the given condition. \nExpected Time Complexity: O(N*logN + M*logM)\nExpected Auxiliary Space: O(1)\nConstraints:\n1 ≤ M, N ≤ 10^{5}\n1 ≤ X[i], Y[i] ≤ 10^{3}", "solutions": ["def countpairs(X, Y, m, n):\n    for i in range(m):\n        X[i] **= 1 / X[i]\n    for i in range(n):\n        Y[i] **= 1 / Y[i]\n    X.sort()\n    Y.sort()\n    i = j = 0\n    ans = 0\n    while i < m:\n        if j == n:\n            ans += n\n        else:\n            while j < n and X[i] > Y[j]:\n                j += 1\n            ans += j\n        i += 1\n    return ans", "import bisect\n\ndef countpairs(X, Y, m, n):\n    X.sort()\n    Y.sort()\n    ans = 0\n    for x in X:\n        if x == 1:\n            continue\n        elif x == 2:\n            idx = bisect.bisect_left(Y, 5)\n            ans += n - idx\n        elif x == 3:\n            idx = bisect.bisect_left(Y, 2)\n            ans += n - idx\n            ans -= bisect.bisect(Y, 3) - bisect.bisect_left(Y, 3)\n        else:\n            idx = bisect.bisect_left(Y, x + 1)\n            ans += n - idx\n    for y in Y:\n        if y == 1:\n            idx = bisect.bisect_left(X, 2)\n            ans += m - idx\n    return ans", "def countpairs(X, Y, m, n):\n    import math\n    (x, y) = ([0] * m, [0] * n)\n    for i in range(m):\n        if X[i] == 1:\n            x[i] = float('inf')\n        else:\n            temp = X[i] * 1.0\n            temp = temp / math.log(temp)\n            x[i] = temp\n    for i in range(n):\n        if Y[i] == 1:\n            y[i] = float('inf')\n        else:\n            temp = Y[i] * 1.0\n            temp = temp / math.log(temp)\n            y[i] = temp\n    x.sort()\n    y.sort()\n    i = j = count = 0\n    while i < m and j < n:\n        if x[i] < y[j]:\n            count += n - j\n            i += 1\n        else:\n            j += 1\n    return count", "import bisect as bs\n\ndef countpairs(X, Y, m, n):\n    (y1, y0, y2, y3, y4) = (0, 0, 0, 0, 0)\n    X.sort()\n    Y.sort()\n    count = 0\n    for i in range(n):\n        if Y[i] == 0:\n            y0 += 1\n        elif Y[i] == 1:\n            y1 += 1\n        elif Y[i] == 2:\n            y2 += 1\n        elif Y[i] == 3:\n            y3 += 1\n        elif Y[i] == 4:\n            y4 += 1\n    for i in range(m):\n        if X[i] == 0:\n            continue\n        elif X[i] == 1:\n            count += y0\n        elif X[i] == 2:\n            k = bs.bisect_right(Y, 2)\n            count += n - k\n            count -= y3\n            count -= y4\n            count += y1 + y0\n        else:\n            j = bs.bisect_right(Y, X[i])\n            count += n - j\n            count += y1 + y0\n            if X[i] == 3:\n                count += y2\n    return count", "from bisect import *\n\ndef countpairs(X, Y, m, n):\n    one = 0\n    two = 0\n    for ele in Y:\n        if ele == 1:\n            one += 1\n        if ele == 2:\n            two += 1\n    X.sort()\n    Y.sort()\n    ans = 0\n    for x in X:\n        if x == 1:\n            continue\n        else:\n            ans += one\n            if x == 2:\n                ans += n - bisect_left(Y, 5)\n                continue\n            elif x == 3:\n                ans += two\n            ans += n - bisect_left(Y, x + 1)\n    return ans", "from bisect import *\n\ndef countpairs(X, Y, m, n):\n    y2 = 0\n    y3 = 0\n    y1 = 0\n    for ele in Y:\n        if ele != 2 and ele != 3 and (ele != 4):\n            y2 += 1\n        if ele != 3:\n            y3 += 1\n        if ele == 1:\n            y1 += 1\n    X.sort()\n    Y.sort()\n    ans = 0\n    for x in X:\n        if x == 1:\n            continue\n        elif x == 2:\n            ans += y2\n        elif x == 3:\n            ans += y3\n        else:\n            ans += y1\n            ans += n - bisect_left(Y, x + 1)\n    return ans", "from collections import Counter\n\ndef countpairs(X, Y, m, n):\n    XC = sorted(Counter(X).items())\n    YC = Counter(Y)\n    Y = sorted(YC.items())\n    (ans, i, left) = (0, 0, n - (YC[2] + YC[3] + YC[4]))\n    if XC[i][0] == 1:\n        i += 1\n    if XC[i][0] == 2:\n        ans += XC[i][1] * left\n        i += 1\n    if XC[i][0] == 3:\n        ans += XC[i][1] * (n - YC[3])\n        i += 1\n    if XC[i][0] == 4:\n        ans += XC[i][1] * left\n        i += 1\n    (j, yleft) = (0, n)\n    while i < len(XC):\n        (v, xcnt) = XC[i]\n        ans += YC[1] * xcnt\n        while j < len(Y) and Y[j][0] <= v:\n            yleft -= Y[j][1]\n            j += 1\n        ans += yleft * xcnt\n        i += 1\n    return ans", "def get_index(y, n, ele):\n    ans = -1\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if Y[mid] > ele:\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    return ans\n\ndef countpairs(X, Y, m, n):\n    X.sort()\n    Y.sort()\n    y_c0 = Y.count(0)\n    y_c1 = Y.count(1)\n    y_c3 = Y.count(3)\n    y_c4 = Y.count(4)\n    y_c2 = Y.count(2)\n    i = 0\n    j = 0\n    ind = -1\n    c = 0\n    for i in range(m):\n        if X[i] == 0:\n            continue\n        elif X[i] == 1:\n            c += y_c0\n        elif X[i] == 2:\n            ind = self.get_index(Y, n, 2)\n            if ind != -1:\n                c += n - ind\n            c -= y_c3\n            c -= y_c4\n            c += y_c1 + y_c0\n        else:\n            ind = self.get_index(Y, n, X[i])\n            if ind != -1:\n                c += n - ind\n            c += y_c1 + y_c0\n            if X[i] == 3:\n                c += y_c2\n    return c", "import bisect\n\ndef count(x, Y, n, NoOfY):\n    if x == 0:\n        return 0\n    if x == 1:\n        return NoOfY[0]\n    idx = bisect.bisect_right(Y, x)\n    ans = n - idx\n    ans += NoOfY[0] + NoOfY[1]\n    if x == 2:\n        ans -= NoOfY[3] + NoOfY[4]\n    if x == 3:\n        ans += NoOfY[2]\n    return ans\n\ndef countpairs(X, Y, m, n):\n    NoOfY = [0] * 5\n    for i in range(n):\n        if Y[i] < 5:\n            NoOfY[Y[i]] += 1\n    Y.sort()\n    total_pairs = 0\n    for x in X:\n        total_pairs += self.count(x, Y, n, NoOfY)\n    return total_pairs", "def bina(x, g, n):\n    l = 0\n    h = n - 1\n    ans = -1\n    while l <= h:\n        m = (l + h) // 2\n        if g[m] > x:\n            ans = m\n            h = m - 1\n        else:\n            l = m + 1\n    return ans\n\ndef countpairs(a, b, M, N):\n    s = {}\n    for i in range(5):\n        s[i] = 0\n    for i in b:\n        if i in s:\n            s[i] += 1\n    b.sort()\n    a.sort()\n    c = 0\n    for i in a:\n        if i == 0:\n            continue\n        elif i == 1:\n            c += s[0]\n        elif i == 2:\n            ind = self.bina(i, b, N)\n            if ind != -1:\n                c += N - ind\n            c += s[1] + s[0] - s[3] - s[4]\n        else:\n            ind = self.bina(i, b, N)\n            if ind != -1:\n                c += N - ind\n            c += s[0] + s[1]\n            if i == 3:\n                c += s[2]\n    return c", "import bisect\n\ndef count(x, Y, n, freq):\n    if x == 1:\n        return freq[0]\n    idx = bisect.bisect_right(Y, x)\n    ans = n - idx\n    ans += freq[0] + freq[1]\n    if x == 2:\n        ans -= freq[3] + freq[4]\n    if x == 3:\n        ans += freq[2]\n    return ans\n\ndef countpairs(X, Y, m, n):\n    freq = [0] * 5\n    Y.sort()\n    for i in Y:\n        if i < 5:\n            freq[i] += 1\n    count_ans = 0\n    for i in X:\n        count_ans += self.count(i, Y, n, freq)\n    return count_ans", "import bisect\n\ndef countpairs(X, Y, m, n):\n    Y.sort()\n    noOfYs = [0 for _ in range(5)]\n    for i in range(n):\n        if Y[i] < 5:\n            noOfYs[Y[i]] += 1\n    pairs = 0\n    for x in X:\n        pairs += self.count(x, Y, noOfYs, n)\n    return pairs\n\ndef count(x, Y, noOfYs, n):\n    if x == 0:\n        return 0\n    if x == 1:\n        return noOfYs[0]\n    idx = bisect.bisect_right(Y, x)\n    res = n - idx\n    res += noOfYs[1] + noOfYs[0]\n    if x == 2:\n        res -= noOfYs[3] + noOfYs[4]\n    if x == 3:\n        res += noOfYs[2]\n    return res", "import bisect\n\ndef countpairs(X, Y, m, n):\n    NoOfYs = [0 for _ in range(5)]\n    for i in range(n):\n        if Y[i] < 5:\n            NoOfYs[Y[i]] += 1\n    Y.sort()\n    pairs = 0\n    for x in X:\n        pairs += self.count(x, Y, NoOfYs)\n    return pairs\n\ndef count(x, Y, noOfYs):\n    if x == 0:\n        return 0\n    if x == 1:\n        return noOfYs[0]\n    idx = bisect.bisect_right(Y, x)\n    res = len(Y) - idx\n    res += noOfYs[0] + noOfYs[1]\n    if x == 2:\n        res -= noOfYs[3] + noOfYs[4]\n    if x == 3:\n        res += noOfYs[2]\n    return res\n\ndef binarySearch(Y, x):\n    low = 0\n    high = len(Y) - 1\n    idx = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if Y[mid] > x:\n            idx = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    return idx", "import math\nimport sys\n\ndef countpairs(X, Y, m, n):\n    arr1 = X\n    arr2 = Y\n    for i in range(len(arr1)):\n        if arr1[i] == 1:\n            arr1[i] = sys.maxsize\n        else:\n            arr1[i] = arr1[i] / math.log(arr1[i])\n    arr1.sort()\n    for j in range(len(arr2)):\n        if arr2[j] == 1:\n            arr2[j] = sys.maxsize\n        else:\n            arr2[j] = arr2[j] / math.log(arr2[j])\n    arr2.sort()\n    pointA = 0\n    pointB = 0\n    count = 0\n    while pointA < len(arr1) and pointB < len(arr2):\n        if arr1[pointA] < arr2[pointB]:\n            count += len(arr2) - pointB\n            pointA += 1\n        else:\n            pointB += 1\n    return count", "import bisect\n\ndef count(i, Y, m, res):\n    if i == 0:\n        return 0\n    if i == 1:\n        return res[0]\n    ind = bisect.bisect_right(Y, i)\n    ans = m - ind\n    ans += res[0] + res[1]\n    if i == 2:\n        ans -= res[3] + res[4]\n    if i == 3:\n        ans += res[2]\n    return ans\n\ndef countpairs(X, Y, m, n):\n    cnt = 0\n    result = [0] * 5\n    for i in range(n):\n        if Y[i] < 5:\n            result[Y[i]] += 1\n    Y.sort()\n    for i in X:\n        cnt += self.count(i, Y, n, result)\n    return cnt", "def search(arr, l, r, x):\n    if r >= l:\n        mid = l + (r - l) // 2\n        if arr[mid] <= x:\n            return search(arr, mid + 1, r, x)\n        else:\n            return search(arr, l, mid - 1, x)\n    return l\n\ndef countpairs(X, Y, m, n):\n    nn = [0] * 5\n    for i in range(n):\n        if Y[i] < 5:\n            nn[Y[i]] += 1\n    Y.sort()\n    pairs = 0\n    for i in X:\n        if i == 0:\n            continue\n        elif i == 1:\n            pairs += nn[0]\n        else:\n            ss = search(Y, 0, n - 1, i)\n            if ss > n - 1:\n                ss = 0\n            else:\n                pairs += n - ss\n            pairs += nn[0] + nn[1]\n            if i == 2:\n                pairs -= nn[3] + nn[4]\n            if i == 3:\n                pairs += nn[2]\n    return pairs", "import bisect\n\ndef bs(arr, low, high, x):\n    if low <= high:\n        mid = low + (high - low) // 2\n        if (mid == 0 or arr[mid - 1] <= x) and arr[mid] > x:\n            return mid\n        elif arr[mid] <= x:\n            return self.bs(arr, mid + 1, high, x)\n        else:\n            return self.bs(arr, low, mid - 1, x)\n    else:\n        return -1\n\ndef count(x, Y, n, NoOfY):\n    if x == 0:\n        return 0\n    if x == 1:\n        return NoOfY[0]\n    idx = bisect.bisect_right(Y, x)\n    ans = n - idx\n    ans += NoOfY[0] + NoOfY[1]\n    if x == 2:\n        ans -= NoOfY[3] + NoOfY[4]\n    if x == 3:\n        ans += NoOfY[2]\n    return ans\n\ndef countpairs(X, Y, m, n):\n    NoOfY = [0] * 5\n    for i in range(n):\n        if Y[i] < 5:\n            NoOfY[Y[i]] += 1\n    Y.sort()\n    total_pairs = 0\n    for x in X:\n        total_pairs += self.count(x, Y, n, NoOfY)\n    return total_pairs", "import bisect\n\ndef count(i, b, n, hashe):\n    if i == 0:\n        return 0\n    if i == 1:\n        return hashe[0]\n    index = bisect.bisect_right(b, i)\n    ans = n - index\n    ans += hashe[1] + hashe[0]\n    if i == 2:\n        ans -= hashe[3]\n        ans -= hashe[4]\n    if i == 3:\n        ans += hashe[2]\n    return ans\n\ndef countpairs(a, b, M, N):\n    pairs = 0\n    hashe = dict()\n    hashe = [0 for i in range(5)]\n    for i in b:\n        if i < 5:\n            hashe[i] += 1\n    b.sort()\n    for i in a:\n        pairs += self.count(i, b, N, hashe)\n    return pairs"], "starter_code": "def countpairs(X, Y, m, n):\n", "input_output": {"inputs": ["M = 3, N = 2\nX[] = {2, 1, 6}, Y = {1, 5}", "M = 3, N = 3\nX[] = {10, 19, 18}, Y[] = {11, 15, 9}"], "outputs": ["3", "2"]}, "difficulty": "MEDIUM", "raw_tags": ["Data Structures", "Arrays", "Algorithms", "Sorting"], "name": null, "source": "geeksforgeeks", "tags": ["Sorting", "Data structures"], "skill_types": ["Sorting", "Data structures"], "url": "https://practice.geeksforgeeks.org/problems/number-of-pairs3422/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N*logN + M*logM)", "entry_point": "countpairs", "task_id": "TACO_lite/28"}
{"requirement": "You are given a sequence of a journey in London, UK. The sequence will contain bus **numbers** and TFL tube names as **strings** e.g.\n\n```python\n['Northern', 'Central', 243, 1, 'Victoria']\n```\nJourneys will always only contain a combination of tube names and bus numbers. Each tube journey costs `£2.40` and each bus journey costs `£1.50`. If there are `2` or more adjacent bus journeys, the bus fare is capped for sets of two adjacent buses and calculated as one bus fare for each set.\n\nYour task is to calculate the total cost of the journey and return the cost `rounded to 2 decimal places` in the format (where x is a number): `£x.xx`", "solutions": ["def london_city_hacker(journey):\n    tube = 2.4\n    bus = 1.5\n    total_cost = 0.0\n    count = 0\n    for link in journey:\n        if isinstance(link, str):\n            total_cost += tube\n            count = 0\n        elif count == 0:\n            total_cost += bus\n            count += 1\n        else:\n            count = 0\n    return '£{:.2f}'.format(total_cost)", "def london_city_hacker(journey):\n    vehicle = ''.join(('t' if isinstance(j, str) else 'b' for j in journey)).replace('bb', 'b')\n    return f\"£{sum((2.4 if v == 't' else 1.5 for v in vehicle)):.2f}\"", "def london_city_hacker(journey):\n    prices = []\n    for stop in journey:\n        prices.append(2.4 if type(stop) is str else 1.5)\n        if prices[-2:] == [1.5, 1.5]:\n            prices[-1] = 0\n    return f'£{sum(prices):.2f}'", "from itertools import groupby\n\ndef london_city_hacker(journey):\n    tube_fare = lambda n: 2.4 * n\n    bus_fare = lambda n: 1.5 * sum(divmod(n, 2))\n    s = sum(([bus_fare, tube_fare][a](len(list(g))) for (a, g) in groupby(map(lambda a: isinstance(a, str), journey))))\n    return f'£{s:.2f}'", "def london_city_hacker(journey):\n    total = 0.0\n    l = []\n    for i in range(len(journey)):\n        if type(journey[i]) == str:\n            total += 2.4\n        elif i < len(journey) - 1 and type(journey[i + 1]) == int:\n            l.append(journey[i])\n            if len(l) == 2:\n                total += 1.5\n                l = []\n        else:\n            total += 1.5\n            l = []\n    total = round(total, 2)\n    return '£' + str(total) + '0'", "from itertools import groupby\n\ndef london_city_hacker(journey):\n    return f'£{sum((2.4 * len(list(l)) if k is str else (len(list(l)) + 1) // 2 * 1.5 for (k, l) in groupby(journey, type))):.2f}'", "def london_city_hacker(journey):\n    bus_counter = 0\n    bus_price = 0\n    tube_price = 0\n    for i in journey:\n        if type(i) is int:\n            bus_counter += 1\n            if bus_counter > 1:\n                bus_counter = 0\n                bus_price += 0\n            else:\n                bus_price += 1.5\n        if type(i) is str:\n            bus_counter = 0\n            tube_price += 2.4\n    return f'£{tube_price + bus_price:.2f}'", "def london_city_hacker(journey):\n    sum = 0.0\n    isBus = False\n    for i in journey:\n        if len(str(i)) <= 3:\n            if isBus:\n                isBus = 0\n            else:\n                sum += 1.5\n                isBus = 1\n        else:\n            sum += 2.4\n            isBus = 0\n    sum = round(sum * 100) / 100\n    return f'£{str(sum)}0'", "def london_city_hacker(journey):\n    total_cost = 0\n    adjacent_bus_tour = 0\n    for tour in journey:\n        if type(tour) == str:\n            adjacent_bus_tour = 0\n            total_cost += 2.4\n        else:\n            adjacent_bus_tour += 1\n            if adjacent_bus_tour == 2:\n                adjacent_bus_tour = 0\n            else:\n                total_cost += 1.5\n    return f'£{total_cost:.2f}'", "from itertools import groupby\n\ndef london_city_hacker(journey):\n    arr = list(map(type, journey))\n    s = 0\n    for (k, g) in groupby(arr):\n        g = len(list(g))\n        if k == str:\n            s += 2.4 * g\n        else:\n            s += 1.5 * (g // 2 + (1 if g % 2 else 0) if g > 1 else g)\n    return f'£{round(s, 2):.2f}'"], "starter_code": "def london_city_hacker(journey):\n", "input_output": {"fn_name": "london_city_hacker", "inputs": [[[12, "Central", "Circle", 21]], [["Piccidilly", 56]], [["Northern", "Central", "Circle"]], [["Piccidilly", 56, 93, 243]], [[386, 56, 1, 876]], [[]]], "outputs": [["£7.80"], ["£3.90"], ["£7.20"], ["£5.40"], ["£3.00"], ["£0.00"]]}, "difficulty": "EASY", "raw_tags": ["Fundamentals"], "name": null, "source": "codewars", "tags": ["Fundamentals"], "skill_types": [], "url": "https://www.codewars.com/kata/5bce125d3bb2adff0d000245", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "london_city_hacker", "task_id": "TACO_lite/29"}
{"requirement": "Given an array of integers arr[0..n-1], count all pairs (arr[i], arr[j]) in it such that i*arr[i] > j*arr[j],\nand 0 ≤ i < j < n.\n \nExample 1:\nInput :\narr[] = {5, 0, 10, 2, 4, 1, 6}\nOutput :\n5\nExplanation :\nPairs which hold condition i*arr[i] > j*arr[j] are\n(10, 2) (10, 4) (10, 1) (2, 1) (4, 1)\n \nExample 2:\nInput :\narr[] = {8, 4, 2, 1}\nOutput :\n2\n \nYour Task:  \nYou don't need to read input or print anything. Your task is to complete the function countPairs() which takes the array A[] and its size N as inputs and returns the required result.\n \nExpected Time Complexity: O(N. log(N))\nExpected Auxiliary Space: O(N. log(N))\n \nConstraints:\n1 ≤ N ≤ 10^{5}\n1 ≤ A[ ] ≤ 10^{3}", "solutions": ["def merge(arr, temp, left, mid, right):\n    inv_count = 0\n    i = left\n    j = mid\n    k = left\n    while i <= mid - 1 and j <= right:\n        if arr[i] <= arr[j]:\n            temp[k] = arr[i]\n            i += 1\n            k += 1\n        else:\n            temp[k] = arr[j]\n            k += 1\n            j += 1\n            inv_count = inv_count + (mid - i)\n    while i <= mid - 1:\n        temp[k] = arr[i]\n        i += 1\n        k += 1\n    while j <= right:\n        temp[k] = arr[j]\n        k += 1\n        j += 1\n    for i in range(left, right + 1):\n        arr[i] = temp[i]\n    return inv_count\n\ndef _mergeSort(arr, temp, left, right):\n    inv_count = 0\n    if right > left:\n        mid = (right + left) // 2\n        inv_count = _mergeSort(arr, temp, left, mid)\n        inv_count += _mergeSort(arr, temp, mid + 1, right)\n        inv_count += merge(arr, temp, left, mid + 1, right)\n    return inv_count\n\ndef countpairs(arr, n):\n    for i in range(n):\n        arr[i] = i * arr[i]\n    temp = [0] * n\n    return _mergeSort(arr, temp, 0, n - 1)", "import bisect\n\ndef countpairs(arr, n):\n    srt_arr = []\n    count = 0\n    for i in range(n):\n        arr[i] = i * arr[i]\n        index = bisect.bisect(srt_arr, arr[i])\n        count += i - index\n        srt_arr.insert(index, arr[i])\n    return count", "def countpairs(arr, n):\n    res = [i * arr[i] for i in range(n)]\n    temp = [0] * n\n    return self.sorter(res, temp, 0, n - 1)\n\ndef sorter(arr, temp, l, r):\n    c = 0\n    if l < r:\n        mid = (l + r) // 2\n        c += self.sorter(arr, temp, l, mid)\n        c += self.sorter(arr, temp, mid + 1, r)\n        c += self.merge(arr, temp, l, mid, r)\n    return c\n\ndef merge(arr, temp, l, mid, r):\n    i = l\n    j = mid + 1\n    k = l\n    c = 0\n    while i <= mid and j <= r:\n        if arr[i] <= arr[j]:\n            temp[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            temp[k] = arr[j]\n            c += mid - i + 1\n            k += 1\n            j += 1\n    while i <= mid:\n        temp[k] = arr[i]\n        k += 1\n        i += 1\n    while j <= r:\n        temp[k] = arr[j]\n        k += 1\n        j += 1\n    arr[l:r + 1] = temp[l:r + 1]\n    return c"], "starter_code": "def countpairs(arr, n):\n", "input_output": {"inputs": ["arr[] = {5, 0, 10, 2, 4, 1, 6}", "arr[] = {8, 4, 2, 1}"], "outputs": ["5", "2"]}, "difficulty": "EASY", "raw_tags": ["Data Structures", "Arrays"], "name": null, "source": "geeksforgeeks", "tags": ["Data structures"], "skill_types": ["Data structures"], "url": "https://practice.geeksforgeeks.org/problems/count-pairs-in-an-array4145/1", "Expected Auxiliary Space": "O(N. log(N))", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N. log(N))", "entry_point": "countpairs", "task_id": "TACO_lite/30"}
{"requirement": "A grid is a perfect starting point for many games (Chess, battleships, Candy Crush!).\n\nMaking a digital chessboard I think is an interesting way of visualising how loops can work together.\n\nYour task is to write a function that takes two integers `rows` and `columns` and returns a chessboard pattern as a two dimensional array.\n\nSo `chessBoard(6,4)` should return an array like this:\n\n\n    [\n            [\"O\",\"X\",\"O\",\"X\"],\n            [\"X\",\"O\",\"X\",\"O\"],\n            [\"O\",\"X\",\"O\",\"X\"],\n            [\"X\",\"O\",\"X\",\"O\"],\n            [\"O\",\"X\",\"O\",\"X\"],\n            [\"X\",\"O\",\"X\",\"O\"]\n    ]\n\nAnd `chessBoard(3,7)` should return this:\n\n\n    [\n        [\"O\",\"X\",\"O\",\"X\",\"O\",\"X\",\"O\"],\n        [\"X\",\"O\",\"X\",\"O\",\"X\",\"O\",\"X\"],\n        [\"O\",\"X\",\"O\",\"X\",\"O\",\"X\",\"O\"]\n    ]\n\nThe white spaces should be represented by an: `'O'`\n\nand the black an: `'X'`\n\nThe first row should always start with a white space `'O'`", "solutions": ["def chess_board(rows, columns):\n    return [['OX'[(row + col) % 2] for col in range(columns)] for row in range(rows)]", "def chess_board(rows, columns):\n    ans = []\n    for i in range(1, rows + 1, 1):\n        l = []\n        for j in range(i, columns + i, 1):\n            if j % 2 != 0:\n                l.append('O')\n            else:\n                l.append('X')\n        ans.append(l)\n    return ans", "chess_board = lambda rows, cols: [['X' if (y + x) % 2 else 'O' for x in range(cols)] for y in range(rows)]", "chess_board = lambda r, c: [['OX'[i + j & 1] for i in range(c)] for j in range(r)]", "def chess_board(rows, columns):\n    board = []\n    for row in range(rows):\n        if row % 2:\n            board.append(['X' if not column % 2 else 'O' for column in range(columns)])\n        else:\n            board.append(['O' if not column % 2 else 'X' for column in range(columns)])\n    return board", "def chess_board(a, b):\n    return [list('OXXO'[i % 2::2] * (b // 2 + 1))[:b] for i in range(a)]", "from itertools import cycle\n\ndef chess_board(rows, columns):\n    result = []\n    for i in range(rows):\n        grida = cycle(['O', 'X'])\n        gridb = cycle(['X', 'O'])\n        result.append([next(gridb) if i % 2 else next(grida) for x in range(columns)])\n    return result", "def chess_board(rows, columns):\n    return [['OX'[(row + column) % 2] for column in range(columns)] for row in range(rows)]", "def chess_board(rows, columns):\n    line = ['X', 'O'] * columns\n    return [line[:columns] if r % 2 else line[1:columns + 1] for r in range(rows)]", "chess_board = lambda r, c: [['OX'[(i + j) % 2] for j in range(c)] for i in range(r)]"], "starter_code": "def chess_board(rows, columns):\n", "input_output": {"fn_name": "chess_board", "inputs": [[1, 1], [1, 2], [2, 1], [2, 2], [6, 6]], "outputs": [[[["O"]]], [[["O", "X"]]], [[["O"], ["X"]]], [[["O", "X"], ["X", "O"]]], [[["O", "X", "O", "X", "O", "X"], ["X", "O", "X", "O", "X", "O"], ["O", "X", "O", "X", "O", "X"], ["X", "O", "X", "O", "X", "O"], ["O", "X", "O", "X", "O", "X"], ["X", "O", "X", "O", "X", "O"]]]]}, "difficulty": "EASY", "raw_tags": ["ASCII Art", "Algorithms", "Fundamentals", "Puzzles"], "name": null, "source": "codewars", "tags": ["String algorithms", "Fundamentals", "Ad-hoc"], "skill_types": [], "url": "https://www.codewars.com/kata/56242b89689c35449b000059", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "chess_board", "task_id": "TACO_lite/31"}
{"requirement": "## Task\n\nWrite a function that accepts two arguments and generates a sequence containing the integers from the first argument to the second inclusive. \n\n## Input\n\nPair of integers greater than or equal to `0`. The second argument will always be greater than or equal to the first. \n\n## Example\n\n```python\ngenerate_integers(2, 5) # --> [2, 3, 4, 5]\n```", "solutions": ["def generate_integers(m, n):\n    return list(range(m, n + 1))", "def generate_integers(m, n):\n    return [i for i in range(m, n + 1)]", "def generate_integers(m, n):\n    ans = []\n    for each in range(m, n + 1):\n        ans.append(each)\n    return ans", "def generate_integers(m, n):\n    return [_ for _ in range(m, n + 1)]", "def generate_integers(m, n):\n    return [num for num in range(m, n + 1)]", "def generate_integers(m, n):\n    c = []\n    for i in range(m, n + 1):\n        c.append(i)\n    return c", "def generate_integers(m, n):\n    numeros = []\n    for x in range(m, n + 1):\n        numeros.append(x)\n    return numeros\n    pass", "def generate_integers(m, n):\n    nums = list()\n    while m <= n:\n        nums.append(m)\n        m += 1\n    return nums", "def generate_integers(m, n):\n    list = []\n    for x in (m, n):\n        while m <= x <= n:\n            x = x + 1\n            list.append(x - 1)\n        return list"], "starter_code": "def generate_integers(m, n):\n", "input_output": {"fn_name": "generate_integers", "inputs": [[2, 5]], "outputs": [[[2, 3, 4, 5]]]}, "difficulty": "EASY", "raw_tags": [], "name": null, "source": "codewars", "tags": [], "skill_types": [], "url": "https://www.codewars.com/kata/5841f680c5c9b092950001ae", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "generate_integers", "task_id": "TACO_lite/32"}
{"requirement": "You're in ancient Greece and giving Philoctetes a hand in preparing a training exercise for Hercules! You've filled a pit with two different ferocious mythical creatures for Hercules to battle!\n\nThe formidable **\"Orthus\"** is a 2 headed dog with 1 tail.  The mighty **\"Hydra\"** has 5 heads and 1 tail. \n\nBefore Hercules goes in, he asks you \"How many of each beast am  I up against!?\".\n\nYou know the total number of heads and the total number of tails, that's the dangerous parts, right? But you didn't consider how many of each beast. \n\n## Task\n\nGiven the number of heads and the number of tails, work out the number of each mythical beast! \n\nThe data is given as two parameters. Your answer should be returned as an array:\n```python \n VALID ->      [24 , 15]           INVALID ->  \"No solutions\"\n```\n\nIf there aren't any cases for the given amount of heads and tails - return \"No solutions\" or null (C#).", "solutions": ["def beasts(heads, tails):\n    orthus = (5 * tails - heads) / 3\n    hydra = tails - orthus\n    return [orthus, hydra] if orthus >= 0 and hydra >= 0 else 'No solutions'", "def beasts(h, t):\n    out = [(5 * t - h) / 3, (h - 2 * t) / 3]\n    return all((x.is_integer() and x >= 0 for x in out)) and out or 'No solutions'", "def beasts(heads, tails):\n    if heads not in range(tails * 2, tails * 5 + 1, 3):\n        return 'No solutions'\n    return [(tails * 5 - heads) / 3, (heads - tails * 2) / 3]", "def beasts(heads, tails):\n    extraheads = heads - 2 * tails\n    if extraheads % 3 != 0 or not 0 <= extraheads <= 3 * tails:\n        return 'No solutions'\n    hydra = extraheads // 3\n    orthus = tails - hydra\n    return [orthus, hydra]", "def beasts(heads, tails):\n    h = (heads - tails * 2) / 3\n    if h < 0 or tails - h < 0:\n        return 'No solutions'\n    return [tails - h, h]", "beasts = lambda h, t: (lambda m: [t - m, m] if m >= 0 and m <= t and (m % 1 == 0) else 'No solutions')((h - t * 2) / 3.0)", "def beasts(h, t):\n    (O, H) = (5 * t - h, h - 2 * t)\n    if O >= O % 3 >= 0 <= H % 3 <= H:\n        return [O // 3, H // 3]\n    else:\n        return 'No solutions'", "def beasts(heads, tails):\n    for orthus in range(heads // 2 + 1):\n        if orthus * 2 + (tails - orthus) * 5 == heads:\n            return [orthus, tails - orthus]\n    return 'No solutions'", "def beasts(heads, tails):\n    o = (5 * tails - heads) / 3\n    h = (heads - 2 * tails) / 3\n    if o == int(o) and h == int(h) and (o >= 0) and (h >= 0):\n        return [int(o), int(h)]\n    else:\n        return 'No solutions'", "def beasts(heads, tails):\n    hydra = (heads - 2 * tails) / 3\n    orthus = tails - (heads - 2 * tails) / 3\n    if hydra % 1 == 0 and hydra >= 0 and (orthus % 1 == 0) and (orthus >= 0):\n        return [orthus, hydra]\n    else:\n        return f'No solutions'"], "starter_code": "def beasts(heads, tails):\n", "input_output": {"fn_name": "beasts", "inputs": [[123, 39], [371, 88], [24, 12], [113, 37], [635, 181], [25, 555], [12, 25], [54, 956], [5455, 54956], [0, 0], [-1, -1], [-45, 5], [99, 0], [0, 99], [5, -55]], "outputs": [[[24, 15]], [[23, 65]], [[12, 0]], [[24, 13]], [[90, 91]], ["No solutions"], ["No solutions"], ["No solutions"], ["No solutions"], [[0, 0]], ["No solutions"], ["No solutions"], ["No solutions"], ["No solutions"], ["No solutions"]]}, "difficulty": "EASY", "raw_tags": ["Mathematics", "Fundamentals"], "name": null, "source": "codewars", "tags": ["Fundamentals", "Mathematics"], "skill_types": [], "url": "https://www.codewars.com/kata/5751aa92f2dac7695d000fb0", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "beasts", "task_id": "TACO_lite/33"}
{"requirement": "Given a Binary Tree, print the diagonal traversal of the binary tree.\nConsider lines of slope -1 passing between nodes. Given a Binary Tree, print all diagonal elements in a binary tree belonging to same line.\nIf the diagonal element are present in two different subtress then left subtree diagonal element should be taken first and then right subtree. \nExample 1:\nInput :\n            8\n         /     \\\n        3      10\n      /   \\      \\\n     1     6     14\n         /   \\   /\n        4     7 13\nOutput : 8 10 14 3 6 7 13 1 4\nExplanation:\nDiagonal Traversal of binary tree : \n 8 10 14 3 6 7 13 1 4\nYour Task:\nYou don't need to read input or print anything. The task is to complete the function diagonal() that takes the root node as input argumets and returns the diagonal traversal of the given tree.\nExpected Time Complexity: O(N).\nExpected Auxiliary Space: O(N).\nHere N is number of nodes.\nConstraints:\n1 <= Number of nodes<= 10^{5}\n1 <= Data of a node<= 10^{5}", "solutions": ["def diagonal(root):\n    if root is None:\n        return\n    out = []\n    node = root\n    left_q = deque()\n    while node:\n        out.append(node.data)\n        if node.left:\n            left_q.appendleft(node.left)\n        if node.right:\n            node = node.right\n        elif len(left_q) >= 1:\n            node = left_q.pop()\n        else:\n            node = None\n    return out", "def diagonal(root):\n    q = []\n    ans = []\n    q.append(root)\n    while q:\n        a = q.pop(0)\n        ans.append(a.data)\n        if a.left:\n            q.append(a.left)\n        while a.right:\n            ans.append(a.right.data)\n            if a.right.left:\n                q.append(a.right.left)\n            a = a.right\n    return ans", "from collections import defaultdict\n\ndef diagonal(root):\n    ans = []\n    d = defaultdict(list)\n\n    def solve(root, l):\n        if root.left == None and root.right == None:\n            d[l].append(root.data)\n            return\n        if root.left:\n            solve(root.left, l - 1)\n        d[l].append(root.data)\n        if root.right:\n            solve(root.right, l)\n    if root == None:\n        return []\n    solve(root, 0)\n    l = []\n    for i in d.keys():\n        l.append(i)\n    l.sort(reverse=-1)\n    for i in l:\n        ans.extend(d[i])\n    return ans", "from collections import deque\n\ndef diagonal(root):\n    q = deque()\n    q.append(root)\n    ans = []\n    while q:\n        x = q.popleft()\n        while x is not None:\n            if x.left:\n                q.append(x.left)\n            ans.append(x.data)\n            x = x.right\n    return ans", "def diagonal(root):\n    vis = []\n    n = root\n    q = deque()\n    while n:\n        vis.append(n.data)\n        if n.left:\n            q.appendleft(n.left)\n        if n.right:\n            n = n.right\n        elif len(q) >= 1:\n            n = q.pop()\n        else:\n            n = None\n    return vis", "def diagonal(root):\n    res = []\n    q = []\n    q.append(root)\n\n    def traverse(node):\n        if node != None:\n            res.append(node.data)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                traverse(node.right)\n    while q != []:\n        x = q.pop(0)\n        traverse(x)\n    return res", "from collections import defaultdict\n\ndef diagonal(root):\n    d = defaultdict(list)\n\n    def sol(root, i):\n        if root.left == None and root.right == None:\n            d[i].append(root.data)\n            return\n        d[i].append(root.data)\n        if root.left:\n            left = sol(root.left, i - 1)\n        if root.right:\n            right = sol(root.right, i)\n    sol(root, 0)\n    r = []\n    for j in sorted(d.keys(), reverse=True):\n        r.extend(d[j])\n    return r", "def diagonal(root):\n\n    def dig(root):\n        if root is None:\n            return []\n        l1 = []\n        q = []\n        q = [root]\n        while q:\n            node = q.pop(0)\n            while node:\n                l1.append(node.data)\n                if node.left:\n                    q.append(node.left)\n                node = node.right\n        return l1\n    return dig(root)", "from collections import defaultdict\n\ndef diagonal(root):\n    d = defaultdict(list)\n\n    def solve(root, idx):\n        if root.left == None and root.right == None:\n            d[idx].append(root.data)\n            return\n        d[idx].append(root.data)\n        if root.left:\n            left = solve(root.left, idx - 1)\n        if root.right:\n            right = solve(root.right, idx)\n    solve(root, 0)\n    res = []\n    for i in sorted(d.keys(), reverse=True):\n        res.extend(d[i])\n    return res", "def diagonal(root):\n    d = {}\n\n    def traverse(root, tag):\n        if root != []:\n            if tag in d:\n                d[tag].append(root.data)\n            else:\n                d[tag] = [root.data]\n            if root.left:\n                traverse(root.left, tag - 1)\n            if root.right:\n                traverse(root.right, tag)\n    traverse(root, 0)\n    k = sorted(d.items(), key=lambda x: -x[0])\n    ans = []\n    for (i, j) in k:\n        ans.extend(j)\n    return ans", "def diagonal_traversal_helper(node, level, diagonal_map):\n    if node is None:\n        return\n    if level in diagonal_map:\n        diagonal_map[level].append(node.data)\n    else:\n        diagonal_map[level] = [node.data]\n    diagonal_traversal_helper(node.left, level + 1, diagonal_map)\n    diagonal_traversal_helper(node.right, level, diagonal_map)\n\ndef diagonal(root):\n    diagonal_map = {}\n    diagonal_traversal_helper(root, 0, diagonal_map)\n    result = []\n    for level in diagonal_map:\n        result.extend(diagonal_map[level])\n    return result", "def diagonal(root):\n    q = []\n    a = []\n    if root == None:\n        return\n    q.append(root)\n    while len(q) != 0:\n        n = q[0]\n        q.pop(0)\n        while n:\n            if n.left:\n                q.append(n.left)\n            a.append(n.data)\n            n = n.right\n    return a", "from collections import defaultdict\n\ndef diagonal(root):\n    ans = []\n    d = defaultdict(list)\n\n    def dfs(x, l):\n        d[l].append(x.data)\n        if x.left:\n            dfs(x.left, l + 1)\n        if x.right:\n            dfs(x.right, l)\n    dfs(root, 0)\n    ans = []\n    for x in d:\n        ans.extend(d[x])\n    return ans", "def diagonal(root):\n    if root == None:\n        return []\n    q = [root]\n    tmp = []\n    ans = []\n    while q:\n        nod = q.pop(0)\n        while nod:\n            ans.append(nod.data)\n            if nod.left:\n                tmp.append(nod.left)\n            nod = nod.right\n        if len(q) == 0:\n            while tmp:\n                q.append(tmp.pop(0))\n    return ans", "def diagonal(root):\n    q = deque()\n    q.append(root)\n    ans = []\n    while len(q) >= 1:\n        x = q.popleft()\n        while x is not None:\n            if x.left is not None:\n                q.append(x.left)\n            ans.append(x.data)\n            x = x.right\n    return ans", "def util(root, a):\n    global d\n    if root == None:\n        return\n    if d.get(a) == None:\n        d[a] = [root.data]\n    else:\n        d[a].append(root.data)\n    self.util(root.left, a - 1)\n    self.util(root.right, a)\n\ndef diagonal(root):\n    global d\n    d = {}\n    self.util(root, 0)\n    ans = []\n    for (k, v) in sorted(d.items(), reverse=True):\n        for i in v:\n            ans.append(i)\n    return ans", "from collections import deque\n\ndef diagonal(root):\n    queue = deque()\n    ans = []\n    queue.append(root)\n    if root is None:\n        return ans\n    while queue:\n        temp = queue.popleft()\n        while temp:\n            if temp.left:\n                queue.append(temp.left)\n            ans.append(temp.data)\n            temp = temp.right\n    return ans", "from collections import deque\n\ndef diagonal(root):\n    hashmap = {}\n\n    def solve(root, index):\n        if root is None:\n            return\n        if index in hashmap:\n            hashmap[index].append(root.data)\n        else:\n            hashmap[index] = [root.data]\n        if root.left is not None:\n            solve(root.left, index + 1)\n        if root.right is not None:\n            solve(root.right, index)\n    solve(root, 0)\n    ans = []\n    for i in sorted(hashmap.keys()):\n        ans += hashmap[i]\n    return ans", "def diagonal(root):\n    q = []\n    res = []\n    q.append(root)\n    while len(q) > 0:\n        p = q.pop(0)\n        res.append(p.data)\n        while p:\n            if p.right != None:\n                res.append(p.right.data)\n            if p.left != None:\n                q.append(p.left)\n            p = p.right\n    return res", "from collections import defaultdict\n\ndef diagonal(root):\n    ans = []\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        while node:\n            ans.append(node.data)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                node = node.right\n            else:\n                break\n    return ans", "def diagonal(root):\n    if root == None:\n        return []\n    queue = []\n    queue.append(root)\n    ans = []\n    while queue:\n        temp = queue.pop(0)\n        while temp:\n            ans.append(temp.data)\n            if temp.left != None:\n                queue.append(temp.left)\n            if temp.right:\n                temp = temp.right\n            else:\n                break\n    return ans", "def diagonal(root):\n    result = list()\n    node = root\n    left_q = deque()\n    while node:\n        result.append(node.data)\n        if node.left:\n            left_q.appendleft(node.left)\n        if node.right:\n            node = node.right\n        else:\n            node = left_q.pop() if len(left_q) >= 1 else None\n    return result", "from collections import deque\n\ndef diagonal(root):\n    res = []\n    q = deque()\n    q.append(root)\n    while len(q):\n        p = q.popleft()\n        res.append(p.data)\n        while p:\n            if p.left:\n                q.append(p.left)\n            if p.right:\n                res.append(p.right.data)\n            p = p.right\n    return res", "from collections import *\n\ndef __init__():\n    self.d = {}\n\ndef diagonal(root):\n    q = deque()\n    q.append([root, 0, 0])\n    while q:\n        (v, x, y) = q.pop()\n        if y - x in self.d:\n            self.d[y - x].append(v.data)\n        else:\n            self.d[y - x] = [v.data]\n        if v.right:\n            q.append([v.right, x + 1, y + 1])\n        if v.left:\n            q.append([v.left, x - 1, y + 1])\n    answer = []\n    for i in sorted(self.d):\n        answer.extend(self.d[i])\n    return answer", "def diagonal(root):\n\n    def diagnolView(root, dict, level):\n        if root is None:\n            return\n        if level not in dict:\n            dict[level] = [root.data]\n        else:\n            dict[level].append(root.data)\n        diagnolView(root.left, dict, level + 1)\n        diagnolView(root.right, dict, level)\n    dict = {}\n    diagnolView(root, dict, 0)\n    arr = []\n    for i in dict:\n        arr += dict[i]\n    return arr", "def rec_sol(root, d, save_dict):\n    try:\n        save_dict[d].append(root.data)\n    except:\n        save_dict[d] = [root.data]\n    if root.left != None:\n        self.rec_sol(root.left, d + 1, save_dict)\n    if root.right != None:\n        self.rec_sol(root.right, d, save_dict)\n    return\n\ndef diagonal(root):\n    save_dict = {}\n    self.rec_sol(root, 0, save_dict)\n    final = []\n    for i in save_dict:\n        for el in save_dict[i]:\n            final.append(el)\n    return final", "def diagonal(root):\n    s = []\n    ans = []\n    s.append(root)\n    while len(s) != 0:\n        size = len(s)\n        while size != 0:\n            rn = s.pop(0)\n            while rn != None:\n                ans.append(rn.data)\n                if rn.left != None:\n                    s.append(rn.left)\n                rn = rn.right\n            size -= 1\n    return ans", "def diagonal(root):\n    queue = []\n    l = []\n    queue.append(root)\n    while len(queue) > 0:\n        temp = queue.pop(0)\n        while temp:\n            if temp.left:\n                queue.append(temp.left)\n            l.append(temp.data)\n            temp = temp.right\n    return l", "def diagonal(root):\n    q = deque([root])\n    res = []\n    while q:\n        temp = q.popleft()\n        while temp:\n            res.append(temp.data)\n            if temp.left:\n                q.append(temp.left)\n            temp = temp.right\n    return res", "def diagonal(root):\n    ans = []\n    q = deque([])\n    q.append(root)\n    while q:\n        n = len(q)\n        for _ in range(len(q)):\n            d = q.popleft()\n            ans.append(d.data)\n            if d.left:\n                q.append(d.left)\n            while d.right:\n                d = d.right\n                ans.append(d.data)\n                if d.left:\n                    q.append(d.left)\n    return ans", "def diagonal(root):\n\n    def helper(root, dic, diagonal):\n        if root == None:\n            return\n        if diagonal in dic:\n            dic[diagonal].append(root.data)\n        else:\n            dic[diagonal] = [root.data]\n        helper(root.left, dic, diagonal + 1)\n        helper(root.right, dic, diagonal)\n        return dic\n    if not root:\n        return\n    dic = {}\n    dic = helper(root, dic, 0)\n    l = list(dic.keys())\n    l.sort()\n    res = []\n    for k in l:\n        res += dic[k]\n    return res", "from queue import LifoQueue\nfrom collections import defaultdict\n\ndef pre_order(root, level, diagonals):\n    diagonals[level].append(root.data)\n    if root.left:\n        pre_order(root.left, level + 1, diagonals)\n    if root.right:\n        pre_order(root.right, level, diagonals)\n\ndef diagonal(root):\n    diagonals_map = defaultdict(list)\n    output = []\n    pre_order(root, 0, diagonals_map)\n    for level in diagonals_map:\n        output.extend(diagonals_map[level])\n    return output", "def diagonal(root):\n    if not root:\n        return []\n    q = [root]\n    res = []\n    while q:\n        curr = q.pop(0)\n        while curr:\n            res.append(curr.data)\n            if curr.left:\n                q.append(curr.left)\n            curr = curr.right\n    return res", "def diagonal(root):\n\n    def find(root, dig, dict):\n        if root is None:\n            return\n        if dig not in dict:\n            dict[dig] = []\n        dict[dig].append(root.data)\n        find(root.left, dig + 1, dict)\n        find(root.right, dig, dict)\n    ans = []\n    dict = {}\n    find(root, 0, dict)\n    for dig in dict:\n        for num in dict[dig]:\n            ans.append(num)\n    return ans", "def diagonal(root):\n    if not root:\n        return []\n    q = deque([root])\n    res = []\n    while q:\n        for i in range(len(q)):\n            curr = q.popleft()\n            while curr:\n                res.append(curr.data)\n                if curr.left:\n                    q.append(curr.left)\n                curr = curr.right\n    return res", "def diagonal(root):\n    if root == None:\n        return []\n    ans = []\n    q = []\n    q.append(root)\n    while len(q) != 0:\n        s = len(q)\n        while s != 0:\n            curr = q.pop(0)\n            while curr != None:\n                ans.append(curr.data)\n                if curr.left != None:\n                    q.append(curr.left)\n                if curr.right != None:\n                    curr = curr.right\n                else:\n                    break\n            s -= 1\n    return ans", "from collections import deque\n\ndef diagonal(root):\n    q = deque()\n    q.append(root)\n    ans = []\n    while q:\n        curr = q.popleft()\n        while curr:\n            ans.append(curr.data)\n            if curr.left:\n                q.append(curr.left)\n            curr = curr.right\n    return ans", "def diagonal(root):\n    l = []\n    queue = [root]\n    while len(queue) > 0:\n        s = len(queue)\n        while s > 0:\n            node = queue.pop(0)\n            while node != None:\n                l.append(node.data)\n                if node.left:\n                    queue.append(node.left)\n                node = node.right\n            s -= 1\n    return l", "def diagonal(root):\n    ans = []\n    Q = [root]\n    s = 1\n    while Q != []:\n        m = 0\n        while s:\n            a = Q.pop(0)\n            while a:\n                if a.left:\n                    Q.append(a.left)\n                    m += 1\n                ans.append(a.data)\n                a = a.right\n            s -= 1\n        s = m\n    return ans", "def diagonal(root):\n    q = [root]\n    ans = []\n    while q:\n        l = len(q)\n        for i in range(l):\n            root = q.pop(0)\n            temp = root\n            while temp:\n                ans.append(temp.data)\n                if temp.left:\n                    q.append(temp.left)\n                temp = temp.right\n    return ans", "def diagonal(root):\n    q = []\n    ans = []\n    if root is None:\n        return ans\n    q.append(root)\n    while q:\n        temp = q.pop(0)\n        while temp:\n            if temp.left:\n                q.append(temp.left)\n            ans.append(temp.data)\n            temp = temp.right\n    return ans", "def diagonal(root):\n    arr = [root]\n    ans = []\n    while len(arr) > 0:\n        temp = arr.pop(0)\n        while temp is not None:\n            if temp.left:\n                arr.append(temp.left)\n            ans.append(temp.data)\n            temp = temp.right\n    return ans", "def diagonal(root):\n    q = [root]\n    (temp, res) = ([], [])\n    while q:\n        node = q.pop(0)\n        res.append(node.data)\n        if node.left:\n            temp.append(node.left)\n        if node.right:\n            q.append(node.right)\n        if not q and temp:\n            q.append(temp.pop(0))\n    return res", "def diagonal(root):\n    if not root:\n        return\n    (queue, result) = ([], [])\n    queue.append(root)\n    while len(queue) > 0:\n        n = len(queue)\n        ans = []\n        while n > 0:\n            temp = queue[0]\n            queue.pop(0)\n            while temp is not None:\n                ans.append(temp.data)\n                if temp.left is not None:\n                    queue.append(temp.left)\n                temp = temp.right\n            n -= 1\n        result.append(' '.join(map(str, ans)))\n    return result", "from collections import defaultdict\n\ndef diagonal(root):\n    if root is None:\n        return []\n    dict1 = defaultdict(list)\n    q = [(root, 0)]\n    while len(q):\n        for i in range(len(q)):\n            (s, d) = q.pop()\n            if s.right:\n                q.append((s.right, d))\n            if s.left:\n                q.append((s.left, d + 1))\n            dict1[d].append(s.data)\n    res = []\n    for i in sorted(dict1):\n        res.extend(dict1[i])\n    return res", "def diagonal(root):\n    if not root:\n        return []\n    ans = []\n    q = [root]\n    while len(q) > 0:\n        node = q.pop(0)\n        while node:\n            if node.left:\n                q.append(node.left)\n            ans.append(node.data)\n            node = node.right\n    return ans", "def diagonal(root):\n    queue = []\n    queue.append(root)\n    ans = []\n\n    def dfs(root):\n        if root == None:\n            return\n        ans.append(root.data)\n        if root.left:\n            queue.append(root.left)\n        if root.right:\n            dfs(root.right)\n    while len(queue) != 0:\n        root = queue.pop(0)\n        dfs(root)\n    return ans", "from collections import deque\n\ndef diagonal(root):\n    ans = []\n    q = deque()\n    new_node = Node(0)\n    new_node.left = root\n    q.append(new_node)\n    while len(q) > 0:\n        node = q.popleft()\n        node = node.left\n        while node is not None:\n            ans.append(node.data)\n            if node.left is not None:\n                q.append(node)\n            node = node.right\n    return ans", "from collections import deque\n\ndef diagonal(root):\n    q = deque()\n    if root is None:\n        return []\n    q.appendleft(root)\n    res = []\n    while len(q) > 0:\n        t = q.pop()\n        while t is not None:\n            res.append(t.data)\n            if t.left is not None:\n                q.appendleft(t.left)\n            t = t.right\n    return res", "def diagonal(root):\n    queue = []\n    ans = []\n    queue.append(root)\n    while queue:\n        curr = queue.pop(0)\n        while curr:\n            if curr.left:\n                queue.append(curr.left)\n            ans.append(curr.data)\n            curr = curr.right\n    return ans", "def diagonal(root):\n    result = []\n    if root == None:\n        return result\n    q = deque()\n    q.append(root)\n    while len(q) != 0:\n        current = q.popleft()\n        while current:\n            result.append(current.data)\n            if current.left:\n                q.append(current.left)\n            current = current.right\n    return result", "import collections\n\ndef diagonal(root):\n    res = []\n    q = collections.deque()\n    q.append(root)\n    while q:\n        a = q.popleft()\n        res.append(a.data)\n        if a.left:\n            q.append(a.left)\n        t = a.right\n        if t:\n            res.append(t.data)\n        while t:\n            if t.left:\n                q.append(t.left)\n            if t.right:\n                res.append(t.right.data)\n            t = t.right\n    return res", "def diagonal(root):\n\n    def diag(root, x, d):\n        if root is None:\n            return\n        try:\n            d[x].append(root.data)\n        except KeyError:\n            d[x] = [root.data]\n        diag(root.left, x + 1, d)\n        diag(root.right, x, d)\n    d = dict()\n    a = []\n    diag(root, 0, d)\n    for i in d:\n        for j in d[i]:\n            a.append(j)\n    return a", "import collections\n\ndef dfs(node):\n    if not node:\n        return\n    self.diag_lst.append(node.data)\n    if node.left:\n        self.q.append(node.left)\n    self.dfs(node.right)\n    return\n\ndef diagonal(root):\n    self.q = collections.deque()\n    self.diag_lst = []\n    self.q.append(root)\n    while self.q:\n        self.dfs(self.q.popleft())\n    return self.diag_lst", "def diagonal(root):\n    right = []\n    res = []\n    q = [root]\n    while q or right:\n        if q:\n            x = q.pop(0)\n        else:\n            x = right.pop(0)\n        if x.right:\n            q.append(x.right)\n        if x.left:\n            right.append(x.left)\n        res.append(x)\n    for i in range(len(res)):\n        res[i] = res[i].data\n    return res", "def diagonal(root):\n    temp = []\n    result = []\n\n    def trav(root):\n        if root == None:\n            return\n        result.append(root.data)\n        if root.left != None:\n            temp.append(root.left)\n        if root.right == None:\n            if len(temp) == 0:\n                return\n            x = temp.pop(0)\n            trav(x)\n        else:\n            trav(root.right)\n    trav(root)\n    return result", "def diagonal(root):\n    if root is None:\n        return\n    level = []\n    ansArr = []\n    while root:\n        ansArr.append(root.data)\n        if root.left:\n            level.append(root.left)\n        if root.right:\n            root = root.right\n        else:\n            if not level:\n                break\n            root = level.pop(0)\n    return ansArr", "def diagonal(root):\n    q = deque()\n    q.append(root)\n    ans = []\n    while len(q) > 0:\n        curr = q.popleft()\n        while curr is not None:\n            ans.append(curr.data)\n            if curr.left is not None:\n                q.append(curr.left)\n            curr = curr.right\n    return ans", "def diagonal(root):\n    ans = []\n    if root is None:\n        return ans\n    import collections\n    queue = collections.deque()\n    queue.append(root)\n    while len(queue) != 0:\n        curr = queue.popleft()\n        while curr is not None:\n            ans.append(curr.data)\n            if curr.left != None:\n                queue.append(curr.left)\n            curr = curr.right\n    return ans", "def diagonal(root):\n    traverse_queue = [root]\n    final_result = []\n    while len(traverse_queue) > 0:\n        node_pop = traverse_queue.pop(0)\n        final_result.append(node_pop.data)\n        curr = node_pop\n        while curr is not None:\n            if curr.left is not None:\n                traverse_queue.append(curr.left)\n            curr = curr.right\n            if curr is not None:\n                final_result.append(curr.data)\n    return final_result"], "starter_code": "def _init_(val):\n", "input_output": {"inputs": ["8\r\n         /     \\\r\n        3      10\r\n      /   \\      \\\r\n     1     6     14\r\n         /   \\   /\r\n        4     7 13"], "outputs": ["8 10 14 3 6 7 13 1 4"]}, "difficulty": "MEDIUM", "raw_tags": ["Data Structures", "Tree"], "name": null, "source": "geeksforgeeks", "tags": ["Tree algorithms", "Data structures"], "skill_types": ["Data structures"], "url": "https://practice.geeksforgeeks.org/problems/diagonal-traversal-of-binary-tree/1", "Expected Auxiliary Space": "O(N).", "time_limit": null, "date": null, "picture_num": "1", "memory_limit": null, "Expected Time Complexity": "O(N).", "entry_point": "_init_", "task_id": "TACO_lite/34"}
{"requirement": "Given an array of numbers, return an array, with each member of input array rounded to a nearest number, divisible by 5.\n\nFor example:\n```\nroundToFive([34.5, 56.2, 11, 13]);\n```\nshould return\n```\n[35, 55, 10, 15]\n```\n\n```if:python\nRoundings have to be done like \"in real life\": `22.5 -> 25`\n```", "solutions": ["from decimal import Decimal, ROUND_HALF_UP\n\ndef round_to_five(numbers):\n    return [(n / 5).quantize(1, ROUND_HALF_UP) * 5 for n in map(Decimal, numbers)]", "def round_to_five(numbers):\n    return [5 * int(x / 5 + 0.5) for x in numbers]", "def round_to_five(numbers):\n    return [int((n + 2.5) / 5) * 5 for n in numbers]", "round_to_five = lambda l: [round((0.01 + n) / 5) * 5 for n in l]", "def round_to_five(numbers):\n    return [int((x // 5 + (x % 5 >= 2.5)) * 5) for x in numbers]", "def round_to_five(arr):\n    return [5 * round(v / 5 + 0.01) for v in arr]", "import math\n\ndef round_to_five(numbers):\n    output = []\n    for n in numbers:\n        if n % 5 == 0:\n            output.append(int(n))\n        elif n % 10 < 5 and n % 5 < 2.5 or (n % 10 > 5 and n % 5 >= 2.5):\n            output.append(int(round(n, -1)))\n        elif n % 10 < 5 and n % 5 >= 2.5:\n            output.append(int(round(n, -1) + 5))\n        else:\n            output.append(int(round(n, -1) - 5))\n    return output", "from math import floor, ceil\n\ndef rond(x):\n    return floor(x) if x % 1 < 0.5 else ceil(x)\n\ndef round_to_five(numbers):\n    return [rond(x / 5) * 5 for x in numbers]", "def rounding(n):\n    intPart = int(n)\n    fracPart = n - intPart\n    if fracPart >= 0.5:\n        n = intPart + 1\n    else:\n        n = intPart\n    for i in range(6):\n        up = n + i\n        down = n - i\n        if up % 5 == 0:\n            return up\n        elif down % 5 == 0:\n            return down\n\ndef round_to_five(numbers):\n    numbers = [rounding(n) for n in numbers]\n    return numbers"], "starter_code": "def round_to_five(numbers):\n", "input_output": {"fn_name": "round_to_five", "inputs": [[[1, 5, 87, 45, 8, 8]], [[3, 56.2, 11, 13]], [[22.5, 544.9, 77.5]]], "outputs": [[[0, 5, 85, 45, 10, 10]], [[5, 55, 10, 15]], [[25, 545, 80]]]}, "difficulty": "EASY", "raw_tags": ["Algorithms"], "name": null, "source": "codewars", "tags": [], "skill_types": [], "url": "https://www.codewars.com/kata/582f52208278c6be55000067", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "round_to_five", "task_id": "TACO_lite/35"}
{"requirement": "Given an array of integers nums, write a method that returns the \"pivot\" index of this array.\n\nWe define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.\n\nIf no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\n\n\nExample 1:\n\nInput: \nnums = [1, 7, 3, 6, 5, 6]\nOutput: 3\nExplanation: \nThe sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.\nAlso, 3 is the first index where this occurs.\n\n\n\nExample 2:\n\nInput: \nnums = [1, 2, 3]\nOutput: -1\nExplanation: \nThere is no index that satisfies the conditions in the problem statement.\n\n\n\nNote:\nThe length of nums will be in the range [0, 10000].\nEach element nums[i] will be an integer in the range [-1000, 1000].", "solutions": ["def pivotindex(nums):\n    (left, right) = (0, sum(nums))\n    for (index, num) in enumerate(nums):\n        right -= num\n        if left == right:\n            return index\n        left += num\n    return -1", "def pivotindex(nums):\n    if len(nums) == 0:\n        return -1\n    leftSum = sum(nums)\n    rightSum = 0\n    for i in range(len(nums)):\n        leftSum = leftSum - nums[i]\n        if rightSum == leftSum:\n            return i\n        rightSum = rightSum + nums[i]\n    return -1", "def pivotindex(nums):\n    ret = sum(nums)\n    left = 0\n    for (k, v) in enumerate(nums):\n        if left * 2 + v == ret:\n            return k\n        left += v\n    return -1", "def pivotindex(nums):\n    left_sum = 0\n    right_sum = sum(nums)\n    for index in range(0, len(nums)):\n        right_sum -= nums[index]\n        if left_sum == right_sum:\n            return index\n        left_sum += nums[index]\n    return -1", "def pivotindex(nums):\n    n = sum(nums)\n    sum_num = n\n    for i in range(len(nums)):\n        n -= nums[i]\n        if (sum_num - nums[i]) / 2 == n:\n            return i\n    return -1", "def pivotindex(nums):\n    if len(nums) == 0:\n        return -1\n    if len(nums) == 1:\n        return nums[0]\n    left = 0\n    right = 0\n    for i in range(1, len(nums)):\n        right += nums[i]\n    if left == right:\n        return 0\n    for i in range(1, len(nums)):\n        left += nums[i - 1]\n        right -= nums[i]\n        if left == right:\n            return i\n    return -1", "def pivotindex(nums):\n    if nums == []:\n        return -1\n    sum = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n    if nums[0] == sum:\n        return 0\n    left_sum = 0\n    for i in range(len(nums) - 1):\n        left_sum += nums[i]\n        if left_sum * 2 == sum - nums[i + 1]:\n            return i + 1\n    if nums[len(nums) - 1] == sum:\n        return len(nums) - 1\n    return -1", "def pivotindex(nums):\n    l = len(nums)\n    if l < 3:\n        return -1\n    s = [0] * l\n    s[0] = nums[0]\n    for i in range(1, l):\n        s[i] = s[i - 1] + nums[i]\n    d = [0] * l\n    d[l - 1] = nums[l - 1]\n    for j in range(l - 2, -1, -1):\n        d[j] = d[j + 1] + nums[j]\n    for i in range(0, l):\n        if s[i] == d[i]:\n            return i\n    return -1"], "starter_code": "def pivotindex(nums: List[int]) -> int:\n", "input_output": {"fn_name": "pivotIndex", "inputs": [[[1, 7, 3, 6, 5, 6]]], "outputs": [3]}, "difficulty": "EASY", "raw_tags": ["Prefix Sum", "Array"], "name": null, "source": "leetcode", "tags": ["Data structures", "Range queries"], "skill_types": ["Data structures", "Range queries"], "url": "https://leetcode.com/problems/find-pivot-index/", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "pivotindex", "task_id": "TACO_lite/36"}
{"requirement": "Write a method named `getExponent(n,p)` that returns the largest integer exponent `x` such that p^(x) evenly divides `n`. if `p<=1` the method should return `null`/`None` (throw an `ArgumentOutOfRange` exception in C#).", "solutions": ["def get_exponent(n, p):\n    if p > 1:\n        x = 0\n        while not n % p:\n            x += 1\n            n //= p\n        return x", "def get_exponent(n, p, i=0):\n    if p <= 1:\n        return None\n    return get_exponent(n / p, p, i + 1) if n / p == n // p else i", "from itertools import count\n\ndef get_exponent(n, p):\n    if p > 1:\n        for res in count():\n            (n, r) = divmod(n, p)\n            if r:\n                return res", "def get_exponent(n, p):\n    return next(iter((i for i in range(int(abs(n) ** (1 / p)), 0, -1) if n / p ** i % 1 == 0)), 0) if p > 1 else None", "def get_exponent(n, p):\n    if p <= 1:\n        return None\n    (x, e) = (0, 1)\n    while n % e == 0:\n        x += 1\n        e *= p\n    return x - 1", "def get_exponent(n, p):\n    i = 1\n    if p <= 1:\n        return None\n    while n % p ** i == 0:\n        i += 1\n    return i - 1", "def get_exponent(n, p):\n    if p <= 1:\n        return\n    return max([i for i in range(1, int(abs(n) ** 0.5)) if n % p ** i == 0], default=0)", "def get_exponent(n, p):\n    if int(p) <= 1:\n        return None\n    else:\n        x = 1\n        while n % p ** x == 0:\n            x += 1\n    return x - 1", "def get_exponent(n, p):\n    r = 0\n    while n % p ** r == 0 and p > 1:\n        r += 1\n    if r > 0:\n        return r - 1", "from math import log\n\ndef get_exponent(n, p):\n    if p <= 1:\n        return None\n    (l, i) = (None, 0)\n    while p ** i <= abs(n):\n        if n % p ** i == 0:\n            l = i\n        i += 1\n    return l"], "starter_code": "def get_exponent(n, p):\n", "input_output": {"fn_name": "get_exponent", "inputs": [[27, 3]], "outputs": [[3]]}, "difficulty": "EASY", "raw_tags": ["Mathematics", "Fundamentals"], "name": null, "source": "codewars", "tags": ["Fundamentals", "Mathematics"], "skill_types": [], "url": "https://www.codewars.com/kata/59b139d69c56e8939700009d", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "get_exponent", "task_id": "TACO_lite/37"}
{"requirement": "You are given an integer array nums that may contain duplicates. Your task is to return all possible subsets. Return only unique subsets and they can be in any order.\nExample: \nInput: \nnums = [1,2,2] \nOutput: \n[[],[1],[1,2],[1,2,2],[2],[2,2]]\nExplanation: \nWe can have subsets ranging from length 0 to 3. which are listed above. Also the subset [1,2] appears twice but is printed only once as we require only unique subsets.\nYour Task:\nComplete the function vector> printUniqueSubset(), which takes  a vector nums and return a vector of vector consisting of all unique subsets.\nExpected Time Complexity: O(K2^{N}).\nExpected Auxiliary Space: O(K2^{N}).\nConstraints:\n1 <= nums.length <= 10\n-10 <= nums[i] <= 10", "solutions": ["def printuniquesubset(nums):\n    n = len(nums)\n    nums.sort()\n    ans = []\n\n    def solve(i, temp):\n        ans.append(temp[:])\n        for j in range(i, n):\n            if j > i and nums[j] == nums[j - 1]:\n                continue\n            temp.append(nums[j])\n            solve(j + 1, temp)\n            temp.pop()\n    solve(0, [])\n    return ans", "def subset2(arr, n, ans, ind, subs):\n    if ind == n:\n        return\n    subs.append(arr[ind])\n    ans.append(subs[:])\n    subset2(arr, n, ans, ind + 1, subs)\n    subs.pop()\n    for i in range(ind + 1, n):\n        if arr[i] == arr[i - 1]:\n            continue\n        subs.append(arr[i])\n        ans.append(subs[:])\n        subset2(arr, n, ans, i + 1, subs)\n        subs.pop()\n\ndef printuniquesubset(nums):\n    nums.sort()\n    n = len(nums)\n    ans = []\n    subs = []\n    ans.append(subs)\n    i = 0\n    subset2(nums, n, ans, i, subs)\n    return ans", "def solve(k, nums, curr):\n    if k == len(nums):\n        self.ans.add(tuple(curr))\n        return\n    self.solve(k + 1, nums, curr)\n    curr.append(nums[k])\n    self.solve(k + 1, nums, curr)\n    curr.pop()\n\ndef printuniquesubset(nums):\n    nums.sort()\n    self.ans = set()\n    curr = []\n    self.solve(0, nums, curr)\n    return sorted(list(self.ans))", "def subsets(arr, index, seq):\n    if index == len(arr):\n        self.res.append(seq)\n        return\n    copyindex = index\n    while index < len(arr) - 1 and arr[index] == arr[index + 1]:\n        index += 1\n    self.subsets(arr, index + 1, seq)\n    self.subsets(arr, copyindex + 1, seq + [arr[copyindex]])\n\ndef printuniquesubset(nums):\n    nums.sort()\n    self.res = []\n    self.subsets(nums, 0, [])\n    return sorted(self.res)", "def printuniquesubset(nums):\n\n    def subdup(ind, nums, ans, s):\n        ans.append(s[:])\n        for i in range(ind, len(nums)):\n            if i > ind and nums[i] == nums[i - 1]:\n                continue\n            s.append(nums[i])\n            subdup(i + 1, nums, ans, s)\n            s.pop()\n        return\n    ans = []\n    s = []\n    nums.sort()\n    subdup(0, nums, ans, s)\n    return ans", "def printuniquesubset(nums):\n    ans = []\n    ds = []\n\n    def findSubsets(ind: int):\n        ans.append(ds[:])\n        for i in range(ind, len(nums)):\n            if i != ind and nums[i] == nums[i - 1]:\n                continue\n            ds.append(nums[i])\n            findSubsets(i + 1)\n            ds.pop()\n    nums.sort()\n    findSubsets(0)\n    return ans", "def printuniquesubset(nums):\n    res = []\n    nums.sort()\n\n    def backtrack(i, subset):\n        if i == len(nums):\n            res.append(subset[:])\n            return\n        subset.append(nums[i])\n        backtrack(i + 1, subset)\n        subset.pop()\n        while i + 1 < len(nums) and nums[i] == nums[i + 1]:\n            i += 1\n        backtrack(i + 1, subset)\n    backtrack(0, [])\n    res.sort()\n    return res", "def gen(nums, n, arr, brr, pos):\n    if pos == n:\n        crr = brr.copy()\n        arr.add(tuple(sorted(crr)))\n        return\n    brr.append(nums[pos])\n    self.gen(nums, n, arr, brr, pos + 1)\n    brr.pop()\n    self.gen(nums, n, arr, brr, pos + 1)\n\ndef printuniquesubset(nums):\n    arr = set()\n    brr = []\n    self.gen(nums, len(nums), arr, brr, 0)\n    return sorted(list(arr))", "def printuniquesubset(nums):\n    (lst, tmp) = ([], [])\n    dic = {}\n\n    def subs(idx, nums, n, tmp, lst):\n        if idx >= n:\n            if str(tmp) not in dic:\n                dic[str(tmp)] = 1\n                lst.append(tmp[:])\n            return\n        tmp.append(nums[idx])\n        subs(idx + 1, nums, n, tmp, lst)\n        tmp.pop()\n        subs(idx + 1, nums, n, tmp, lst)\n    nums.sort()\n    subs(0, nums, len(nums), tmp, lst)\n    return sorted(lst)", "def printuniquesubset(nums):\n    ans = []\n    m = len(nums)\n    nums.sort()\n\n    def recursion(idx, ds):\n        ans.append(ds.copy())\n        for i in range(idx, m):\n            if i > idx and nums[i] == nums[i - 1]:\n                continue\n            ds.append(nums[i])\n            recursion(i + 1, ds)\n            ds.remove(nums[i])\n    recursion(0, [])\n    return ans", "def solve(i, nums, lst, ans):\n    if i == n:\n        ans.add(tuple(lst))\n        return\n    lst.append(nums[i])\n    self.solve(i + 1, nums, lst, ans)\n    lst.pop()\n    self.solve(i + 1, nums, lst, ans)\n\ndef printuniquesubset(nums):\n    nums.sort()\n    ans = set()\n    lst = []\n    i = 0\n    self.solve(i, nums, lst, ans)\n    return sorted(ans)"], "starter_code": "def printuniquesubset(nums):\n", "input_output": {"inputs": ["nums = [1,2,2]"], "outputs": ["[[],[1],[1,2],[1,2,2],[2],[2,2]]"]}, "difficulty": "MEDIUM", "raw_tags": [], "name": null, "source": "geeksforgeeks", "tags": [], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/subset-sum-ii/1", "Expected Auxiliary Space": "O(K2^{N}).", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(K2^{N}).", "entry_point": "printuniquesubset", "task_id": "TACO_lite/38"}
{"requirement": "The number ```89``` is the first integer with more than one digit that fulfills the property partially introduced in the title of this kata. \nWhat's the use of saying \"Eureka\"? Because this sum gives the same number.\n\nIn effect: ```89 = 8^1 + 9^2``` \n\nThe next number in having this property is ```135```.\n\nSee this property again: ```135 = 1^1 + 3^2 + 5^3```\n\nWe need a function to collect these numbers, that may receive two integers ```a```, ```b``` that defines the range ```[a, b]``` (inclusive) and outputs a list of the sorted numbers in the range that fulfills the property described above.\n\nLet's see some cases:\n```python\nsum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nsum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89]\n```\nIf there are no numbers of this kind in the range [a, b] the function should output an empty list.\n```python\nsum_dig_pow(90, 100) == []\n```\nEnjoy it!!", "solutions": ["def dig_pow(n):\n    return sum((int(x) ** y for (y, x) in enumerate(str(n), 1)))\n\ndef sum_dig_pow(a, b):\n    return [x for x in range(a, b + 1) if x == dig_pow(x)]", "def sum_dig_pow(a, b):\n    return [x for x in range(a, b + 1) if sum((int(d) ** i for (i, d) in enumerate(str(x), 1))) == x]", "def sum_dig_pow(a, b):\n    res = []\n    for number in range(a, b + 1):\n        digits = [int(i) for i in str(number)]\n        s = 0\n        for (idx, val) in enumerate(digits):\n            s += val ** (idx + 1)\n        if s == number:\n            res.append(number)\n    return res", "def sum_dig_pow(a, b):\n    l = []\n    for i in range(a, b + 1):\n        k = 0\n        p = str(i)\n        for j in range(len(p)):\n            k += int(p[j]) ** (j + 1)\n        if k == i:\n            l.append(i)\n    return l", "def sum_dig_pow(a, b):\n    ans = []\n    while a <= b:\n        if sum((int(j) ** k for (j, k) in zip(str(a), range(1, len(str(a)) + 1)))) == a:\n            ans += [a]\n        a += 1\n    return ans", "def sum_dig_pow(a, b):\n    lis = []\n    for i in range(a, b + 1):\n        temp = str(i)\n        su = 0\n        for l in range(0, len(temp)):\n            su += int(temp[l:l + 1]) ** (l + 1)\n        if su == i:\n            lis.append(i)\n    return lis"], "starter_code": "def sum_dig_pow(a, b):\n", "input_output": {"fn_name": "sum_dig_pow", "inputs": [[1, 100], [10, 89], [10, 100], [90, 100], [90, 150], [50, 150], [10, 150], [89, 135]], "outputs": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 89]], [[89]], [[89]], [[]], [[135]], [[89, 135]], [[89, 135]], [[89, 135]]]}, "difficulty": "EASY", "raw_tags": ["Mathematics", "Fundamentals"], "name": null, "source": "codewars", "tags": ["Fundamentals", "Mathematics"], "skill_types": [], "url": "https://www.codewars.com/kata/5626b561280a42ecc50000d1", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "sum_dig_pow", "task_id": "TACO_lite/39"}
{"requirement": "Given a string Str which may contains lowercase and uppercase chracters. The task is to remove all duplicate characters from the string and find the resultant string. The order of remaining characters in the output should be same as in the original string.\nExample 1:\nInput:\nStr = geeksforgeeks\nOutput: geksfor\nExplanation: After removing duplicate\ncharacters such as e, k, g, s, we have\nstring as \"geksfor\".\nExample 2:\nInput:\nStr = HappyNewYear\nOutput: HapyNewYr\nExplanation: After removing duplicate\ncharacters such as p, e, a, we have\nstring as \"HapyNewYr\".\nYour Task:\nComplete the function removeDuplicates() which takes a string str, as input parameters and returns a string denoting the answer. You don't to print answer or take inputs.\nExpected Time Complexity: O(N)\nExpected Auxiliary Space: O(N)\nConstraints:\n1 ≤ N ≤ 10^{5}\nString contains uppercase and lowercase english letters.", "solutions": ["def removeduplicates(str):\n    asci = [0] * 256\n    s = ''\n    for i in range(len(str)):\n        x = ord(str[i])\n        asci[x] += 1\n    for i in range(len(str)):\n        x = ord(str[i])\n        if asci[x] > 0:\n            s += str[i]\n            asci[x] = 0\n    return s", "def removeduplicates(str):\n    ans = ''\n    li = [0] * 256\n    for i in str:\n        ind = ord(i) - ord('a')\n        if li[ind] == 0:\n            li[ind] = 1\n            ans += i\n    return ans", "def removeduplicates(str):\n    lst = []\n    for i in str:\n        if i not in lst:\n            lst.append(i)\n    return ''.join(lst)", "def removeduplicates(str):\n    (m, p) = ({}, '')\n    for i in str:\n        if i not in m:\n            p += i\n        m[i] = 1\n    return p", "def removeduplicates(str):\n    f = ''\n    for i in str:\n        if i not in f:\n            f = f + i\n    return f", "def removeduplicates(str):\n    str1 = ''\n    for i in range(len(str)):\n        if str[i] not in str1:\n            str1 = str1 + str[i]\n    return str1", "def removeduplicates(str):\n    from collections import defaultdict\n    dic = defaultdict(int)\n    ans = ''\n    for i in str:\n        if dic[i] == 0:\n            ans += i\n        dic[i] += 1\n    return ans", "def removeduplicates(str):\n    l = list(str)\n    l1 = []\n    for i in l:\n        if i not in l1:\n            l1.append(i)\n        else:\n            pass\n    x = ''.join(l1)\n    return x", "from collections import OrderedDict\n\ndef removeduplicates(str):\n    a = []\n    b = ''\n    for i in str:\n        a.append(i)\n    a = list(OrderedDict.fromkeys(a))\n    for i in a:\n        b += i\n    return b", "def removeduplicates(str):\n    a = {}\n    b = ''\n    for i in str:\n        if i not in a:\n            b += i\n        a[i] = 1\n    return b", "def removeduplicates(str):\n    ms = ''\n    d = {}\n    for i in str:\n        if i not in d:\n            ms += i\n            d[i] = 1\n    return ms", "def removeduplicates(str):\n    arr = [char for char in str]\n    b = list()\n    for i in arr:\n        if i not in b:\n            b.append(i)\n    return ''.join(b)", "def removeduplicates(str):\n    p = ''\n    for char in str:\n        if char not in p:\n            p = p + char\n    return p", "def removeduplicates(str):\n    freq = {}\n    s = ''\n    for i in range(len(str)):\n        if str[i] not in freq:\n            s += str[i]\n            freq[str[i]] = i\n    return s", "def removeduplicates(str):\n    l = list(str)\n    lst = []\n    s = set()\n    for i in l:\n        if i not in s:\n            s.add(i)\n            lst.append(i)\n    return ''.join(lst)", "def removeduplicates(s: str) -> str:\n    seen = set()\n    ans = []\n    for c in s:\n        if c not in seen:\n            ans.append(c)\n            seen.add(c)\n    return ''.join(ans)", "def removeduplicates(str):\n    unique = set()\n    res = []\n    for c in str:\n        if c not in unique:\n            res.append(c)\n            unique.add(c)\n    return ''.join(res)", "def removeduplicates(str: str) -> str:\n    hash = [0] * 256\n    ans = ''\n    for c in str:\n        if hash[ord(c)] == 0:\n            ans += c\n            hash[ord(c)] += 1\n    return ans", "def removeduplicates(Str):\n    unique_chars = set()\n    output = ''\n    for char in Str:\n        if char not in unique_chars:\n            unique_chars.add(char)\n            output += char\n    return output", "def removeduplicates(s):\n    for i in range(len(s)):\n        s[i].lower()\n    d = {}\n    for i in s:\n        d[i] = 1\n    t = ''\n    for i in s:\n        if d[i] == 1:\n            t += i\n            d[i] -= 1\n    return t", "def removeduplicates(string):\n    hash_set = set()\n    result = ''\n    for char in string:\n        if char not in hash_set:\n            result += char\n            hash_set.add(char)\n    return result", "def removeduplicates(str):\n    letters = []\n    output = ''\n    for i in range(len(str)):\n        if str[i] in letters:\n            continue\n        else:\n            output += str[i]\n            letters.append(str[i])\n    return output", "def removeduplicates(s):\n    result = ''\n    for char in s:\n        if char not in result:\n            result += char\n    return result", "def removeduplicates(str):\n    res = ''\n    for s in str:\n        if s not in res:\n            res = res + s\n    return res", "def removeduplicates(str):\n    seen = set()\n    result = ''\n    for char in str:\n        if char not in seen:\n            result += char\n            seen.add(char)\n    return result", "def removeduplicates(str):\n    a = []\n    s = ''\n    for i in str:\n        if i not in a:\n            a.append(i)\n    for i in a:\n        s += i\n    return s", "def removeduplicates(str):\n    a = list(str)\n    l = []\n    l.append(a[0])\n    for i in range(1, len(a)):\n        if a[i] not in l:\n            l.append(a[i])\n    s = ''.join(l)\n    return s", "def removeduplicates(st):\n    d = {}\n    s = ''\n    for i in st:\n        if i not in d:\n            s += i\n            d[i] = 1\n    return s", "def removeduplicates(str):\n    s = ''\n    str = list(str)\n    l = []\n    for i in str:\n        if i in l:\n            continue\n        else:\n            l.append(i)\n    for i in l:\n        s += i\n    return s", "def removeduplicates(str):\n    s = ''\n    length = len(str)\n    for i in range(length):\n        c = str[i]\n        if c not in s:\n            s += c\n    return s", "def removeduplicates(str):\n    result = []\n    sample = ''\n    for i in str:\n        if i not in result:\n            result.append(i)\n    for i in result:\n        sample += i\n    return sample", "def removeduplicates(str):\n    hsh = set()\n    T = ''\n    for ch in str:\n        if ch in hsh:\n            continue\n        else:\n            T += ch\n            hsh.add(ch)\n    return T", "def removeduplicates(str):\n    d = {}\n    res = ''\n    for char in str:\n        d[char] = d.get(char, 0) + 1\n        if d[char] == 1:\n            res += char\n    return res", "def removeduplicates(str):\n    l = list(str)\n    dup = []\n    s = ''\n    for i in l:\n        if i not in dup:\n            dup.append(i)\n    for j in dup:\n        return s.join(dup)", "def removeduplicates(str):\n    res = ''\n    myDict = {}\n    for i in str:\n        if i not in myDict:\n            res += i\n            myDict[i] = 1\n    return res", "def removeduplicates(str):\n    s = list(str)\n    look = {}\n    p = ''\n    for i in s:\n        if i not in look:\n            p += i\n        look[i] = 1\n    return p", "def removeduplicates(str):\n    l = []\n    for i in str:\n        if i not in l:\n            l.append(i)\n        else:\n            continue\n    a = ''.join(l)\n    return a", "def removeduplicates(str):\n    l = []\n    for i in str:\n        if i in l:\n            pass\n        else:\n            l.append(i)\n    joint = ''.join(l)\n    return joint", "def removeduplicates(str):\n    look_up = {}\n    result = ''\n    for i in str:\n        if i not in look_up.keys():\n            result = result + i\n            look_up[i] = 1\n    return result"], "starter_code": "def removeduplicates(str):\n", "input_output": {"inputs": ["Str = geeksforgeeks", "Str = HappyNewYear"], "outputs": ["geksfor", "HapyNewYr"]}, "difficulty": "EASY", "raw_tags": ["Strings", "Arrays", "Data Structures"], "name": null, "source": "geeksforgeeks", "tags": ["String algorithms", "Data structures"], "skill_types": ["Data structures"], "url": "https://practice.geeksforgeeks.org/problems/remove-all-duplicates-from-a-given-string4321/1", "Expected Auxiliary Space": "O(N)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N)", "entry_point": "removeduplicates", "task_id": "TACO_lite/40"}
{"requirement": "Given a matrix A of dimensions NxN where every element is either O or X. Find the largest subsquare surrounded by X.\nExample 1:\nInput:\nN=2\nA=[[X,X][X,X]]\nOutput:\n2\nExplanation:\nThe largest square submatrix \nsurrounded by X is the whole \ninput matrix.\nExample 2:\nInput:\nN=4\nA=[[X,X,X,O],[X,O,X,X],\n[X,X,X,O],[X,O,X,X]]\nOutput:\n3\nExplanation:\nHere,the input represents following \nmatrix of size 4 x 4\nX X X O\nX O X X\nX X X O\nX O X X\nThe square submatrix starting at \n(0,0) and ending at (2,2) is the \nlargest submatrix surrounded by X.\nTherefore, size of that matrix would be 3.\nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function largestSubsquare() which takes the integer N and the matrix A as input parameters and returns the size of the largest subsquare surrounded by 'X'.\nExpected Time Complexity:O(N^{2})\nExpected Auxillary Space:O(N^{2})\nConstraints:\n1<=N<=1000\nA[i][j]={'X','O'}", "solutions": ["def largestsubsquare(N, A):\n    m = [[[0 for _ in range(N)] for _ in range(N)] for _ in range(2)]\n    for i in range(N):\n        m[0][i][0] = 1 if A[i][0] == 'X' else 0\n        for j in range(1, N):\n            if A[i][j] == 'X':\n                m[0][i][j] = m[0][i][j - 1] + 1\n    for j in range(N):\n        m[1][0][j] = 1 if A[0][j] == 'X' else 0\n        for i in range(1, N):\n            if A[i][j] == 'X':\n                m[1][i][j] = m[1][i - 1][j] + 1\n    ans = 0\n    for i in range(N):\n        for j in range(N):\n            d = min(m[0][i][j], m[1][i][j])\n            while d > 0:\n                if m[0][i - d + 1][j] >= d and m[1][i][j - d + 1] >= d:\n                    ans = max(d, ans)\n                    break\n                d -= 1\n    return ans", "def get_hor_mat(n, a, hor):\n    for i in range(n):\n        for j in range(n):\n            if i >= 0 and j == 0:\n                if a[i][j] == 'X':\n                    hor[i][j] = 1\n                else:\n                    hor[i][j] = 0\n            elif a[i][j] == 'X':\n                hor[i][j] = hor[i][j - 1] + 1\n            else:\n                continue\n\ndef get_ver_mat(n, a, ver):\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j >= 0:\n                if a[i][j] == 'X':\n                    ver[i][j] = 1\n            elif a[i][j] == 'X':\n                ver[i][j] = ver[i - 1][j] + 1\n\ndef largestsubsquare(n, a):\n    hor = [[0 for j in range(n)] for i in range(n)]\n    ver = [[0 for j in range(n)] for i in range(n)]\n    max_square = 0\n    self.get_hor_mat(n, a, hor)\n    self.get_ver_mat(n, a, ver)\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            min_val = min(hor[i][j], ver[i][j])\n            while min_val > max_square:\n                if ver[i][j - min_val + 1] >= min_val and hor[i - min_val + 1][j] >= min_val:\n                    max_square = min_val\n                min_val -= 1\n    return max_square", "def largestsubsquare(N, A):\n    (ROWS, COLS) = (len(A), len(A[0]))\n    dp = [[[0, 0] for i in range(ROWS + 1)] for j in range(COLS + 1)]\n    for i in range(ROWS):\n        for j in range(COLS):\n            if A[i][j] == 'X':\n                dp[i + 1][j + 1][0] = dp[i][j + 1][0] + 1\n                dp[i + 1][j + 1][1] = dp[i + 1][j][1] + 1\n    maxi = 0\n    for i in range(ROWS, 0, -1):\n        for j in range(COLS, 0, -1):\n            curMin = min(dp[i][j][0], dp[i][j][1])\n            while curMin > maxi:\n                if dp[i - curMin + 1][j][1] >= curMin and dp[i][j - curMin + 1][0] >= curMin:\n                    maxi = curMin\n                else:\n                    curMin -= 1\n    return maxi", "def largestsubsquare(N, A):\n    left_c = [[0] * N for i in range(N)]\n    top_c = [[0] * N for i in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if A[i][j] == 'X':\n                left_c[i][j] = (left_c[i][j - 1] if j > 0 else 0) + 1\n                top_c[i][j] = (top_c[i - 1][j] if i > 0 else 0) + 1\n    max_len = 0\n    for i in range(N - 1, -1, -1):\n        for j in range(N - 1, -1, -1):\n            val = min(left_c[i][j], top_c[i][j])\n            while val > max_len:\n                if top_c[i][j - val + 1] >= val and left_c[i - val + 1][j] >= val:\n                    max_len = max(max_len, val)\n                val -= 1\n    return max_len", "def largestsubsquare(n, a):\n    dp = [[[0, 0] for i in range(n)] for i in range(n)]\n    dp[0][0] = [1, 1] if a[0][0] == 'X' else [0, 0]\n    m = dp[0][0][0]\n\n    def check(i, j, back):\n        nonlocal dp\n        nonlocal m\n        while back > m and (dp[i - back + 1][j][1] < back or dp[i][j - back + 1][0] < back):\n            back -= 1\n        return back if back > m else m\n    for i in range(1, n):\n        if a[0][i] == 'X':\n            dp[0][i] = [1, dp[0][i - 1][1] + 1]\n        if a[i][0] == 'X':\n            dp[i][0] = [dp[i - 1][0][0] + 1, 1]\n        m = max(m, min(dp[0][i]), min(dp[i][0]))\n    for i in range(1, n):\n        for j in range(1, n):\n            if a[i][j] == 'X':\n                dp[i][j][0] = dp[i - 1][j][0] + 1\n                dp[i][j][1] = dp[i][j - 1][1] + 1\n                x = min(dp[i][j])\n                if x > m:\n                    m = check(i, j, x)\n    return m", "def largestsubsquare(N, A):\n    a = [[[0, 0] for i in range(N)] for i in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if A[i][j] == 'O':\n                a[i][j][0] = 0\n                a[i][j][1] = 0\n            elif A[i][j] == 'X':\n                if i - 1 >= 0:\n                    a[i][j][1] = a[i - 1][j][1] + 1\n                else:\n                    a[i][j][1] = 1\n                if j - 1 >= 0:\n                    a[i][j][0] = a[i][j - 1][0] + 1\n                else:\n                    a[i][j][0] = 1\n    max = 0\n    for i in range(N):\n        for j in range(N):\n            aa = min(a[i][j][0], a[i][j][1])\n            while aa > max:\n                if aa > max and a[i - aa + 1][j][0] >= aa and (a[i][j - aa + 1][1] >= aa):\n                    max = aa\n                    break\n                aa -= 1\n    return max", "def largestsubsquare(N, mat):\n    Max = 0\n    mp = [[(0, 0) for i in range(N)] for i in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if mat[i][j] == 'O':\n                mp[i][j] = (0, 0)\n            elif i == 0 and j == 0:\n                mp[i][j] = (1, 1)\n            elif i == 0:\n                mp[i][j] = (1, mp[i][j - 1][1] + 1)\n            elif j == 0:\n                mp[i][j] = (mp[i - 1][j][0] + 1, 1)\n            else:\n                mp[i][j] = (mp[i - 1][j][0] + 1, mp[i][j - 1][1] + 1)\n    for i in range(N - 1, -1, -1):\n        for j in range(N - 1, -1, -1):\n            small = mp[i][j][0] if mp[i][j][0] < mp[i][j][1] else mp[i][j][1]\n            while small > Max:\n                if mp[i][j - small + 1][0] >= small and mp[i - small + 1][j][1] >= small:\n                    Max = small\n                small -= 1\n    return Max"], "starter_code": "def largestsubsquare(N,A):\n", "input_output": {"inputs": ["N=2\r\nA=[[X,X][X,X]]", "N=4\r\nA=[[X,X,X,O],[X,O,X,X],\r\n[X,X,X,O],[X,O,X,X]]"], "outputs": ["2", "3"]}, "difficulty": "MEDIUM", "raw_tags": ["Data Structures", "Matrix"], "name": null, "source": "geeksforgeeks", "tags": ["Matrices", "Data structures"], "skill_types": ["Data structures"], "url": "https://practice.geeksforgeeks.org/problems/largest-subsquare-surrounded-by-x0558/1", "Expected Auxiliary Space": "O(N^{2})", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N^{2})", "entry_point": "largestsubsquare", "task_id": "TACO_lite/41"}
{"requirement": "```if-not:ruby\nCreate a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with empty elements.\n```\n```if:ruby\nCreate a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with `nil`s.\n```\n\nExamples:\n\n```python\ninterleave([1, 2, 3], [\"c\", \"d\", \"e\"]) == [1, \"c\", 2, \"d\", 3, \"e\"]\ninterleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, None]\ninterleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [1, 4, 7, 2, 5, 8, 3, 6, 9]\ninterleave([]) == []\n```", "solutions": ["from itertools import chain, zip_longest\n\ndef interleave(*args):\n    return list(chain.from_iterable(zip_longest(*args)))", "def interleave(*args):\n    max_len = max(map(len, args))\n    interleaved = []\n    for i in range(max_len):\n        for arr in args:\n            if i < len(arr):\n                interleaved.append(arr[i])\n            else:\n                interleaved.append(None)\n    return interleaved", "from itertools import chain, zip_longest\n\ndef interleave(*args):\n    return [*chain(*zip_longest(*args))]", "interleave = lambda *a: [b[i] if len(b) > i else None for i in range(max((len(i) for i in a))) for b in a]", "from itertools import zip_longest\n\ndef interleave(*args):\n    return [y for x in zip_longest(*args) for y in x]", "interleave = lambda *a: sum([list(i) for i in __import__('itertools').zip_longest(*a)], [])", "from itertools import zip_longest\n\ndef interleave(*args):\n    return [i for _ in zip_longest(*args) for i in _]", "def interleave(*args):\n    arr = []\n    for i in range(max((len(a) for a in args))):\n        for j in range(len(args)):\n            try:\n                arr.append(args[j][i])\n            except:\n                arr.append(None)\n    return arr", "def interleave(*args):\n    n_max = len(max(args, key=len))\n    return [j[i] if i < len(j) else None for i in range(n_max) for j in args]"], "starter_code": "def interleave(*args):\n", "input_output": {"fn_name": "interleave", "inputs": [[[1, 2, 3], ["c", "d", "e"]], [[1, 2, 3], [4, 5]], [[1, 2], [3, 4, 5]], [[null], [null, null], [null, null, null]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[]]], "outputs": [[[1, "c", 2, "d", 3, "e"]], [[1, 4, 2, 5, 3, null]], [[1, 3, 2, 4, null, 5]], [[null, null, null, null, null, null, null, null, null]], [[1, 4, 7, 2, 5, 8, 3, 6, 9]], [[]]]}, "difficulty": "EASY", "raw_tags": ["Arrays", "Algorithms"], "name": null, "source": "codewars", "tags": ["Data structures"], "skill_types": ["Data structures"], "url": "https://www.codewars.com/kata/523d2e964680d1f749000135", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "interleave", "task_id": "TACO_lite/42"}
{"requirement": "Given an integer N, count the numbers having an odd number of factors from 1 to N (inclusive).\n \nExample 1:\nInput:\nN = 5\nOutput:\n2\nExplanation:\nFrom 1 - 5 only 2 numbers,\n1 and 4 are having odd number\nof factors.\nExample 2:\nInput:\nN = 1\nOutput:\n1\nExplanation:\n1 have only 1(odd)\nfactor\nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function count() which takes an integer N as input parameters and returns an integer, the total count of numbers from 1 to N having an odd number of factors.\n \nExpected Time Complexity: O(sqrt(N))\nExpected Space Complexity: O(1)\n \nConstraints:\n0 <= N <= 10^{9}", "solutions": ["import math\n\ndef count(N):\n    c = 0\n    for i in range(1, N + 1):\n        if i * i <= N:\n            c += 1\n    return c", "import math\n\ndef count(N):\n    return math.floor(math.sqrt(N))", "def count(N):\n    return int(N ** 0.5)", "def count(N):\n    count_odd = 0\n    for i in range(1, N + 1):\n        if int(i ** 0.5) ** 2 == i:\n            count_odd += 1\n    return count_odd", "from math import *\n\ndef count(N):\n    return int(N ** 0.5)", "import math\n\ndef count(N):\n    return int(math.sqrt(N))", "def count(N):\n    import math\n    self.N = N\n    p = math.sqrt(N)\n    q = math.floor(p)\n    return q", "import math\n\ndef count(N):\n    (count, d) = (0, 0)\n    for i in range(1, N + 1):\n        d = int(math.sqrt(i))\n        if i == d * d:\n            count += 1\n    return count", "def count(N):\n    c = 0\n    for i in range(1, N + 1):\n        if i ** 0.5 == int(i ** 0.5):\n            c = c + 1\n    return c", "def count(N):\n    import math\n    if N == 1:\n        return 1\n    else:\n        return int(math.sqrt(N))", "def count(N):\n    count = 0\n    val = int(pow(N, 0.5))\n    for i in range(1, val + 1):\n        if i * i <= N:\n            count += 1\n    return count", "import math\n\ndef count(N):\n    ar = [1]\n    for i in range(2, N + 1):\n        if math.sqrt(i) == int(math.sqrt(i)):\n            ar.append(i)\n    return len(ar)", "import math\n\ndef count(n):\n    if n == 1:\n        return 1\n    return int(math.sqrt(n))", "def sqrt(N):\n    l = 1\n    r = N\n    m = N // 2\n    while l <= r:\n        if m * m == N:\n            return m\n        elif m * m > N:\n            r = m - 1\n        else:\n            l = m + 1\n        m = (l + r) // 2\n    return m\n\ndef count(N):\n    val = self.sqrt(N)\n    return val", "import math\nfrom math import floor, ceil\n\ndef count(N):\n    return floor(math.sqrt(N))", "def count(N):\n    import math\n    c = 1\n    for i in range(2, N + 1):\n        if int(math.sqrt(i) * int(math.sqrt(i)) == i):\n            c = c + 1\n    return c", "def count(N):\n    a = 0\n    b = N\n    return int(b ** 0.5) - int(a ** 0.5)", "def count(N):\n    count1 = 0\n    for i in range(1, N + 1):\n        if i * i <= N:\n            count1 += 1\n    return count1", "import math\n\ndef count(N):\n    c = 0\n    if N == 1:\n        return 1\n    else:\n        for i in range(1, N):\n            if math.ceil(math.sqrt(i)) == math.floor(math.sqrt(i)):\n                c += 1\n    return c", "from math import *\n\ndef count(N):\n    main_count = 0\n    for i in range(1, N + 1):\n        result = int(sqrt(i))\n        if result * result == i:\n            main_count += 1\n    return main_count", "def count(N):\n    fac = int(pow(N, 1 / 2))\n    return fac", "import math\n\ndef count(n):\n    return int(math.sqrt(n))", "def helper(n):\n    sr = n ** 0.5\n    m1 = sr % 1\n    if m1 == 0:\n        return True\n    else:\n        return False\n\ndef count(N):\n    ans = 1\n    for i in range(2, N):\n        if self.helper(i):\n            ans += 1\n    return ans", "import math\n\ndef count(N):\n    count = 0\n    for i in range(1, N + 1):\n        square = i ** (1 / 2)\n        if math.ceil(square) == math.floor(square):\n            count += 1\n    return count"], "starter_code": "def count (N):\n", "input_output": {"inputs": ["N = 5", "N = 1"], "outputs": ["2", "1"]}, "difficulty": "EASY", "raw_tags": ["Algorithms", "Mathematical"], "name": null, "source": "geeksforgeeks", "tags": ["Mathematics"], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/count-odd-factors0844/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(sqrt(N))", "entry_point": "count", "task_id": "TACO_lite/43"}
{"requirement": "Given a sequence of moves for a robot. Check if the sequence is circular or not. \nA sequence of moves is circular if the first and last positions of the robot are the same. A move can be one of the following :\n    G - Go one unit\n    L - Turn left\n    R - Turn right\nExample 1:\nInput: path = \"GLGLGLG\"\nOutput: \"Circular\"\nExplanation: If we start form \n(0,0) in a plane then we will \nback to (0,0) by the end of the \nsequence.\nÃ¢â¬â¹Example 2:\nInput: path = \"GGGGL\"\nOutput: \"Not Circular\"\nExplanation: We can't return to \nsame place at the end of the path.\nYour Task:  \nYou don't need to read input or print anything. Your task is to complete the function isCircular() which takes the string path as input and returns \"Circular\" if the path is circular else returns \"Not Circular\".\nExpected Time Complexity: O(|S|)\nExpected Auxiliary Space: O(1)\nConstraints:\n1 ≤ |S| ≤ 10^{5}", "solutions": ["def iscircular(path):\n    i = j = 0\n    pre = 'r'\n    for k in path:\n        if k == 'G':\n            if pre == 'r':\n                j += 1\n            elif pre == 'l':\n                j -= 1\n            elif pre == 'u':\n                i -= 1\n            elif pre == 'd':\n                i += 1\n        elif k == 'L':\n            if pre == 'r':\n                pre = 'u'\n            elif pre == 'l':\n                pre = 'd'\n            elif pre == 'u':\n                pre = 'l'\n            elif pre == 'd':\n                pre = 'r'\n        elif k == 'R':\n            if pre == 'r':\n                pre = 'd'\n            elif pre == 'l':\n                pre = 'u'\n            elif pre == 'u':\n                pre = 'r'\n            elif pre == 'd':\n                pre = 'l'\n    if i == 0 and j == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    l = [0, 0]\n    dir = 1\n    for i in range(len(path)):\n        if path[i] == 'G':\n            if dir == 1:\n                l[0] += 1\n            elif dir == 2:\n                l[1] += 1\n            elif dir == 3:\n                l[0] -= 1\n            else:\n                l[1] -= 1\n        elif path[i] == 'L':\n            dir += 1\n            if dir > 4:\n                dir = 1\n        else:\n            dir -= 1\n            if dir == 0:\n                dir = 4\n    if l == [0, 0]:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    direction = 0\n    x = 0\n    y = 0\n    for i in path:\n        if i == 'G':\n            if direction == 0:\n                y += 1\n            elif direction == 1:\n                x += 1\n            elif direction == 2:\n                y -= 1\n            elif direction == 3:\n                x -= 1\n        elif i == 'L':\n            if direction == 0:\n                direction = 3\n            else:\n                direction -= 1\n        elif i == 'R':\n            if direction == 3:\n                direction = 0\n            else:\n                direction += 1\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(moves):\n    (x, y) = (0, 0)\n    direction = 'N'\n    for move in moves:\n        if move == 'G':\n            if direction == 'N':\n                y += 1\n            elif direction == 'S':\n                y -= 1\n            elif direction == 'E':\n                x += 1\n            elif direction == 'W':\n                x -= 1\n        elif move == 'L':\n            if direction == 'N':\n                direction = 'W'\n            elif direction == 'S':\n                direction = 'E'\n            elif direction == 'E':\n                direction = 'N'\n            elif direction == 'W':\n                direction = 'S'\n        elif move == 'R':\n            if direction == 'N':\n                direction = 'E'\n            elif direction == 'S':\n                direction = 'W'\n            elif direction == 'E':\n                direction = 'S'\n            elif direction == 'W':\n                direction = 'N'\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    x = 0\n    y = 0\n    angle = 0\n    for i in path:\n        if i == 'G':\n            if angle % 360 == 0:\n                x += 1\n            elif angle % 360 == 180:\n                x -= 1\n            elif angle % 360 == 90:\n                y += 1\n            else:\n                y -= 1\n        elif i == 'R':\n            angle += 90\n        elif i == 'L':\n            angle += 270\n    if x == 0 and y == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    dir = 'N'\n    y = 0\n    x = 0\n    for i in path:\n        if dir == 'N' and i == 'G':\n            y = y + 1\n        elif dir == 'E' and i == 'G':\n            x = x + 1\n        elif dir == 'S' and i == 'G':\n            y = y - 1\n        elif dir == 'W' and i == 'G':\n            x = x - 1\n        if dir == 'N' and i == 'L':\n            dir = 'W'\n        elif dir == 'N' and i == 'R':\n            dir = 'E'\n        elif dir == 'W' and i == 'L':\n            dir = 'S'\n        elif dir == 'W' and i == 'R':\n            dir = 'N'\n        elif dir == 'S' and i == 'L':\n            dir = 'E'\n        elif dir == 'S' and i == 'R':\n            dir = 'W'\n        elif dir == 'E' and i == 'L':\n            dir = 'N'\n        elif dir == 'E' and i == 'R':\n            dir = 'S'\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    dir = 0\n    xn = 0\n    yn = 0\n    for i in range(len(path)):\n        move = path[i]\n        if move == 'R':\n            dir = (dir + 1) % 4\n        elif move == 'L':\n            dir = (4 + dir - 1) % 4\n        elif dir == 0:\n            yn = yn + 1\n        elif dir == 1:\n            xn = xn + 1\n        elif dir == 2:\n            yn = yn - 1\n        else:\n            xn = xn - 1\n    if xn == 0 and yn == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    d = {0: [1, 0], 1: [0, 1], 2: [-1, 0], 3: [0, -1]}\n    position = [0, 0]\n    direction = 0\n    for item in path:\n        if item == 'G':\n            position[0] += d[direction][0]\n            position[1] += d[direction][1]\n        if item == 'L':\n            direction = (direction - 1) % 4\n        if item == 'R':\n            direction = (direction + 1) % 4\n    return 'Circular' if position == [0, 0] else 'Not Circular'", "def iscircular(path):\n    (i, j) = (0, 0)\n    d = 0\n    for x in path:\n        if x == 'G':\n            if d % 2 == 0:\n                i = i - 1 if d == 2 else i + 1\n            else:\n                j = j + 1 if d == 1 else j - 1\n        elif x == 'L':\n            d = (d + 1) % 4\n        else:\n            d = d - 1 if d != 0 else 3\n    if i == 0 and j == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    x_axis = 0\n    y_axis = 0\n    direction = 0\n    for char in path:\n        if char == 'L':\n            direction += 1\n        elif char == 'R':\n            direction -= 1\n        elif char == 'G':\n            if direction % 4 == 1:\n                x_axis += 1\n            elif direction % 4 == 2:\n                y_axis -= 1\n            elif direction % 4 == 3:\n                x_axis -= 1\n            elif direction % 4 == 0:\n                y_axis += 1\n    if x_axis == 0 and y_axis == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    x = 0\n    y = 0\n    dir = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    cur = 0\n    for i in path:\n        if i == 'G':\n            (movex, movey) = dir[cur]\n            x += movex\n            y += movey\n        elif i == 'L':\n            if cur == 0:\n                cur = 3\n            else:\n                cur -= 1\n        elif cur == 3:\n            cur = 0\n        else:\n            cur += 1\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    direc = ['left', 'up', 'right', 'down']\n    index = 1\n    start = [1, 1]\n    for i in path:\n        if i == 'G':\n            if direc[index] == 'up':\n                start[1] += 1\n            elif direc[index] == 'down':\n                start[1] -= 1\n            elif direc[index] == 'left':\n                start[0] -= 1\n            else:\n                start[0] += 1\n        elif i == 'L':\n            index -= 1\n            index %= 4\n        else:\n            index += 1\n            index %= 4\n    return 'Circular' if start[0] == 1 and start[1] == 1 else 'Not Circular'", "def iscircular(path):\n    N = 1\n    S = 2\n    E = 3\n    W = 4\n    curr = 1\n    x = 0\n    y = 0\n    for i in path:\n        if i == 'G':\n            if curr == 1:\n                y += 1\n            elif curr == 2:\n                y -= 1\n            elif curr == 3:\n                x += 1\n            else:\n                x -= 1\n        elif i == 'L':\n            if curr == N:\n                curr = W\n            elif curr == S:\n                curr = E\n            elif curr == E:\n                curr = N\n            elif curr == W:\n                curr = S\n        elif i == 'R':\n            if curr == N:\n                curr = E\n            elif curr == S:\n                curr = W\n            elif curr == E:\n                curr = S\n            elif curr == W:\n                curr = N\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    (x, y) = (0, 0)\n    (dirX, dirY) = (0, 1)\n    for p in path:\n        if p == 'G':\n            (x, y) = (x + dirX, y + dirY)\n        elif p == 'L':\n            (dirX, dirY) = (-1 * dirY, dirX)\n        else:\n            (dirX, dirY) = (dirY, -1 * dirX)\n    if (x, y) == (0, 0):\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    i = 0\n    j = 0\n    dir = 'E'\n    LL = ['E', 'S', 'W', 'N']\n    for c in path:\n        if c == 'G':\n            j += (dir == 'N') - (dir == 'S')\n            i += (dir == 'E') - (dir == 'W')\n        if c == 'R':\n            dir = LL[(LL.index(dir) + 1) % 4]\n        if c == 'L':\n            dir = LL[(LL.index(dir) - 1) % 4]\n    return 'Circular' if i == 0 and j == 0 else 'Not Circular'", "def iscircular(path):\n    x = 0\n    y = 0\n    dirc = 'R'\n    for i in path:\n        if i == 'G':\n            if dirc == 'R':\n                x += 1\n            elif dirc == 'U':\n                y += 1\n            elif dirc == 'L':\n                x -= 1\n            elif dirc == 'D':\n                y -= 1\n        elif i == 'L':\n            if dirc == 'R':\n                dirc = 'U'\n            elif dirc == 'U':\n                dirc = 'L'\n            elif dirc == 'L':\n                dirc = 'D'\n            elif dirc == 'D':\n                dirc = 'R'\n        elif i == 'R':\n            if dirc == 'R':\n                dirc = 'D'\n            elif dirc == 'U':\n                dirc = 'R'\n            elif dirc == 'L':\n                dirc = 'U'\n            elif dirc == 'D':\n                dirc = 'L'\n    if x == 0 and y == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    position = [0, 0]\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    dir_idx = 0\n    for a in path:\n        if a == 'G':\n            position[0] += directions[dir_idx][0]\n            position[1] += directions[dir_idx][1]\n        elif a == 'L':\n            dir_idx = (dir_idx - 1) % 4\n        elif a == 'R':\n            dir_idx = (dir_idx + 1) % 4\n    if position[0] == 0 and position[1] == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    curr = 0\n    (posx, posy) = (0, 0)\n    for char in path:\n        if char == 'G':\n            posx += dirs[curr][0]\n            posy += dirs[curr][1]\n        elif char == 'L':\n            curr -= 1\n            if curr == -1:\n                curr = 3\n        else:\n            curr += 1\n            if curr == 4:\n                curr = 0\n    if posx == 0 and posy == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    position = (0, 0)\n    current_orientation = 'u'\n    for move in path:\n        if move == 'G':\n            if current_orientation == 'u':\n                position = (position[0], position[1] + 1)\n            elif current_orientation == 'l':\n                position = (position[0] - 1, position[1])\n            elif current_orientation == 'r':\n                position = (position[0] + 1, position[1])\n            elif current_orientation == 'd':\n                position = (position[0], position[1] - 1)\n        if move == 'L':\n            if current_orientation == 'u':\n                current_orientation = 'l'\n            elif current_orientation == 'l':\n                current_orientation = 'd'\n            elif current_orientation == 'r':\n                current_orientation = 'u'\n            elif current_orientation == 'd':\n                current_orientation = 'r'\n        if move == 'R':\n            if current_orientation == 'u':\n                current_orientation = 'r'\n            elif current_orientation == 'l':\n                current_orientation = 'u'\n            elif current_orientation == 'r':\n                current_orientation = 'd'\n            elif current_orientation == 'd':\n                current_orientation = 'l'\n    if position == (0, 0):\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    x = 0\n    y = 0\n    dir = 0\n    for i in range(len(path)):\n        if path[i] == 'L':\n            dir = (4 + dir - 1) % 4\n        elif path[i] == 'R':\n            dir = (dir + 1) % 4\n        elif dir == 0:\n            y += 1\n        elif dir == 1:\n            x += 1\n        elif dir == 2:\n            y -= 1\n        else:\n            x -= 1\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    dirX = [1, 0, -1, 0]\n    dirY = [0, 1, 0, -1]\n    dir = 0\n    x = 0\n    y = 0\n    for i in path:\n        if i == 'G':\n            x += dirX[dir]\n            y += dirY[dir]\n        elif i == 'L':\n            dir = (dir - 1) % 4\n        else:\n            dir = (dir + 1) % 4\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    directions = {'E': ['N', 'S'], 'W': ['S', 'N'], 'N': ['W', 'E'], 'S': ['E', 'W']}\n    move = {'E': [1, 0], 'W': [-1, 0], 'N': [0, 1], 'S': [0, -1]}\n    (X, Y) = (0, 0)\n    towards = 'E'\n    for p in path:\n        if p == 'G':\n            X += move[towards][0]\n            Y += move[towards][1]\n        else:\n            towards = directions[towards][0] if p == 'L' else directions[towards][1]\n    return 'Circular' if not X and (not Y) else 'Not Circular'", "def iscircular(path):\n    (N, E, S, W) = (0, 1, 2, 3)\n    dire = N\n    (x, y) = (0, 0)\n    n = len(path)\n    for i in range(n):\n        move = path[i]\n        if move == 'R':\n            dire = (dire + 1) % 4\n        elif move == 'L':\n            dire = (4 + dire - 1) % 4\n        elif dire == N:\n            y += 1\n        elif dire == S:\n            y -= 1\n        elif dire == E:\n            x += 1\n        else:\n            x -= 1\n    if x == 0 and y == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    (dirx, diry) = (0, 1)\n    (x, y) = (0, 0)\n    for i in path:\n        if i == 'G':\n            (x, y) = (x + dirx, y + diry)\n        elif i == 'L':\n            (dirx, diry) = (-1 * diry, dirx)\n        else:\n            (dirx, diry) = (diry, -1 * dirx)\n    if (x, y) == (0, 0):\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    face_up = [0, 1]\n    face_d = [0, -1]\n    face_l = [-1, 0]\n    face_r = [1, 0]\n    n = len(path) // 4 + 1\n    dir = [face_up, face_l, face_d, face_r] * n\n    position = [0, 0]\n    current_pos = position\n    ind = 0\n    for i in path:\n        if i == 'L':\n            ind = ind + 1\n        elif i == 'R':\n            ind = ind - 1\n        else:\n            current_pos = [current_pos[0] + dir[ind][0], current_pos[1] + dir[ind][1]]\n    if current_pos == position:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    facing = 'N'\n    cord = [0, 0]\n    for i in path:\n        if i == 'G':\n            if facing == 'N':\n                cord[1] += 1\n            elif facing == 'S':\n                cord[1] -= 1\n            elif facing == 'E':\n                cord[0] += 1\n            else:\n                cord[0] -= 1\n        elif i == 'L':\n            if facing == 'N':\n                facing = 'W'\n            elif facing == 'S':\n                facing = 'E'\n            elif facing == 'E':\n                facing = 'N'\n            else:\n                facing = 'S'\n        elif facing == 'N':\n            facing = 'E'\n        elif facing == 'S':\n            facing = 'W'\n        elif facing == 'E':\n            facing = 'S'\n        else:\n            facing = 'N'\n    if cord[0] == cord[1] == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    (dx, dy) = (0, 1)\n    (x, y) = (0, 0)\n    for d in path:\n        if d == 'G':\n            (x, y) = (x + dx, y + dy)\n        elif d == 'L':\n            (dx, dy) = (-1 * dy, dx)\n        else:\n            (dx, dy) = (dy, -1 * dx)\n    if (x, y) == (0, 0):\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    (x, y) = (0, 0)\n    currDir = 'N'\n    for c in path:\n        if c == 'G':\n            if currDir == 'N':\n                x += 1\n            elif currDir == 'W':\n                y -= 1\n            elif currDir == 'E':\n                y += 1\n            else:\n                x -= 1\n        elif c == 'L':\n            if currDir == 'N':\n                currDir = 'W'\n            elif currDir == 'W':\n                currDir = 'S'\n            elif currDir == 'E':\n                currDir = 'N'\n            else:\n                currDir = 'E'\n        elif currDir == 'N':\n            currDir = 'E'\n        elif currDir == 'W':\n            currDir = 'N'\n        elif currDir == 'E':\n            currDir = 'S'\n        else:\n            currDir = 'W'\n    return 'Circular' if x == 0 and y == 0 else 'Not Circular'", "def iscircular(path):\n    dir_l = ['y+', 'x+', 'y-', 'x-']\n    d = {'y+': [0, 1], 'x+': [1, 0], 'y-': [0, -1], 'x-': [-1, 0]}\n    curr_dir = 'y+'\n    curr_co = [0, 0]\n    for i in path:\n        if i == 'G':\n            (add_x, add_y) = d[curr_dir]\n            curr_co = [curr_co[0] + add_x, curr_co[1] + add_y]\n        else:\n            curr_ind = dir_l.index(curr_dir)\n            if i == 'R':\n                if curr_ind + 1 == 4:\n                    curr_ind = 0\n                else:\n                    curr_ind += 1\n            elif curr_ind - 1 == -1:\n                curr_ind = 3\n            else:\n                curr_ind -= 1\n            curr_dir = dir_l[curr_ind]\n    if curr_co == [0, 0]:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    up = 0\n    down = 0\n    left = 0\n    right = 0\n    moving = 0\n    for move in path:\n        if move == 'G':\n            if moving == 0:\n                right = right + 1\n            elif moving == 1:\n                up = up + 1\n            elif moving == 2:\n                left = left + 1\n            else:\n                down = down + 1\n        elif move == 'R':\n            moving = (moving + 1) % 4\n        elif moving == 0:\n            moving = 3\n        else:\n            moving = moving - 1\n    if up - down + left - right == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    (x, y) = (0, 0)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    d = 0\n    for i in path:\n        if i == 'G':\n            x += directions[d % 4][0]\n            y += directions[d % 4][1]\n        elif i == 'L':\n            d -= 1\n        else:\n            d += 1\n    return 'Circular' if (x, y) == (0, 0) else 'Not Circular'", "N = 0\nE = 1\nS = 2\nW = 3\n\ndef case_E(x, y):\n    return (x + 1, y)\n\ndef case_W(x, y):\n    return (x - 1, y)\n\ndef case_N(x, y):\n    return (x, y + 1)\n\ndef case_S(x, y):\n    return (x, y - 1)\noptions = {E: case_E, W: case_W, N: case_N, S: case_S}\n\ndef iscircular(path):\n    x = y = 0\n    dir = N\n    for i in range(len(path)):\n        if path[i] == 'L':\n            dir = (dir + 4 - 1) % 4\n        elif path[i] == 'R':\n            dir = (dir + 1) % 4\n        else:\n            (x, y) = options[dir](x, y)\n    if x == 0 and y == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    (curr_loc, first_loc) = ([0, 0], [0, 0])\n    curr_dir = 'N'\n    for move in path:\n        if move == 'G':\n            if curr_dir == 'N':\n                curr_loc[1] += 1\n            elif curr_dir == 'S':\n                curr_loc[1] -= 1\n            elif curr_dir == 'E':\n                curr_loc[0] += 1\n            elif curr_dir == 'W':\n                curr_loc[0] -= 1\n        elif move == 'L':\n            if curr_dir == 'N':\n                curr_dir = 'W'\n            elif curr_dir == 'S':\n                curr_dir = 'E'\n            elif curr_dir == 'E':\n                curr_dir = 'N'\n            elif curr_dir == 'W':\n                curr_dir = 'S'\n        elif move == 'R':\n            if curr_dir == 'N':\n                curr_dir = 'E'\n            elif curr_dir == 'S':\n                curr_dir = 'W'\n            elif curr_dir == 'E':\n                curr_dir = 'S'\n            elif curr_dir == 'W':\n                curr_dir = 'N'\n    if curr_loc == first_loc:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "from collections import namedtuple\nPoint = namedtuple('Point', 'x y')\n\ndef turn(currentDirection, dest):\n    sign = 1 if dest == 'L' else -1\n    if currentDirection == (1, 0):\n        return Point(0, sign * 1)\n    elif currentDirection == (0, 1):\n        return Point(-1 * sign, 0)\n    elif currentDirection == (-1, 0):\n        return Point(0, -1 * sign)\n    elif currentDirection == (0, -1):\n        return Point(1 * sign, 0)\n    else:\n        return currentDirection\n\ndef iscircular(path):\n    p = Point(0, 0)\n    direction = Point(1, 0)\n    for e in path:\n        if e == 'G':\n            p = Point(p.x + direction.x, p.y + direction.y)\n        elif e == 'L':\n            direction = turn(direction, 'L')\n        elif e == 'R':\n            direction = turn(direction, 'R')\n    return 'Circular' if p == (0, 0) else 'Not Circular'", "def iscircular(path):\n    (x, y) = (0, 0)\n    directions = {'N': (0, 1), 'S': (0, -1), 'E': (1, 0), 'W': (-1, 0)}\n    pos = 'N'\n    n = len(path)\n    for i in range(n):\n        if path[i] == 'G':\n            x = x + directions[pos][0]\n            y = y + directions[pos][1]\n        elif path[i] == 'L':\n            if pos == 'N':\n                pos = 'W'\n            elif pos == 'W':\n                pos = 'S'\n            elif pos == 'S':\n                pos = 'E'\n            elif pos == 'E':\n                pos = 'N'\n        elif path[i] == 'R':\n            if pos == 'N':\n                pos = 'E'\n            elif pos == 'E':\n                pos = 'S'\n            elif pos == 'S':\n                pos = 'W'\n            elif pos == 'W':\n                pos = 'N'\n    return 'Circular' if x == 0 and y == 0 else 'Not Circular'", "def iscircular(path):\n    N = 1\n    E = 2\n    s = 3\n    w = 4\n    x = 0\n    y = 0\n    curr_dir = 1\n    for i in path:\n        if i == 'G':\n            if curr_dir == 1:\n                y += 1\n            elif curr_dir == 2:\n                x += 1\n            elif curr_dir == 3:\n                y -= 1\n            else:\n                x -= 1\n        elif i == 'L':\n            if curr_dir == 1:\n                curr_dir = 4\n            elif curr_dir == 2:\n                curr_dir = 1\n            elif curr_dir == 3:\n                curr_dir = 2\n            else:\n                curr_dir = 3\n        elif curr_dir == 1:\n            curr_dir = 2\n        elif curr_dir == 2:\n            curr_dir = 3\n        elif curr_dir == 3:\n            curr_dir = 4\n        else:\n            curr_dir = 1\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    pos = [0, 0]\n    ret = [0, 0]\n    dirleft = {'l': 'd', 'd': 'r', 'r': 'u', 'u': 'l'}\n    dirright = {'l': 'u', 'd': 'l', 'r': 'd', 'u': 'r'}\n    move = 'r'\n    for i in range(len(path)):\n        if path[i] == 'G':\n            if move == 'r':\n                pos[1] += 1\n            elif move == 'l':\n                pos[1] -= 1\n            elif move == 'u':\n                pos[0] -= 1\n            elif move == 'd':\n                pos[0] += 1\n        elif path[i] == 'L':\n            move = dirleft[move]\n        elif path[i] == 'R':\n            move = dirright[move]\n    if pos == ret:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    x = y = 0\n    (dx, dy) = (1, 0)\n    l = len(path)\n    for i in range(l):\n        if path[i] == 'L':\n            if dx == 1:\n                dx = 0\n                dy = 1\n            elif dy == 1:\n                dx = -1\n                dy = 0\n            elif dy == -1:\n                dx = 1\n                dy = 0\n            else:\n                dx = 0\n                dy = -1\n            continue\n        if path[i] == 'R':\n            if dx == 1:\n                dx = 0\n                dy = -1\n            elif dy == 1:\n                dx = 1\n                dy = 0\n            elif dy == -1:\n                dx = -1\n                dy = 0\n            else:\n                dx = 0\n                dy = 1\n            continue\n        x += dx\n        y += dy\n    if x == 0 and y == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    (x, y, direc) = (0, 0, 0)\n    for move in path:\n        if move == 'L':\n            direc = (4 + direc - 1) % 4\n        if move == 'R':\n            direc = (direc + 1) % 4\n        if move == 'G':\n            if direc == 0:\n                y += 1\n            elif direc == 1:\n                x += 1\n            elif direc == 2:\n                y -= 1\n            else:\n                x -= 1\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    (x, y) = (0, 0)\n    up = (0, 1)\n    down = (0, -1)\n    left = (-1, 0)\n    right = (1, 0)\n    left_turn = [down, left, up, right]\n    right_turn = [up, left, down, right]\n    current_direction = left\n    for i in range(len(path)):\n        if path[i] == 'G':\n            x += current_direction[0]\n            y += current_direction[1]\n        else:\n            if path[i] == 'L':\n                turn = left_turn\n            if path[i] == 'R':\n                turn = right_turn\n            index = turn.index(current_direction)\n            index = 0 if index == 3 else index + 1\n            current_direction = turn[index]\n    return 'Circular' if (x, y) == (0, 0) else 'Not Circular'", "def iscircular(path):\n    POSSIBLE_MOVEMENTS = {'N': [0, 1], 'S': [0, -1], 'E': [1, 0], 'W': [-1, 0]}\n    POSSIBLE_DIRECTION_CHANGES = {'N': {'L': 'W', 'R': 'E'}, 'S': {'L': 'E', 'R': 'W'}, 'E': {'L': 'N', 'R': 'S'}, 'W': {'L': 'S', 'R': 'N'}}\n    current_position = [0, 0]\n    current_direction = 'N'\n    for i in range(0, len(path)):\n        if path[i] == 'G':\n            current_position = self.addArrays(current_position, POSSIBLE_MOVEMENTS[current_direction])\n        else:\n            current_step = path[i]\n            current_options = POSSIBLE_DIRECTION_CHANGES[current_direction]\n            current_direction = current_options[current_step]\n    if current_position == [0, 0]:\n        return 'Circular'\n    return 'Not Circular'\n\ndef addArrays(arr1, arr2):\n    array = [arr1[0] + arr2[0], arr1[1] + arr2[1]]\n    return array", "def iscircular(path):\n    x_count = 0\n    y_count = 0\n    direction = 'x'\n    for char in path:\n        if char == 'G' and direction == 'x':\n            x_count += 1\n        elif char == 'G' and direction == '-x':\n            x_count -= 1\n        elif char == 'G' and direction == 'y':\n            y_count += 1\n        elif char == 'G' and direction == '-y':\n            y_count -= 1\n        if char == 'L' and direction == 'x':\n            direction = 'y'\n        elif char == 'L' and direction == 'y':\n            direction = '-x'\n        elif char == 'L' and direction == '-x':\n            direction = '-y'\n        elif char == 'L' and direction == '-y':\n            direction = 'x'\n        elif char == 'R' and direction == 'x':\n            direction = '-y'\n        elif char == 'R' and direction == 'y':\n            direction = 'x'\n        elif char == 'R' and direction == '-x':\n            direction = 'y'\n        elif char == 'R' and direction == '-y':\n            direction = '-x'\n    if x_count == 0 and y_count == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    state_map = {'x+ve': (1, 0), 'x-ve': (-1, 0), 'y+ve': (0, 1), 'y-ve': (0, -1)}\n    direct_map = {'x+ve': ('y+ve', 'y-ve'), 'x-ve': ('y-ve', 'y+ve'), 'y+ve': ('x-ve', 'x+ve'), 'y-ve': ('x+ve', 'x-ve')}\n    state = ('x+ve', (0, 0))\n    for char in path:\n        (direct, cord) = state\n        if char == 'G':\n            (dx, dy) = state_map[direct]\n            new_cord = (cord[0] + dx, cord[1] + dy)\n            new_state = (direct, new_cord)\n        else:\n            if char == 'L':\n                new_direct = direct_map[direct][0]\n            else:\n                new_direct = direct_map[direct][1]\n            new_state = (new_direct, cord)\n        state = new_state\n    return 'Circular' if state[1] == (0, 0) else 'Not Circular'", "def iscircular(path):\n    x = 0\n    y = 0\n    directions = ['N', 'E', 'S', 'W']\n    index = 0\n    for i in range(len(path)):\n        move = path[i]\n        if move == 'R':\n            index = (index + 1) % 4\n        elif move == 'L':\n            index = (4 + index - 1) % 4\n        else:\n            d = directions[index]\n            if d == 'N':\n                y += 1\n            elif d == 'E':\n                x += 1\n            elif d == 'S':\n                y -= 1\n            else:\n                x -= 1\n    return 'Circular' if x == 0 and y == 0 else 'Not Circular'", "def iscircular(path):\n    d = [[0, 1], [-1, 0], [0, -1], [1, 0]]\n    dir = 0\n    x = y = 0\n    for p in path:\n        if p == 'L':\n            dir = (dir + 1) % 4\n        elif p == 'R':\n            dir = (dir + 3) % 4\n        else:\n            (x, y) = (x + d[dir][0], y + d[dir][1])\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    i = 0\n    x = 0\n    y = 0\n    d = 0\n    while i < len(path):\n        if path[i] == 'L':\n            d -= 1\n            i += 1\n        elif path[i] == 'R':\n            d += 1\n            i += 1\n        elif path[i] == 'G':\n            d = d % 4\n            if d == -1 or d == 3:\n                x -= 1\n            elif d == 1 or d == -3:\n                x += 1\n            elif d == -2 or d == 2:\n                y -= 1\n            elif d == 0:\n                y += 1\n            i += 1\n    if x == 0 and y == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    directions = {'0': 0, '90': 0, '180': 0, '270': 0}\n    heading = 0\n    for step in path:\n        if step == 'G':\n            directions[str(heading)] = directions[str(heading)] + 1\n        elif step == 'L':\n            heading = (heading + 90) % 360\n        elif step == 'R':\n            heading = (heading - 90) % 360\n        if heading < 0:\n            heading = 360 + heading\n    if directions['0'] - directions['180'] + (directions['90'] - directions['270']) == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    final_pos = 0\n    (x, y) = (0, 0)\n    head = 1\n    for i in path:\n        if i == 'L' and head == 1:\n            head = 2\n        elif i == 'L' and head == 2:\n            head = 3\n        elif i == 'L' and head == 3:\n            head = 4\n        elif i == 'L' and head == 4:\n            head = 1\n        elif i == 'R' and head == 1:\n            head = 4\n        elif i == 'R' and head == 2:\n            head = 1\n        elif i == 'R' and head == 3:\n            head = 2\n        elif i == 'R' and head == 4:\n            head = 3\n        elif head == 1:\n            x += 1\n        elif head == 2:\n            y += 1\n        elif head == 3:\n            x -= 1\n        else:\n            y -= 1\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n\n    def walk(pathUnit, walkRecord, pointer):\n        if pointer == 3 and pathUnit == 'L':\n            pointer = 0\n        elif pointer == 0 and pathUnit == 'R':\n            pointer = 3\n        elif pathUnit == 'L':\n            pointer += 1\n        elif pathUnit == 'R':\n            pointer -= 1\n        if pathUnit == 'G':\n            if pointer == 0:\n                walkRecord[0] += 1\n            if pointer == 1:\n                walkRecord[1] += 1\n            if pointer == 2:\n                walkRecord[2] += 1\n            if pointer == 3:\n                walkRecord[3] += 1\n        return (walkRecord, pointer)\n    walkRecord = [0] * 4\n    pointer = 0\n    for pathUnit in path:\n        (walkRecord, pointer) = walk(pathUnit, walkRecord, pointer)\n    if walkRecord[0] + walkRecord[1] == walkRecord[2] + walkRecord[3]:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    (n, e, s, w) = (0, 1, 2, 3)\n    (x, y) = (0, 0)\n    d = n\n    for i in path:\n        if i == 'R':\n            d = (d + 1) % 4\n        elif i == 'L':\n            d = (4 + d - 1) % 4\n        elif d == n:\n            y += 1\n        elif d == e:\n            x += 1\n        elif d == s:\n            y -= 1\n        else:\n            x -= 1\n    if x == 0 and y == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    direction = 'right'\n    init_x = init_y = 0\n    for move in path:\n        if move == 'G':\n            if direction == 'right':\n                init_x += 1\n            elif direction == 'left':\n                init_x -= 1\n            elif direction == 'up':\n                init_y += 1\n            elif direction == 'down':\n                init_y -= 1\n        elif move == 'L':\n            if direction == 'right':\n                direction = 'up'\n            elif direction == 'up':\n                direction = 'left'\n            elif direction == 'left':\n                direction = 'down'\n            elif direction == 'down':\n                direction = 'right'\n        elif move == 'R':\n            if direction == 'right':\n                direction = 'down'\n            elif direction == 'down':\n                direction = 'left'\n            elif direction == 'left':\n                direction = 'up'\n            elif direction == 'up':\n                direction = 'right'\n    if init_x == init_y and init_x == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    direction = 'n'\n    n = 0\n    e = 0\n    s = 0\n    w = 0\n    for p in path:\n        if p == 'R':\n            if direction == 'n':\n                direction = 'e'\n            elif direction == 'e':\n                direction = 's'\n            elif direction == 's':\n                direction = 'w'\n            else:\n                direction = 'n'\n        elif p == 'L':\n            if direction == 'n':\n                direction = 'w'\n            elif direction == 'e':\n                direction = 'n'\n            elif direction == 's':\n                direction = 'e'\n            else:\n                direction = 's'\n        elif direction == 'n':\n            n += 1\n            if s > 0:\n                n -= 1\n                s -= 1\n        elif direction == 'e':\n            e += 1\n            if w > 0:\n                e -= 1\n                w -= 1\n        elif direction == 's':\n            s += 1\n            if n > 0:\n                n -= 1\n                s -= 1\n        else:\n            w += 1\n            if e > 0:\n                e -= 1\n                w -= 1\n    if n - s == 0 and e - w == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    x = 0\n    y = 0\n    face = 0\n    for chars in path:\n        if chars == 'G':\n            if face == 0:\n                x += 1\n            elif face == 1:\n                y += 1\n            elif face == 2:\n                x -= 1\n            else:\n                y -= 1\n        elif chars == 'L':\n            face += 1\n            face %= 4\n        elif chars == 'R':\n            face -= 1\n            if face < 0:\n                face = 3\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    if not 1 <= len(path) <= pow(10, 5):\n        return 'Not Circular'\n    position = [0, 0]\n    direction = 'North'\n    for s in path:\n        if s == 'L':\n            if direction == 'North':\n                direction = 'West'\n            elif direction == 'West':\n                direction = 'South'\n            elif direction == 'South':\n                direction = 'East'\n            elif direction == 'East':\n                direction = 'North'\n        if s == 'R':\n            if direction == 'North':\n                direction = 'East'\n            elif direction == 'East':\n                direction = 'South'\n            elif direction == 'South':\n                direction = 'West'\n            elif direction == 'West':\n                direction = 'North'\n        if s == 'G':\n            if direction == 'North':\n                position = [a + b for (a, b) in zip(position, [0, 1])]\n            elif direction == 'East':\n                position = [a + b for (a, b) in zip(position, [1, 0])]\n            elif direction == 'South':\n                position = [a + b for (a, b) in zip(position, [0, -1])]\n            elif direction == 'West':\n                position = [a + b for (a, b) in zip(position, [-1, 0])]\n    if position == [0, 0]:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def __init__():\n    self.x = 0\n    self.y = 0\n    self.direction = [0, 1]\n\ndef iscircular(path):\n    for c in path:\n        if c == 'G':\n            self.x += self.direction[0]\n            self.y += self.direction[1]\n        if c == 'L':\n            self.direction = [-1 * self.direction[1], self.direction[0] * 1]\n        if c == 'R':\n            self.direction = [1 * self.direction[1], self.direction[0] * -1]\n    if self.x == 0 and self.y == 0:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    N = 0\n    E = 1\n    S = 2\n    W = 3\n    x = 0\n    y = 0\n    direction = 0\n    for move in list(path):\n        if move == 'L':\n            direction = (direction + 1) % 4\n        elif move == 'R':\n            direction = (4 + direction - 1) % 4\n        else:\n            if direction == 0:\n                y += 1\n            if direction == 1:\n                x += 1\n            if direction == 2:\n                y -= 1\n            if direction == 3:\n                x -= 1\n    return 'Circular' if x == 0 and y == 0 else 'Not Circular'", "def iscircular(path):\n    dirn = 'E'\n    (x, y) = (0, 0)\n    for i in range(len(path)):\n        if path[i] == 'G':\n            if dirn == 'E':\n                y += 1\n            elif dirn == 'W':\n                y -= 1\n            elif dirn == 'N':\n                x -= 1\n            else:\n                x += 1\n        elif path[i] == 'L':\n            if dirn == 'E':\n                dirn = 'N'\n            elif dirn == 'W':\n                dirn = 'S'\n            elif dirn == 'N':\n                dirn = 'W'\n            else:\n                dirn = 'E'\n        elif dirn == 'E':\n            dirn = 'S'\n        elif dirn == 'W':\n            dirn = 'N'\n        elif dirn == 'N':\n            dirn = 'E'\n        else:\n            dirn = 'W'\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    loc = [0, 0]\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    current_dir = 0 % 4\n    for p in path:\n        if p == 'G':\n            loc[0] += dirs[current_dir][0]\n            loc[1] += dirs[current_dir][1]\n        elif p == 'L':\n            current_dir = (current_dir - 1) % 4\n        else:\n            current_dir = (current_dir + 1) % 4\n    return 'Circular' if loc == [0, 0] else 'Not Circular'", "def iscircular(path):\n    N = 0\n    E = 1\n    S = 2\n    W = 3\n    x = 0\n    y = 0\n    dir = N\n    for item in path:\n        if item == 'L':\n            dir = (4 + dir - 1) % 4\n        elif item == 'R':\n            dir = (dir + 1) % 4\n        elif dir == N:\n            y += 1\n        elif dir == E:\n            x += 1\n        elif dir == S:\n            y -= 1\n        else:\n            x -= 1\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    x = 0\n    y = 0\n    cp = 4\n    for ch in path:\n        if ch == 'L':\n            cp += 1\n        elif ch == 'R':\n            cp -= 1\n        elif cp % 4 == 0:\n            x += 1\n        elif cp % 4 == 1:\n            y += 1\n        elif cp % 4 == 2:\n            x -= 1\n        elif cp % 4 == 3:\n            y -= 1\n    if x == y and x == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(moves):\n    x = y = 0\n    present_direction = 0\n    for move in moves:\n        if move == 'L':\n            present_direction = (4 + present_direction - 1) % 4\n        elif move == 'R':\n            present_direction = (present_direction + 1) % 4\n        elif present_direction == 0:\n            y += 1\n        elif present_direction == 2:\n            y -= 1\n        elif present_direction == 3:\n            x += 1\n        else:\n            x -= 1\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    flag = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    cur = 1\n    init = (0, 0)\n    pos = (0, 0)\n    for c in path:\n        if c == 'G':\n            pos = tuple(map(lambda a, b: a + b, pos, flag[cur]))\n        elif c == 'L':\n            cur = (3 + cur) % 4\n        else:\n            cur = (1 + cur) % 4\n    if pos == init:\n        return 'Circular'\n    return 'Not Circular'", "def iscircular(path):\n    (x, y) = (0, 0)\n    currentDirection = 'N'\n    turn = {'NL': 'W', 'NR': 'E', 'EL': 'N', 'ER': 'S', 'SL': 'E', 'SR': 'W', 'WL': 'S', 'WR': 'N'}\n    for i in path:\n        if i == 'G':\n            if currentDirection == 'N':\n                x += 1\n            elif currentDirection == 'S':\n                x -= 1\n            elif currentDirection == 'E':\n                y += 1\n            elif currentDirection == 'W':\n                y -= 1\n        else:\n            currentDirection = turn[currentDirection + i]\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(list_of_commands):\n    compass = 0\n    orientation = 'N'\n    x = 0\n    y = 0\n    for command in list_of_commands:\n        if command == 'G':\n            if orientation == 'N':\n                y += 1\n            if orientation == 'S':\n                y -= 1\n            if orientation == 'E':\n                x += 1\n            if orientation == 'W':\n                x -= 1\n        if command == 'L':\n            if compass == 0:\n                compass = 3\n            else:\n                compass -= 1\n        if command == 'R':\n            if compass == 3:\n                compass = 0\n            else:\n                compass += 1\n        if compass == 0:\n            orientation = 'N'\n        if compass == 1:\n            orientation = 'E'\n        if compass == 2:\n            orientation = 'S'\n        if compass == 3:\n            orientation = 'W'\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    dir = 'east'\n    x = 0\n    y = 0\n    for i in path:\n        if i == 'L':\n            if dir == 'east':\n                dir = ''\n                dir = 'north'\n            elif dir == 'north':\n                dir = ''\n                dir = 'west'\n            elif dir == 'west':\n                dir = ''\n                dir = 'south'\n            elif dir == 'south':\n                dir = ''\n                dir = 'east'\n        elif i == 'R':\n            if dir == 'east':\n                dir = ''\n                dir = 'south'\n            elif dir == 'south':\n                dir = ''\n                dir = 'west'\n            elif dir == 'west':\n                dir = ''\n                dir = 'north'\n            elif dir == 'north':\n                dir = ''\n                dir = 'east'\n        elif i == 'G':\n            if dir == 'east':\n                x = x + 1\n            elif dir == 'west':\n                x = x - 1\n            elif dir == 'north':\n                y = y + 1\n            elif dir == 'south':\n                y = y - 1\n    if x == 0 and y == 0:\n        return 'Circular'\n    else:\n        return 'Not Circular'", "def iscircular(path):\n    start = [0, 0]\n    modify = 'X+'\n    nextmodify = {('X+', 'L'): 'Y+', ('X+', 'R'): 'Y-', ('X-', 'L'): 'Y-', ('X-', 'R'): 'Y+', ('Y+', 'L'): 'X-', ('Y+', 'R'): 'X+', ('Y-', 'L'): 'X+', ('Y-', 'R'): 'X-'}\n    for move in path:\n        if move == 'G':\n            if modify == 'X+':\n                start[0] = start[0] + 1\n            elif modify == 'X-':\n                start[0] = start[0] - 1\n            elif modify == 'Y+':\n                start[1] = start[1] + 1\n            elif modify == 'Y-':\n                start[1] = start[1] - 1\n        else:\n            modify = nextmodify[modify, move]\n    return 'Circular' if start[0] == 0 and start[1] == 0 else 'Not Circular'"], "starter_code": "def iscircular(path):\n", "input_output": {"inputs": ["path = \"GLGLGLG\"", "path = \"GGGGL\""], "outputs": ["\"Circular\"", "\"Not Circular\""]}, "difficulty": "EASY", "raw_tags": ["Data Structures", "Strings"], "name": null, "source": "geeksforgeeks", "tags": ["String algorithms", "Data structures"], "skill_types": ["Data structures"], "url": "https://practice.geeksforgeeks.org/problems/does-robot-moves-circular0414/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(|S|)", "entry_point": "iscircular", "task_id": "TACO_lite/44"}
{"requirement": "Given an array Arr of N positive integers. Your task is to find the elements whose value is equal to that of its index value ( Consider 1-based indexing ).\nNote: There can be more than one element in the array which have the same value as its index. You need to include every such element's index. Follows 1-based indexing of the array. \nExample 1:\nInput:\nN = 5\nArr[] = {15, 2, 45, 12, 7}\nOutput: 2\nExplanation: Only Arr[2] = 2 exists here.\nExample 2:\nInput: \nN = 1\nArr[] = {1}\nOutput: 1\nExplanation: Here Arr[1] = 1 exists.\nYour Task:  \nYou don't need to read input or print anything. Your task is to complete the function valueEqualToIndex() which takes the array of integers arr[] and n as parameters and returns an array of indices where the given conditions are satisfied. When there is no such element exists then return an empty array of length 0.\nExpected Time Complexity: O(N)\nExpected Auxiliary Space: O(1)\n \nConstraints:\n1 ≤ N ≤ 10^{5}\n1 ≤ Arr[i] ≤ 10^{6}", "solutions": ["def valueequaltoindex(arr, n):\n    final = []\n    for (i, ele) in enumerate(arr):\n        if ele == i + 1:\n            final.append(ele)\n    return final", "def valueequaltoindex(arr, n):\n    ans = []\n    for i in range(n):\n        if arr[i] == i + 1:\n            ans.append(arr[i])\n    return ans", "def valueequaltoindex(arr, n):\n    li = []\n    for i in range(0, n):\n        if arr[i] == i + 1:\n            li.append(arr[i])\n    if len(li) == 0:\n        return []\n    else:\n        return li", "def valueequaltoindex(arr, n):\n    mylist = []\n    i = 1\n    for a in arr:\n        if i == a:\n            mylist.append(a)\n        i = i + 1\n    return mylist", "def valueequaltoindex(arr, n):\n    val = []\n    for i in range(0, n):\n        if arr[i] == i + 1:\n            val.append(arr[i])\n    return val", "def valueequaltoindex(arr, n):\n    indarr = []\n    count = 0\n    for i in arr:\n        count += 1\n        if i == count:\n            indarr.append(count)\n    return indarr", "def valueequaltoindex(arr, n):\n    val = []\n    for (i, n) in enumerate(arr, start=1):\n        if i == n:\n            val.append(n)\n    return val", "def valueequaltoindex(arr, n):\n    y = []\n    z = []\n    for i in range(n):\n        if arr[i] == i + 1:\n            y.append(arr[i])\n    return y", "def valueequaltoindex(arr, n):\n    result = []\n    for i in range(len(arr)):\n        if arr[i] == i + 1:\n            result.append(arr[i])\n    return result", "def valueequaltoindex(arr, n):\n    output = []\n    for i in range(0, n):\n        if arr[i] == i + 1:\n            output.append(arr[i])\n    if len(output) > 0:\n        return output\n    else:\n        return ['Not Found']", "def valueequaltoindex(arr, n):\n    sol = []\n    i = 0\n    while i < n:\n        if i + 1 == arr[i]:\n            sol.append(i + 1)\n        i += 1\n    return sol", "def valueequaltoindex(arr, n):\n    output = []\n    for index in range(n):\n        if arr[index] == index + 1:\n            output.append(arr[index])\n    return output", "def valueequaltoindex(arr, n):\n    ar2 = []\n    c = 1\n    for i in arr:\n        if i == c:\n            ar2.append(i)\n        c += 1\n    return ar2", "def valueequaltoindex(arr, n):\n    lis = list()\n    for i in range(0, n):\n        if arr[i] == i + 1:\n            lis.append(arr[i])\n    return lis", "def valueequaltoindex(arr, n):\n    r = []\n    v = sorted(arr)\n    n = len(arr)\n    for i in range(1, len(arr) + 1):\n        if i == arr[i - 1]:\n            r.append(i)\n    return r", "def valueequaltoindex(arr, n):\n    flag = 0\n    w = 0\n    a = []\n    b = []\n    for i in range(len(arr)):\n        if arr[i] == i + 1:\n            w = arr[i]\n            flag += 1\n            a.append(arr[i])\n    if flag > 0:\n        return a\n    else:\n        return b", "def valueequaltoindex(arr, n):\n    res = []\n    for (i, e) in enumerate(arr):\n        if i + 1 == e:\n            res.append(e)\n    return res", "def valueequaltoindex(arr, n):\n    return [value for (index, value) in enumerate(arr) if value == index + 1]", "def valueequaltoindex(arr, n):\n    answer = []\n    for (i, num) in enumerate(arr):\n        if num == i + 1:\n            answer.append(num)\n    return answer", "def valueequaltoindex(arr, n):\n    newarr = []\n    index = 0\n    i = 0\n    for index in range(n):\n        if arr[index] == index + 1:\n            newarr.append(index + 1)\n            i = i + 1\n    return newarr", "def valueequaltoindex(arr, n):\n    list = []\n    temp = 1\n    for i in arr:\n        if i == temp:\n            list.append(i)\n        temp += 1\n    return list", "def valueequaltoindex(arr, n):\n    ans = []\n    for (idx, num) in enumerate(arr):\n        if idx + 1 == num:\n            ans.append(num)\n    return ans", "def valueequaltoindex(arr, n):\n    if n == 0:\n        return -1\n    if n == 1:\n        if n[0] == 1:\n            return 1\n        else:\n            return -1\n    if n > 1:\n        indexes = []\n        for (ind, value) in enumerate(arr):\n            i = ind + 1\n            if i == value:\n                indexes.append(i)\n        return indexes", "def valueequaltoindex(arr, n):\n    arr = list(arr)\n    output = []\n    index = 1\n    while index <= n:\n        if index == arr[index - 1]:\n            output.append(index)\n        index += 1\n    return output", "def valueequaltoindex(arr, n):\n    arr1 = []\n    for i in range(len(arr)):\n        if arr[i] == i + 1:\n            arr1.append(arr[i])\n        else:\n            continue\n    return arr1"], "starter_code": "def valueequaltoindex(arr, n):\n", "input_output": {"inputs": ["N = 5\r\nArr[] = {15, 2, 45, 12, 7}", "N = 1\r\nArr[] = {1}"], "outputs": ["2", "1"]}, "difficulty": "EASY", "raw_tags": ["Data Structures", "Arrays", "Searching", "Algorithms"], "name": null, "source": "geeksforgeeks", "tags": ["Data structures", "Complete search"], "skill_types": ["Data structures", "Complete search"], "url": "https://practice.geeksforgeeks.org/problems/value-equal-to-index-value1330/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N)", "entry_point": "valueequaltoindex", "task_id": "TACO_lite/45"}
{"requirement": "Given an array A[]of size N. Let us call difference between indices of an element's first and last appearance in the array A[] a gap. Find the maximum possible gap.  Note that if any element appears only once, then the gap for that element is 0.\n \nExample 1:\nInput:\nN = 9\nA[] = {2, 1, 3, 4, 2, 1, 5, 1, 7}\nOutput:\n6\nExplanation:\nFor the above test case (Assuming 0-based indexing): \nNumber 1's first appearance is at index 1 and last appearance is at index 7. This implies gap is 7-1=6\nThis is the maximum possible in the given test case.\n \nYour Task:  \nYou don't need to read input or print anything. Your task is to complete the function leftIndex() which takes the array A[] and its size N as inputs and returns the Maximum Difference.\n \nExpected Time Complexity: O(N. Log(N))\nExpected Auxiliary Space: O(N)\n \nConstraints:\n1<=N<=10^{5}\n-10^{5}<=A_{i}<=10^{5}", "solutions": ["import math\n\ndef maxdiffindex(A, N):\n    maxi = -math.inf\n    dicti = {}\n    for i in range(N):\n        if A[i] not in dicti:\n            dicti[A[i]] = i\n        else:\n            maxi = max(maxi, i - dicti[A[i]])\n    if maxi == -math.inf:\n        return 0\n    return maxi", "def maxdiffindex(A, N):\n    diff = 0\n    dict_ = {}\n    for index in range(N):\n        elem = A[index]\n        ind = dict_.get(elem, -1)\n        if ind == -1:\n            dict_.update({elem: index})\n        else:\n            current_diff = index - dict_[elem]\n            diff = index - dict_[elem] if diff < current_diff else diff\n    return diff", "def maxdiffindex(A, N):\n    d = {}\n    id = 0\n    for i in range(N):\n        if A[i] not in d:\n            d[A[i]] = i\n        elif i - d[A[i]] > id:\n            id = i - d[A[i]]\n    return id", "def maxdiffindex(A, N):\n    B = list(reversed(A))\n    maxi = 0\n    visited = set()\n    i = -1\n    while i + maxi < N - 1:\n        i += 1\n        if A[i] in visited:\n            continue\n        visited.add(A[i])\n        diff = N - 1 - i - B.index(A[i])\n        if diff > maxi:\n            maxi = diff\n    return maxi", "def maxdiffindex(A, N):\n    maxi = 0\n    rev = A[::-1]\n    for i in list(set(A)):\n        fir = A.index(i)\n        las = rev.index(i)\n        las = len(A) - las - 1\n        maxi = max(maxi, las - fir)\n    return maxi", "def maxdiffindex(A, N):\n    d1 = {}\n    d2 = {}\n    for i in range(len(A)):\n        if A[i] not in d1:\n            d1[A[i]] = i\n    for i in reversed(range(len(A))):\n        if A[i] not in d2:\n            d2[A[i]] = i\n    maximum = -987654321\n    for (k, v) in d1.items():\n        maximum = max(maximum, d2[k] - v)\n    return maximum", "def maxdiffindex(A, N):\n    result = []\n    dict = {}\n    for i in range(N):\n        dict[A[i]] = i\n    for j in range(N):\n        value = abs(dict[A[j]] - j)\n        result.append(value)\n    return max(result)", "def maxdiffindex(A, N):\n    maxi = 0\n    temp = {}\n    for i in range(N):\n        if A[i] not in temp:\n            temp[A[i]] = i\n        else:\n            maxi = max(maxi, i - temp[A[i]])\n    return maxi", "from collections import defaultdict\n\ndef maxdiffindex(A, N):\n    di = defaultdict(list)\n    ans = []\n    for i in range(N):\n        di[A[i]].append(i)\n    values = di.values()\n    for i in values:\n        if len(i) == 1:\n            continue\n        else:\n            ans.append(i[-1] - i[0])\n    if len(ans) != 0:\n        return max(ans)\n    else:\n        return 0", "def maxdiffindex(A, N):\n    m = {}\n    for i in range(len(A)):\n        m[A[i]] = i\n    A = A[::-1]\n    d = {}\n    for j in range(len(A)):\n        d[A[j]] = N - j - 1\n    r = sorted(m.items())\n    r = dict(r)\n    e = sorted(d.items())\n    e = dict(e)\n    u = []\n    v = []\n    for (x, y) in r.items():\n        u.append(y)\n    for (x, y) in e.items():\n        v.append(y)\n    h = []\n    for k in range(len(u)):\n        h.append(abs(u[k] - v[k]))\n    return max(h)", "def maxdiffindex(A, N):\n    first = {}\n    last = {}\n    max_diff = -123456789\n    for i in range(N):\n        if A[i] not in first:\n            first[A[i]] = i\n        if A[i] not in last:\n            last[A[i]] = i\n        else:\n            last[A[i]] = i\n    for key in first:\n        diff = last[key] - first[key]\n        max_diff = max(max_diff, diff)\n    return max_diff", "def maxdiffindex(A, N):\n    d = {}\n    for i in range(N):\n        a = A[i]\n        if a not in d:\n            d[a] = [i]\n        else:\n            d[a].append(i)\n    x = []\n    for i in d:\n        b = d[i]\n        x.append(b[-1] - b[0])\n    return max(x)", "def maxdiffindex(A, N):\n    h = {}\n    for i in range(N):\n        if A[i] not in h:\n            h[A[i]] = [i]\n        else:\n            h[A[i]] += [i]\n    ans = []\n    for i in h:\n        if len(h[i]) == 1:\n            ans.append(0)\n        else:\n            ans.append(h[i][-1] - h[i][0])\n    return max(ans)", "def maxdiffindex(A, N):\n    d = {}\n    for i in range(N):\n        if A[i] not in d:\n            d[A[i]] = i\n    ans = 0\n    for i in range(N - 1, -1, -1):\n        if A[i] in d:\n            ans = max(ans, i - d[A[i]])\n    return ans", "def maxdiffindex(A, N):\n    d = {}\n    mx = 0\n    for i in range(N):\n        if A[i] in d:\n            mx = max(abs(d[A[i]] - i), mx)\n        else:\n            d[A[i]] = i\n    return mx", "def maxdiffindex(arr, n):\n    d = dict()\n    res = 0\n    for i in range(n):\n        if arr[i] in d:\n            res = max(res, i - d[arr[i]])\n        else:\n            d[arr[i]] = i\n    return res", "def maxdiffindex(A, N):\n    max_diff = 0\n    d = {}\n    for i in range(N):\n        if A[i] not in d:\n            d[A[i]] = i\n        else:\n            max_diff = max(max_diff, i - d[A[i]])\n    return max_diff", "def maxdiffindex(A, N):\n    d = {}\n    f = {}\n    for i in range(len(A)):\n        if A[i] not in d:\n            d[A[i]] = i\n        else:\n            continue\n    for i in range(len(A) - 1, -1, -1):\n        if A[i] not in f:\n            f[A[i]] = i\n        else:\n            continue\n    max_val = -9999\n    for key in d.keys():\n        if abs(d[key] - f[key]) > max_val:\n            max_val = abs(d[key] - f[key])\n    return max_val"], "starter_code": "def maxdiffindex(A, N):\n", "input_output": {"inputs": ["N = 9\nA[] = {2, 1, 3, 4, 2, 1, 5, 1, 7}"], "outputs": ["6"]}, "difficulty": "EASY", "raw_tags": ["Map", "Arrays", "Data Structures"], "name": null, "source": "geeksforgeeks", "tags": ["Data structures"], "skill_types": ["Data structures"], "url": "https://practice.geeksforgeeks.org/problems/maximum-difference-10429/1", "Expected Auxiliary Space": "O(N)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N. Log(N))", "entry_point": "maxdiffindex", "task_id": "TACO_lite/46"}
{"requirement": "Imagine there's a big cube consisting of n^3 small cubes. Calculate, how many small cubes are not visible from outside.\n\nFor example, if we have a cube which has 4 cubes in a row, then the function should return 8, because there are 8 cubes inside our cube (2 cubes in each dimension)", "solutions": ["def not_visible_cubes(n):\n    return max(n - 2, 0) ** 3", "def not_visible_cubes(n):\n    if n > 1:\n        return (n - 2) ** 3\n    else:\n        return 0", "def not_visible_cubes(n):\n    if 0 <= n <= 2:\n        return 0\n    return (n - 2) ** 3", "import math\n\ndef not_visible_cubes(n):\n    if n < 2:\n        return 0\n    else:\n        return (n - 2) * (n - 2) * (n - 2)", "def not_visible_cubes(n):\n    return pow(n - 2, 3) if n > 2 else 0", "def not_visible_cubes(n):\n    return n > 2 and (n - 2) ** 3", "def not_visible_cubes(n):\n    if n == 0 or n == 1 or n == 2:\n        return 0\n    totalCubes = n * n * n\n    cubesPerSide = n * n\n    outsideCubes = cubesPerSide + 2 * (cubesPerSide - n) + cubesPerSide - 2 * n + 2 * (cubesPerSide - (n + 2 * (n - 1) + n - 2))\n    return totalCubes - outsideCubes"], "starter_code": "def not_visible_cubes(n):\n", "input_output": {"fn_name": "not_visible_cubes", "inputs": [[0], [1], [2], [3], [4], [5], [7], [12], [18], [10002]], "outputs": [[0], [0], [0], [1], [8], [27], [125], [1000], [4096], [1000000000000]]}, "difficulty": "EASY", "raw_tags": ["Puzzles"], "name": null, "source": "codewars", "tags": ["Ad-hoc"], "skill_types": [], "url": "https://www.codewars.com/kata/560d6ebe7a8c737c52000084", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "not_visible_cubes", "task_id": "TACO_lite/47"}
{"requirement": "Given an array arr[] of size N, find the first digit from the left of the product of these N integers.\nExample 1:\nInput: N = 4, arr[] = {5, 8, 3, 7}\nOutput: 8\nExplanation: Produt is 840\nExample 2:\nInput: N = 3, arr[] = {6, 7, 9} \nOutput: 3\nExplanation: Produt is 378\n \nYour Task:\nYou don't need to read input or print anything. Your task is to complete the function firstDigit() which takes N and array arr[] as input parameters and returns the left digit of product.\nExpected Time Complexity: O(N)\nExpected Auxiliary Space: O(1)\nConstraints:\n1 ≤ N, arr[i] ≤ 10^{5}\nTest cases have been designed such that there is no precision ambiguity.", "solutions": ["def firstdigit(arr, n):\n    p = 1\n    for i in range(n):\n        p = p * arr[i]\n        d = str(p)\n        p = int(d[:6])\n    return str(p)[0]", "def firstdigit(arr, n):\n    val = 1\n    for i in arr:\n        val *= i\n        st = str(val)\n        val = int(st[:6])\n    return str(val)[0]", "import math\n\ndef firstdigit(arr, n):\n    s = 0.0\n    for a in arr:\n        s += math.log10(a)\n    s = s - math.floor(s)\n    return int(math.pow(10, s) + 1e-06)", "import math\n\ndef firstdigit(arr, n):\n    res = 1\n    for i in arr:\n        res = res * i\n    dig = int(math.log10(res))\n    return res // 10 ** dig", "def firstdigit(arr, n):\n    s = 1\n    for i in range(n):\n        s = s * arr[i]\n        m = str(s)\n        s = int(m[:6])\n    return str(s)[0]", "import math\n\ndef firstdigit(arr, n):\n    S = 0\n    if n == 1:\n        s = str(arr[0])\n        return s[0]\n    else:\n        for i in arr:\n            S = S + math.log10(i * 1.0)\n        fract_S = S - math.floor(S)\n        ans = math.pow(10, fract_S)\n        return int(ans)", "import functools as f\n\ndef firstdigit(arr, n):\n    p = 1\n    for i in range(n):\n        p = p * arr[i]\n        d = str(p)\n        p = int(d[:8])\n    return str(p)[0]", "import math\n\ndef firstdigit(arr, n):\n    product = 1\n    for i in range(0, n):\n        product = product * arr[i]\n    digit = product // 10 ** int(math.log10(product))\n    return digit", "import math\n\ndef firstdigit(arr, n):\n    S = 0\n    for i in range(n):\n        S += math.log(arr[i], 10)\n    S += 1e-06\n    S -= math.floor(S)\n    ans = int(pow(10, S))\n    return ans", "import math\n\ndef firstdigit(arr, n):\n    if n == 1:\n        return str(arr[0])[0]\n    s = 0\n    for val in arr:\n        s = s + math.log10(val * 1.0)\n    frac = s - math.floor(s)\n    return int(math.pow(10, frac))"], "starter_code": "def firstdigit(arr, n):\n", "input_output": {"inputs": ["N = 4, arr[] = {5, 8, 3, 7}", "N = 3, arr[] = {6, 7, 9}"], "outputs": ["8", "3"]}, "difficulty": "MEDIUM", "raw_tags": ["Algorithms", "Mathematical"], "name": null, "source": "geeksforgeeks", "tags": ["Mathematics"], "skill_types": [], "url": "https://practice.geeksforgeeks.org/problems/first-digit1751/1", "Expected Auxiliary Space": "O(1)", "time_limit": null, "date": null, "picture_num": "0", "memory_limit": null, "Expected Time Complexity": "O(N)", "entry_point": "firstdigit", "task_id": "TACO_lite/48"}
{"requirement": "# Description\nYou are required to implement a function `find_nth_occurrence` that returns the index of the nth occurrence of a substring within a string (considering that those substring could overlap each others). If there are less than n occurrences of the substring, return -1.\n\n# Example\n```python\nstring = \"This is an example. Return the nth occurrence of example in this example string.\"\nfind_nth_occurrence(\"example\", string, 1) == 11\nfind_nth_occurrence(\"example\", string, 2) == 49\nfind_nth_occurrence(\"example\", string, 3) == 65\nfind_nth_occurrence(\"example\", string, 4) == -1\n```\n\nMultiple occurrences of a substring are allowed to overlap, e.g.\n```python\nfind_nth_occurrence(\"TestTest\", \"TestTestTestTest\", 1) == 0\nfind_nth_occurrence(\"TestTest\", \"TestTestTestTest\", 2) == 4\nfind_nth_occurrence(\"TestTest\", \"TestTestTestTest\", 3) == 8\nfind_nth_occurrence(\"TestTest\", \"TestTestTestTest\", 4) == -1\n```", "solutions": ["def find_nth_occurrence(substring, string, occurrence=1):\n    idx = -1\n    for i in range(occurrence):\n        idx = string.find(substring, idx + 1)\n        if idx == -1:\n            return -1\n    return idx", "import re\n\ndef find_nth_occurrence(sb, s, n=1):\n    r = list(re.finditer('(?=' + sb + ')', s))\n    return r[n - 1].span()[0] if n <= len(r) else -1", "import re\n\ndef find_nth_occurrence(substring, string, occurrence):\n    try:\n        return [s.start() for s in re.finditer('(?=' + substring + ')', string)][occurrence - 1]\n    except:\n        return -1", "def find_nth_occurrence(substring, string, occurrence=1):\n    i = -1\n    for _ in range(occurrence):\n        i = string.find(substring, i + 1)\n        if i == -1:\n            break\n    return i", "def find_nth_occurrence(substring, string, occurrence=1):\n    index = -1\n    for occ in range(0, occurrence):\n        index = string.find(substring, index + 1)\n    return index", "def find_nth_occurrence(w, s, n=1, k=0):\n    for i in range(len(s)):\n        if s[i:i + len(w)] == w:\n            k += 1\n            if k == n:\n                return i\n    else:\n        return -1", "def find_nth_occurrence(substring, string, occurrence=1):\n    indicies = [i for i in range(len(string)) if string.startswith(substring, i)]\n    if occurrence > len(indicies):\n        return -1\n    else:\n        return indicies[occurrence - 1]", "import re\n\ndef find_nth_occurrence(substring, string, occurrence=1):\n    try:\n        return [m.start() for m in re.finditer(f'(?={substring})', string)][occurrence - 1]\n    except:\n        return -1", "def find_nth_occurrence(substring, string, occurrence=1):\n    (c, i) = (1, string.find(substring))\n    while c < occurrence and i > -1:\n        (c, i) = (c + 1, string.find(substring, i + 1))\n    return i", "def find_nth_occurrence(substring, string, occurrence):\n    a = string.find(substring)\n    while a >= 0 and occurrence > 1:\n        a = string.find(substring, a + 1)\n        occurrence -= 1\n    return a"], "starter_code": "def find_nth_occurrence(substring, string, occurrence=1):\n", "input_output": {"fn_name": "find_nth_occurrence", "inputs": [], "outputs": []}, "difficulty": "EASY", "raw_tags": ["Fundamentals"], "name": null, "source": "codewars", "tags": ["Fundamentals"], "skill_types": [], "url": "https://www.codewars.com/kata/5b1d1812b6989d61bd00004f", "Expected Auxiliary Space": null, "time_limit": null, "date": null, "picture_num": null, "memory_limit": null, "Expected Time Complexity": null, "entry_point": "find_nth_occurrence", "task_id": "TACO_lite/49"}
